# toolbox

I've made this toolbox to accomplish several things.

## 1. Convenience

This is to make a quick-reference, a type of link-based [commonplace book](https://en.wikipedia.org/wiki/Commonplace_book).

Since we don't write essays in machine code, _everyone_ exploits an abstraction when using computers. An OS is the equivalent of a vastly complicated multitool, but with modular pieces with use cases that range from a rocket ship to a chainsaw.

With the web, most people will download something, use it, then promptly forget about it. Then, months or years later, they'll rediscover it while researching a solution, then promptly forget it again. Repeat.

So, this makes my life convenient.

## 2. Awareness

I'm fairly certain many people remake existing software because they don't realize someone already made it.

Obviously, that's not _always_ true:

- Refactoring is complicated, and it's often hard to find _precisely_ what you want.
- Some software developers want to test to themselves/others whether they're smart.
- Sometimes it's very educational or downright _fun_ to reinvent the wheel.
- If someone has severe trust issues, they'll make an open-source or de-(thing) version of that thing.

However, if I need something to stretch audio or batch-compare files, my largest mental hurdle is knowing it even _exists_. Even when a tool is obsolete, placed behind a paywall, merged into some other software suite, or just plain forgotten, that idea lives on and someone else will usually pick up the torch.

## 3. Future Convenience

I _might_ find lots of things here useful someday, but I don't feel like dragging around 4 terabytes of constantly updating programs just to know where they are.

So, this is a bit like a hoarder's barn, but collects less dust and is proportionally smaller. I will probably not use 95% of the stuff here, but someone else might, and I might run across them.

## Rules

For brevity's sake, I'm mostly glossing over a few groups:

- The built-in tools. If I need them, they're in the computer already.
- Paid tools, when they cost enough that it makes me pause to consider my budget.
- Most courses and courseware, since I'm convinced most of that is part of a _constantly_ revolving cycle of technology fashions (Remember when Java and Netscape was going to run the world forever? By contrast, how about web browsers and corporation-endorsed programming languages?)

I've broken everything into malleable groupings, since there are _many_ things that someone could use a computer for, and people are constantly adding new things. These groupings are somewhat arbitrary:

- Audio: to work with sound for some intended aesthetic
- Communicating: to communicate with other people, directly or indirectly
- Files/OS: to manage computer files or operating systems
- Games: to work with games
- Hardware: to make or manage physical things, which includes computer hardware
- Internet: a sub-division of computer networking that has its own subdomains
- Math: for calculation-specific needs
- Text: to work with language for some intended aesthetic
- Visual: to visually design or adapt things which contain some intended aesthetic

- Productivity: to broadly streamline doing any of the above

Further, there are some patterns that keep cropping up in each domain:

- Consuming: human consumption only, without modification to it
- CySec: protecting bad things from happening
- Foraging: to acquire others' creative works

Also further, some things are all-pervasive sporks:

- Dev: to broadly make or manage computer code, which may refer to front-end or back-end, be language-specific, and may simply be a more nuanced version of any of the above

## Earmarks

- _*_ if it's something to copy-paste or a reference sheet.
- ☁ for browser-based apps, ⇉ for a browser/software plugin or extension
- Desktop: ⊞ for Windows, ⌘ for Mac OS X, 🐧 for Linux and Friends.
- Mobile: 🤖 for Android, 🍎 for iOS.
- □ for non-UI CLI-based tools, often requires [programming experience](https://techsplained.xyz/prog-basics).
- ■ for standalone files or portable Windows apps (many through [PortableApps.com](https://portableapps.com/)).
- 🐍 if it runs in Python
- 🔌 if it's an API or has API documentation
- ⦿ for a data-heavy tool that may interest devs

These are volatile out-of-the-box OS estimations for several reasons:

- If the specs on a computer are high enough (and they often are if the software is >5 years old), you can make almost any software run on any popular OS. Quick-and-dirty still does the job, even if it's running on an MS-DOS emulator inside a Windows 98 VM.
- Developers keep making new things for new technologies, so this is constantly becoming obsolete (PR if you want to fix that).
- In ten years everyone might have BlahBlahOS where everything runs on it and these won't matter.

I also update a [pile of gists](https://gist.github.com/Phileosopher) for all the code-based and procedure-based things.

## What I'm looking for

Please PR if you see anything I've missed. Or, if tech's not your thing, contact me via "dave at stucky dot tech":

1. Things that are obsolete and their superior replacement.
2. Any relevant platforms/languages the tool needs (e.g., ⊞■⌘🐧🍎🤖⇉).
3. Any classes or sub-classes of tool I may have missed.

If you like what you see, feel free to fork, or visit [my website](https://stucky.tech) for other useful things.
