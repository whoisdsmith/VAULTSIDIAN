/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all) => {
  for (var name in all)
    __defProp(target2, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/scoped-eval/dist/index.js
var require_dist = __commonJS({
  "node_modules/scoped-eval/dist/index.js"(exports, module2) {
    (() => {
      var e = { 113: (e2, t2, r2) => {
        (function() {
          "use strict";
          var e3 = r2(479);
          function isNode(e4) {
            if (e4 == null) {
              return false;
            }
            return typeof e4 === "object" && typeof e4.type === "string";
          }
          function isProperty(t3, r3) {
            return (t3 === e3.Syntax.ObjectExpression || t3 === e3.Syntax.ObjectPattern) && r3 === "properties";
          }
          function Visitor(t3, r3) {
            r3 = r3 || {};
            this.__visitor = t3 || this;
            this.__childVisitorKeys = r3.childVisitorKeys ? Object.assign({}, e3.VisitorKeys, r3.childVisitorKeys) : e3.VisitorKeys;
            if (r3.fallback === "iteration") {
              this.__fallback = Object.keys;
            } else if (typeof r3.fallback === "function") {
              this.__fallback = r3.fallback;
            }
          }
          Visitor.prototype.visitChildren = function(t3) {
            var r3, n, s, i, o, a, l;
            if (t3 == null) {
              return;
            }
            r3 = t3.type || e3.Syntax.Property;
            n = this.__childVisitorKeys[r3];
            if (!n) {
              if (this.__fallback) {
                n = this.__fallback(t3);
              } else {
                throw new Error("Unknown node type " + r3 + ".");
              }
            }
            for (s = 0, i = n.length; s < i; ++s) {
              l = t3[n[s]];
              if (l) {
                if (Array.isArray(l)) {
                  for (o = 0, a = l.length; o < a; ++o) {
                    if (l[o]) {
                      if (isNode(l[o]) || isProperty(r3, n[s])) {
                        this.visit(l[o]);
                      }
                    }
                  }
                } else if (isNode(l)) {
                  this.visit(l);
                }
              }
            }
          };
          Visitor.prototype.visit = function(t3) {
            var r3;
            if (t3 == null) {
              return;
            }
            r3 = t3.type || e3.Syntax.Property;
            if (this.__visitor[r3]) {
              this.__visitor[r3].call(this, t3);
              return;
            }
            this.visitChildren(t3);
          };
          t2.version = r2(389).version;
          t2.Visitor = Visitor;
          t2.visit = function(e4, t3, r3) {
            var n = new Visitor(t3, r3);
            n.visit(e4);
          };
        })();
      }, 479: (e2, t2) => {
        (function clone2(e3) {
          "use strict";
          var t3, r2, n, s, i, o;
          function deepCopy(e4) {
            var t4 = {}, r3, n2;
            for (r3 in e4) {
              if (e4.hasOwnProperty(r3)) {
                n2 = e4[r3];
                if (typeof n2 === "object" && n2 !== null) {
                  t4[r3] = deepCopy(n2);
                } else {
                  t4[r3] = n2;
                }
              }
            }
            return t4;
          }
          function upperBound(e4, t4) {
            var r3, n2, s2, i2;
            n2 = e4.length;
            s2 = 0;
            while (n2) {
              r3 = n2 >>> 1;
              i2 = s2 + r3;
              if (t4(e4[i2])) {
                n2 = r3;
              } else {
                s2 = i2 + 1;
                n2 -= r3 + 1;
              }
            }
            return s2;
          }
          t3 = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ChainExpression: "ChainExpression", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ComprehensionBlock: "ComprehensionBlock", ComprehensionExpression: "ComprehensionExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DebuggerStatement: "DebuggerStatement", DirectiveStatement: "DirectiveStatement", DoWhileStatement: "DoWhileStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", GeneratorExpression: "GeneratorExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportExpression: "ImportExpression", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", ModuleSpecifier: "ModuleSpecifier", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", PrivateIdentifier: "PrivateIdentifier", Program: "Program", Property: "Property", PropertyDefinition: "PropertyDefinition", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchStatement: "SwitchStatement", SwitchCase: "SwitchCase", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" };
          n = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ComprehensionBlock: ["left", "right"], ComprehensionExpression: ["blocks", "filter", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], GeneratorExpression: ["blocks", "filter", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportExpression: ["source"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], PrivateIdentifier: [], Program: ["body"], Property: ["key", "value"], PropertyDefinition: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] };
          s = {};
          i = {};
          o = {};
          r2 = { Break: s, Skip: i, Remove: o };
          function Reference(e4, t4) {
            this.parent = e4;
            this.key = t4;
          }
          Reference.prototype.replace = function replace2(e4) {
            this.parent[this.key] = e4;
          };
          Reference.prototype.remove = function remove() {
            if (Array.isArray(this.parent)) {
              this.parent.splice(this.key, 1);
              return true;
            } else {
              this.replace(null);
              return false;
            }
          };
          function Element(e4, t4, r3, n2) {
            this.node = e4;
            this.path = t4;
            this.wrap = r3;
            this.ref = n2;
          }
          function Controller() {
          }
          Controller.prototype.path = function path3() {
            var e4, t4, r3, n2, s2, i2;
            function addToPath(e5, t5) {
              if (Array.isArray(t5)) {
                for (r3 = 0, n2 = t5.length; r3 < n2; ++r3) {
                  e5.push(t5[r3]);
                }
              } else {
                e5.push(t5);
              }
            }
            if (!this.__current.path) {
              return null;
            }
            s2 = [];
            for (e4 = 2, t4 = this.__leavelist.length; e4 < t4; ++e4) {
              i2 = this.__leavelist[e4];
              addToPath(s2, i2.path);
            }
            addToPath(s2, this.__current.path);
            return s2;
          };
          Controller.prototype.type = function() {
            var e4 = this.current();
            return e4.type || this.__current.wrap;
          };
          Controller.prototype.parents = function parents() {
            var e4, t4, r3;
            r3 = [];
            for (e4 = 1, t4 = this.__leavelist.length; e4 < t4; ++e4) {
              r3.push(this.__leavelist[e4].node);
            }
            return r3;
          };
          Controller.prototype.current = function current() {
            return this.__current.node;
          };
          Controller.prototype.__execute = function __execute(e4, t4) {
            var r3, n2;
            n2 = void 0;
            r3 = this.__current;
            this.__current = t4;
            this.__state = null;
            if (e4) {
              n2 = e4.call(this, t4.node, this.__leavelist[this.__leavelist.length - 1].node);
            }
            this.__current = r3;
            return n2;
          };
          Controller.prototype.notify = function notify(e4) {
            this.__state = e4;
          };
          Controller.prototype.skip = function() {
            this.notify(i);
          };
          Controller.prototype["break"] = function() {
            this.notify(s);
          };
          Controller.prototype.remove = function() {
            this.notify(o);
          };
          Controller.prototype.__initialize = function(e4, t4) {
            this.visitor = t4;
            this.root = e4;
            this.__worklist = [];
            this.__leavelist = [];
            this.__current = null;
            this.__state = null;
            this.__fallback = null;
            if (t4.fallback === "iteration") {
              this.__fallback = Object.keys;
            } else if (typeof t4.fallback === "function") {
              this.__fallback = t4.fallback;
            }
            this.__keys = n;
            if (t4.keys) {
              this.__keys = Object.assign(Object.create(this.__keys), t4.keys);
            }
          };
          function isNode(e4) {
            if (e4 == null) {
              return false;
            }
            return typeof e4 === "object" && typeof e4.type === "string";
          }
          function isProperty(e4, r3) {
            return (e4 === t3.ObjectExpression || e4 === t3.ObjectPattern) && "properties" === r3;
          }
          function candidateExistsInLeaveList(e4, t4) {
            for (var r3 = e4.length - 1; r3 >= 0; --r3) {
              if (e4[r3].node === t4) {
                return true;
              }
            }
            return false;
          }
          Controller.prototype.traverse = function traverse2(e4, t4) {
            var r3, n2, o2, a, l, c, p, u, f, d, h, m;
            this.__initialize(e4, t4);
            m = {};
            r3 = this.__worklist;
            n2 = this.__leavelist;
            r3.push(new Element(e4, null, null, null));
            n2.push(new Element(null, null, null, null));
            while (r3.length) {
              o2 = r3.pop();
              if (o2 === m) {
                o2 = n2.pop();
                c = this.__execute(t4.leave, o2);
                if (this.__state === s || c === s) {
                  return;
                }
                continue;
              }
              if (o2.node) {
                c = this.__execute(t4.enter, o2);
                if (this.__state === s || c === s) {
                  return;
                }
                r3.push(m);
                n2.push(o2);
                if (this.__state === i || c === i) {
                  continue;
                }
                a = o2.node;
                l = a.type || o2.wrap;
                d = this.__keys[l];
                if (!d) {
                  if (this.__fallback) {
                    d = this.__fallback(a);
                  } else {
                    throw new Error("Unknown node type " + l + ".");
                  }
                }
                u = d.length;
                while ((u -= 1) >= 0) {
                  p = d[u];
                  h = a[p];
                  if (!h) {
                    continue;
                  }
                  if (Array.isArray(h)) {
                    f = h.length;
                    while ((f -= 1) >= 0) {
                      if (!h[f]) {
                        continue;
                      }
                      if (candidateExistsInLeaveList(n2, h[f])) {
                        continue;
                      }
                      if (isProperty(l, d[u])) {
                        o2 = new Element(h[f], [p, f], "Property", null);
                      } else if (isNode(h[f])) {
                        o2 = new Element(h[f], [p, f], null, null);
                      } else {
                        continue;
                      }
                      r3.push(o2);
                    }
                  } else if (isNode(h)) {
                    if (candidateExistsInLeaveList(n2, h)) {
                      continue;
                    }
                    r3.push(new Element(h, p, null, null));
                  }
                }
              }
            }
          };
          Controller.prototype.replace = function replace2(e4, t4) {
            var r3, n2, a, l, c, p, u, f, d, h, m, g, k;
            function removeElem(e5) {
              var t5, n3, s2, i2;
              if (e5.ref.remove()) {
                n3 = e5.ref.key;
                i2 = e5.ref.parent;
                t5 = r3.length;
                while (t5--) {
                  s2 = r3[t5];
                  if (s2.ref && s2.ref.parent === i2) {
                    if (s2.ref.key < n3) {
                      break;
                    }
                    --s2.ref.key;
                  }
                }
              }
            }
            this.__initialize(e4, t4);
            m = {};
            r3 = this.__worklist;
            n2 = this.__leavelist;
            g = { root: e4 };
            p = new Element(e4, null, null, new Reference(g, "root"));
            r3.push(p);
            n2.push(p);
            while (r3.length) {
              p = r3.pop();
              if (p === m) {
                p = n2.pop();
                c = this.__execute(t4.leave, p);
                if (c !== void 0 && c !== s && c !== i && c !== o) {
                  p.ref.replace(c);
                }
                if (this.__state === o || c === o) {
                  removeElem(p);
                }
                if (this.__state === s || c === s) {
                  return g.root;
                }
                continue;
              }
              c = this.__execute(t4.enter, p);
              if (c !== void 0 && c !== s && c !== i && c !== o) {
                p.ref.replace(c);
                p.node = c;
              }
              if (this.__state === o || c === o) {
                removeElem(p);
                p.node = null;
              }
              if (this.__state === s || c === s) {
                return g.root;
              }
              a = p.node;
              if (!a) {
                continue;
              }
              r3.push(m);
              n2.push(p);
              if (this.__state === i || c === i) {
                continue;
              }
              l = a.type || p.wrap;
              d = this.__keys[l];
              if (!d) {
                if (this.__fallback) {
                  d = this.__fallback(a);
                } else {
                  throw new Error("Unknown node type " + l + ".");
                }
              }
              u = d.length;
              while ((u -= 1) >= 0) {
                k = d[u];
                h = a[k];
                if (!h) {
                  continue;
                }
                if (Array.isArray(h)) {
                  f = h.length;
                  while ((f -= 1) >= 0) {
                    if (!h[f]) {
                      continue;
                    }
                    if (isProperty(l, d[u])) {
                      p = new Element(h[f], [k, f], "Property", new Reference(h, f));
                    } else if (isNode(h[f])) {
                      p = new Element(h[f], [k, f], null, new Reference(h, f));
                    } else {
                      continue;
                    }
                    r3.push(p);
                  }
                } else if (isNode(h)) {
                  r3.push(new Element(h, k, null, new Reference(a, k)));
                }
              }
            }
            return g.root;
          };
          function traverse(e4, t4) {
            var r3 = new Controller();
            return r3.traverse(e4, t4);
          }
          function replace(e4, t4) {
            var r3 = new Controller();
            return r3.replace(e4, t4);
          }
          function extendCommentRange(e4, t4) {
            var r3;
            r3 = upperBound(t4, function search(t5) {
              return t5.range[0] > e4.range[0];
            });
            e4.extendedRange = [e4.range[0], e4.range[1]];
            if (r3 !== t4.length) {
              e4.extendedRange[1] = t4[r3].range[0];
            }
            r3 -= 1;
            if (r3 >= 0) {
              e4.extendedRange[0] = t4[r3].range[1];
            }
            return e4;
          }
          function attachComments(e4, t4, n2) {
            var s2 = [], i2, o2, a, l;
            if (!e4.range) {
              throw new Error("attachComments needs range information");
            }
            if (!n2.length) {
              if (t4.length) {
                for (a = 0, o2 = t4.length; a < o2; a += 1) {
                  i2 = deepCopy(t4[a]);
                  i2.extendedRange = [0, e4.range[0]];
                  s2.push(i2);
                }
                e4.leadingComments = s2;
              }
              return e4;
            }
            for (a = 0, o2 = t4.length; a < o2; a += 1) {
              s2.push(extendCommentRange(deepCopy(t4[a]), n2));
            }
            l = 0;
            traverse(e4, { enter: function(e5) {
              var t5;
              while (l < s2.length) {
                t5 = s2[l];
                if (t5.extendedRange[1] > e5.range[0]) {
                  break;
                }
                if (t5.extendedRange[1] === e5.range[0]) {
                  if (!e5.leadingComments) {
                    e5.leadingComments = [];
                  }
                  e5.leadingComments.push(t5);
                  s2.splice(l, 1);
                } else {
                  l += 1;
                }
              }
              if (l === s2.length) {
                return r2.Break;
              }
              if (s2[l].extendedRange[0] > e5.range[1]) {
                return r2.Skip;
              }
            } });
            l = 0;
            traverse(e4, { leave: function(e5) {
              var t5;
              while (l < s2.length) {
                t5 = s2[l];
                if (e5.range[1] < t5.extendedRange[0]) {
                  break;
                }
                if (e5.range[1] === t5.extendedRange[0]) {
                  if (!e5.trailingComments) {
                    e5.trailingComments = [];
                  }
                  e5.trailingComments.push(t5);
                  s2.splice(l, 1);
                } else {
                  l += 1;
                }
              }
              if (l === s2.length) {
                return r2.Break;
              }
              if (s2[l].extendedRange[0] > e5.range[1]) {
                return r2.Skip;
              }
            } });
            return e4;
          }
          e3.Syntax = t3;
          e3.traverse = traverse;
          e3.replace = replace;
          e3.attachComments = attachComments;
          e3.VisitorKeys = n;
          e3.VisitorOption = r2;
          e3.Controller = Controller;
          e3.cloneEnvironment = function() {
            return clone2({});
          };
          return e3;
        })(t2);
      }, 57: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const n = r2(852);
        function default_1(e3, t3) {
          const r3 = (0, n.analyze)(e3, { ecmaVersion: 6 });
          const s = r3.acquire(e3);
          const i = /* @__PURE__ */ Object.create(null);
          const o = new Set(s.set.keys());
          s.through.forEach(function(e4) {
            const r4 = e4.identifier.name;
            if (o.has(r4))
              return;
            if (t3[r4] === true)
              return;
            const n2 = e4.identifier.range;
            if (i[r4]) {
              i[r4].push(n2);
            } else {
              i[r4] = [n2];
            }
          });
          return i;
        }
        t2["default"] = default_1;
      }, 144: function(e2, t2, r2) {
        "use strict";
        var n = this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        const s = r2(479);
        const i = n(r2(89));
        const o = n(r2(57));
        const a = n(r2(578));
        const l = n(r2(238));
        const c = n(r2(132));
        const p = { undefined: true, NaN: true, isNaN: true, Infinity: true, isFinite: true, alert: true, atob: true, btoa: true, encodeURI: true, encodeURIComponent: true, decodeURI: true, decodeURIComponent: true, parseFloat: true, parseInt: true, JSON: true, Number: true, String: true, Array: true, BigInt: true, Blob: true, Boolean: true, Date: true, Map: true, Math: true, Object: true, RegExp: true, Set: true, Intl: true };
        class ScopedEval2 {
          constructor() {
            this.allowedGlobals = { ...p };
          }
          allowGlobals(e3) {
            if (typeof e3 === "string") {
              e3 = [e3];
            }
            for (const t3 of e3) {
              this.allowedGlobals[t3] = true;
            }
          }
          eval(e3, t3, r3 = false) {
            return this.build(e3, r3)(t3);
          }
          build(e3, t3 = false) {
            return new Function(...this.preprocess(e3, t3));
          }
          preprocess(e3, t3 = false) {
            if (typeof e3 !== "string") {
              throw new Error(`Code to be evaluated must be a string, but received ${typeof e3}: ${JSON.stringify(e3)}`);
            }
            e3 = t3 ? (0, l.default)(e3) : e3;
            const r3 = (0, i.default)(e3);
            const n2 = (0, c.default)(r3);
            const p2 = n2 + ".";
            const u = (0, o.default)(r3, this.allowedGlobals);
            const f = new a.default(e3);
            const d = r3.body.length;
            if (d > 0) {
              const e4 = r3.body[d - 1];
              if (e4.type === "ExpressionStatement") {
                f.insert(e4.range[0], "return ");
              }
            }
            (0, s.traverse)(r3, { enter: function(e4) {
              if (e4.type === "ImportExpression") {
                throw new Error(`[${e4.loc.start.line}:${e4.loc.start.column}]: Dynamic import is not allowed`);
              }
            } });
            for (const e4 in u) {
              for (const t4 of u[e4]) {
                f.insert(t4[0], p2);
              }
            }
            return [n2, f.transform()];
          }
        }
        t2["default"] = ScopedEval2;
      }, 578: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        class InsertCode {
          constructor(e3) {
            this.code = e3;
            this.parts = {};
          }
          insert(e3, t3) {
            let r2;
            if (this.parts[e3]) {
              r2 = this.parts[e3];
            } else {
              r2 = [];
              this.parts[e3] = r2;
            }
            r2.push(t3);
          }
          transform() {
            const e3 = Object.keys(this.parts).map((e4) => parseInt(e4, 10)).sort((e4, t4) => e4 - t4);
            let t3 = "";
            let r2 = 0;
            for (const n of e3) {
              t3 += this.code.slice(r2, n);
              for (const e4 of this.parts[n]) {
                t3 += e4;
              }
              r2 = n;
            }
            t3 += this.code.slice(r2);
            return t3;
          }
        }
        t2["default"] = InsertCode;
      }, 89: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const n = r2(631);
        const s = { next: true, ranges: true, loc: true, webcompat: true, globalReturn: true, impliedStrict: true };
        function default_1(e3) {
          return (0, n.parseScript)(e3, s);
        }
        t2["default"] = default_1;
      }, 238: function(e2, t2, r2) {
        "use strict";
        var n = this && this.__importDefault || function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        const s = n(r2(89));
        var i;
        (function(e3) {
          e3[e3["str"] = 0] = "str";
          e3[e3["exp"] = 1] = "exp";
        })(i || (i = {}));
        class Part {
          constructor(e3, t3) {
            this.t = e3;
            this.v = t3;
          }
        }
        function split(e3) {
          const t3 = e3.indexOf("${");
          if (t3 === -1)
            return [new Part(i.str, e3)];
          if (t3 > 0 && e3[t3 - 1] === "\\") {
            const r4 = [new Part(i.str, e3.slice(0, t3 - 1) + "${")];
            if (t3 + 2 < e3.length) {
              r4.push(...split(e3.slice(t3 + 2)));
            }
            return r4;
          }
          let r3 = t3 + 1;
          for (; ; ) {
            r3 = e3.indexOf("}", r3 + 1);
            if (r3 === -1) {
              throw new Error("cannot find } in interpolation: " + e3.slice(t3));
            }
            const n2 = e3.slice(t3 + 2, r3);
            try {
              const e4 = (0, s.default)(n2);
              if (e4.body.length !== 1 || e4.body[0].type !== "ExpressionStatement") {
                throw new Error("not a valid expression: " + n2);
              }
            } catch (e4) {
              continue;
            }
            const o = [];
            if (t3 > 0) {
              o.push(new Part(i.str, e3.slice(0, t3)));
            }
            o.push(new Part(i.exp, n2));
            if (r3 + 1 < e3.length) {
              o.push(...split(e3.slice(r3 + 1)));
            }
            return o;
          }
        }
        function clean(e3) {
          const t3 = [];
          let r3;
          for (const n2 of e3) {
            if (r3 && r3.t === i.str && n2.t === i.str) {
              r3.v += n2.v;
              continue;
            }
            r3 = n2;
            t3.push(n2);
          }
          return t3;
        }
        function stringInterpolation(e3) {
          const t3 = clean(split(e3));
          return t3.map((e4, t4) => {
            if (e4.t === i.exp) {
              const r3 = "(" + e4.v + ")";
              if (t4 === 0)
                return '"" + ' + r3;
              return r3;
            }
            return JSON.stringify(e4.v);
          }).join(" + ");
        }
        t2["default"] = stringInterpolation;
      }, 132: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const n = r2(479);
        const s = "abcdefghijklmnopqrstuvwxyz$_";
        function default_1(e3) {
          const t3 = {};
          (0, n.traverse)(e3, { enter: function(e4) {
            if (e4.type === "Identifier" && e4.name.length === 1) {
              t3[e4.name] = true;
            }
          } });
          for (const e4 of s) {
            if (!t3[e4])
              return e4;
          }
          throw new Error("I gave up :( You exhausted variable names a,b,...z,$,_ in one expression.");
        }
        t2["default"] = default_1;
      }, 491: (e2) => {
        "use strict";
        e2.exports = require("assert");
      }, 852: (e2, t2, r2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = r2(491);
        var s = r2(479);
        var i = r2(113);
        function _interopDefaultLegacy(e3) {
          return e3 && typeof e3 === "object" && "default" in e3 ? e3 : { default: e3 };
        }
        var o = _interopDefaultLegacy(n);
        var a = _interopDefaultLegacy(s);
        var l = _interopDefaultLegacy(i);
        const c = 1;
        const p = 2;
        const u = c | p;
        class Reference {
          constructor(e3, t3, r3, n2, s2, i2, o2) {
            this.identifier = e3;
            this.from = t3;
            this.tainted = false;
            this.resolved = null;
            this.flag = r3;
            if (this.isWrite()) {
              this.writeExpr = n2;
              this.partial = i2;
              this.init = o2;
            }
            this.__maybeImplicitGlobal = s2;
          }
          isStatic() {
            return !this.tainted && this.resolved && this.resolved.scope.isStatic();
          }
          isWrite() {
            return !!(this.flag & Reference.WRITE);
          }
          isRead() {
            return !!(this.flag & Reference.READ);
          }
          isReadOnly() {
            return this.flag === Reference.READ;
          }
          isWriteOnly() {
            return this.flag === Reference.WRITE;
          }
          isReadWrite() {
            return this.flag === Reference.RW;
          }
        }
        Reference.READ = c;
        Reference.WRITE = p;
        Reference.RW = u;
        class Variable {
          constructor(e3, t3) {
            this.name = e3;
            this.identifiers = [];
            this.references = [];
            this.defs = [];
            this.tainted = false;
            this.stack = true;
            this.scope = t3;
          }
        }
        Variable.CatchClause = "CatchClause";
        Variable.Parameter = "Parameter";
        Variable.FunctionName = "FunctionName";
        Variable.ClassName = "ClassName";
        Variable.Variable = "Variable";
        Variable.ImportBinding = "ImportBinding";
        Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
        class Definition {
          constructor(e3, t3, r3, n2, s2, i2) {
            this.type = e3;
            this.name = t3;
            this.node = r3;
            this.parent = n2;
            this.index = s2;
            this.kind = i2;
          }
        }
        class ParameterDefinition extends Definition {
          constructor(e3, t3, r3, n2) {
            super(Variable.Parameter, e3, t3, null, r3, null);
            this.rest = n2;
          }
        }
        const { Syntax: f } = a["default"];
        function isStrictScope(e3, t3, r3, n2) {
          let s2;
          if (e3.upper && e3.upper.isStrict) {
            return true;
          }
          if (r3) {
            return true;
          }
          if (e3.type === "class" || e3.type === "module") {
            return true;
          }
          if (e3.type === "block" || e3.type === "switch") {
            return false;
          }
          if (e3.type === "function") {
            if (t3.type === f.ArrowFunctionExpression && t3.body.type !== f.BlockStatement) {
              return false;
            }
            if (t3.type === f.Program) {
              s2 = t3;
            } else {
              s2 = t3.body;
            }
            if (!s2) {
              return false;
            }
          } else if (e3.type === "global") {
            s2 = t3;
          } else {
            return false;
          }
          if (n2) {
            for (let e4 = 0, t4 = s2.body.length; e4 < t4; ++e4) {
              const t5 = s2.body[e4];
              if (t5.type !== f.DirectiveStatement) {
                break;
              }
              if (t5.raw === '"use strict"' || t5.raw === "'use strict'") {
                return true;
              }
            }
          } else {
            for (let e4 = 0, t4 = s2.body.length; e4 < t4; ++e4) {
              const t5 = s2.body[e4];
              if (t5.type !== f.ExpressionStatement) {
                break;
              }
              const r4 = t5.expression;
              if (r4.type !== f.Literal || typeof r4.value !== "string") {
                break;
              }
              if (r4.raw !== null && r4.raw !== void 0) {
                if (r4.raw === '"use strict"' || r4.raw === "'use strict'") {
                  return true;
                }
              } else {
                if (r4.value === "use strict") {
                  return true;
                }
              }
            }
          }
          return false;
        }
        function registerScope(e3, t3) {
          e3.scopes.push(t3);
          const r3 = e3.__nodeToScope.get(t3.block);
          if (r3) {
            r3.push(t3);
          } else {
            e3.__nodeToScope.set(t3.block, [t3]);
          }
        }
        function shouldBeStatically(e3) {
          return e3.type === Variable.ClassName || e3.type === Variable.Variable && e3.parent.kind !== "var";
        }
        class Scope {
          constructor(e3, t3, r3, n2, s2) {
            this.type = t3;
            this.set = /* @__PURE__ */ new Map();
            this.taints = /* @__PURE__ */ new Map();
            this.dynamic = this.type === "global" || this.type === "with";
            this.block = n2;
            this.through = [];
            this.variables = [];
            this.references = [];
            this.variableScope = this.type === "global" || this.type === "module" || this.type === "function" || this.type === "class-field-initializer" || this.type === "class-static-block" ? this : r3.variableScope;
            this.functionExpressionScope = false;
            this.directCallToEvalScope = false;
            this.thisFound = false;
            this.__left = [];
            this.upper = r3;
            this.isStrict = e3.isStrictModeSupported() ? isStrictScope(this, n2, s2, e3.__useDirective()) : false;
            this.childScopes = [];
            if (this.upper) {
              this.upper.childScopes.push(this);
            }
            this.__declaredVariables = e3.__declaredVariables;
            registerScope(e3, this);
          }
          __shouldStaticallyClose(e3) {
            return !this.dynamic || e3.__isOptimistic();
          }
          __shouldStaticallyCloseForGlobal(e3) {
            const t3 = e3.identifier.name;
            if (!this.set.has(t3)) {
              return false;
            }
            const r3 = this.set.get(t3);
            const n2 = r3.defs;
            return n2.length > 0 && n2.every(shouldBeStatically);
          }
          __staticCloseRef(e3) {
            if (!this.__resolve(e3)) {
              this.__delegateToUpperScope(e3);
            }
          }
          __dynamicCloseRef(e3) {
            let t3 = this;
            do {
              t3.through.push(e3);
              t3 = t3.upper;
            } while (t3);
          }
          __globalCloseRef(e3) {
            if (this.__shouldStaticallyCloseForGlobal(e3)) {
              this.__staticCloseRef(e3);
            } else {
              this.__dynamicCloseRef(e3);
            }
          }
          __close(e3) {
            let t3;
            if (this.__shouldStaticallyClose(e3)) {
              t3 = this.__staticCloseRef;
            } else if (this.type !== "global") {
              t3 = this.__dynamicCloseRef;
            } else {
              t3 = this.__globalCloseRef;
            }
            for (let e4 = 0, r3 = this.__left.length; e4 < r3; ++e4) {
              const r4 = this.__left[e4];
              t3.call(this, r4);
            }
            this.__left = null;
            return this.upper;
          }
          __isValidResolution(e3, t3) {
            return true;
          }
          __resolve(e3) {
            const t3 = e3.identifier.name;
            if (!this.set.has(t3)) {
              return false;
            }
            const r3 = this.set.get(t3);
            if (!this.__isValidResolution(e3, r3)) {
              return false;
            }
            r3.references.push(e3);
            r3.stack = r3.stack && e3.from.variableScope === this.variableScope;
            if (e3.tainted) {
              r3.tainted = true;
              this.taints.set(r3.name, true);
            }
            e3.resolved = r3;
            return true;
          }
          __delegateToUpperScope(e3) {
            if (this.upper) {
              this.upper.__left.push(e3);
            }
            this.through.push(e3);
          }
          __addDeclaredVariablesOfNode(e3, t3) {
            if (t3 === null || t3 === void 0) {
              return;
            }
            let r3 = this.__declaredVariables.get(t3);
            if (r3 === null || r3 === void 0) {
              r3 = [];
              this.__declaredVariables.set(t3, r3);
            }
            if (r3.indexOf(e3) === -1) {
              r3.push(e3);
            }
          }
          __defineGeneric(e3, t3, r3, n2, s2) {
            let i2;
            i2 = t3.get(e3);
            if (!i2) {
              i2 = new Variable(e3, this);
              t3.set(e3, i2);
              r3.push(i2);
            }
            if (s2) {
              i2.defs.push(s2);
              this.__addDeclaredVariablesOfNode(i2, s2.node);
              this.__addDeclaredVariablesOfNode(i2, s2.parent);
            }
            if (n2) {
              i2.identifiers.push(n2);
            }
          }
          __define(e3, t3) {
            if (e3 && e3.type === f.Identifier) {
              this.__defineGeneric(e3.name, this.set, this.variables, e3, t3);
            }
          }
          __referencing(e3, t3, r3, n2, s2, i2) {
            if (!e3 || e3.type !== f.Identifier) {
              return;
            }
            if (e3.name === "super") {
              return;
            }
            const o2 = new Reference(e3, this, t3 || Reference.READ, r3, n2, !!s2, !!i2);
            this.references.push(o2);
            this.__left.push(o2);
          }
          __detectEval() {
            let e3 = this;
            this.directCallToEvalScope = true;
            do {
              e3.dynamic = true;
              e3 = e3.upper;
            } while (e3);
          }
          __detectThis() {
            this.thisFound = true;
          }
          __isClosed() {
            return this.__left === null;
          }
          resolve(e3) {
            let t3, r3, n2;
            o["default"](this.__isClosed(), "Scope should be closed.");
            o["default"](e3.type === f.Identifier, "Target should be identifier.");
            for (r3 = 0, n2 = this.references.length; r3 < n2; ++r3) {
              t3 = this.references[r3];
              if (t3.identifier === e3) {
                return t3;
              }
            }
            return null;
          }
          isStatic() {
            return !this.dynamic;
          }
          isArgumentsMaterialized() {
            return true;
          }
          isThisMaterialized() {
            return true;
          }
          isUsedName(e3) {
            if (this.set.has(e3)) {
              return true;
            }
            for (let t3 = 0, r3 = this.through.length; t3 < r3; ++t3) {
              if (this.through[t3].identifier.name === e3) {
                return true;
              }
            }
            return false;
          }
        }
        class GlobalScope extends Scope {
          constructor(e3, t3) {
            super(e3, "global", null, t3, false);
            this.implicit = { set: /* @__PURE__ */ new Map(), variables: [], left: [] };
          }
          __close(e3) {
            const t3 = [];
            for (let e4 = 0, r3 = this.__left.length; e4 < r3; ++e4) {
              const r4 = this.__left[e4];
              if (r4.__maybeImplicitGlobal && !this.set.has(r4.identifier.name)) {
                t3.push(r4.__maybeImplicitGlobal);
              }
            }
            for (let e4 = 0, r3 = t3.length; e4 < r3; ++e4) {
              const r4 = t3[e4];
              this.__defineImplicit(r4.pattern, new Definition(Variable.ImplicitGlobalVariable, r4.pattern, r4.node, null, null, null));
            }
            this.implicit.left = this.__left;
            return super.__close(e3);
          }
          __defineImplicit(e3, t3) {
            if (e3 && e3.type === f.Identifier) {
              this.__defineGeneric(e3.name, this.implicit.set, this.implicit.variables, e3, t3);
            }
          }
        }
        class ModuleScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "module", t3, r3, false);
          }
        }
        class FunctionExpressionNameScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "function-expression-name", t3, r3, false);
            this.__define(r3.id, new Definition(Variable.FunctionName, r3.id, r3, null, null, null));
            this.functionExpressionScope = true;
          }
        }
        class CatchScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "catch", t3, r3, false);
          }
        }
        class WithScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "with", t3, r3, false);
          }
          __close(e3) {
            if (this.__shouldStaticallyClose(e3)) {
              return super.__close(e3);
            }
            for (let e4 = 0, t3 = this.__left.length; e4 < t3; ++e4) {
              const t4 = this.__left[e4];
              t4.tainted = true;
              this.__delegateToUpperScope(t4);
            }
            this.__left = null;
            return this.upper;
          }
        }
        class BlockScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "block", t3, r3, false);
          }
        }
        class SwitchScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "switch", t3, r3, false);
          }
        }
        class FunctionScope extends Scope {
          constructor(e3, t3, r3, n2) {
            super(e3, "function", t3, r3, n2);
            if (this.block.type !== f.ArrowFunctionExpression) {
              this.__defineArguments();
            }
          }
          isArgumentsMaterialized() {
            if (this.block.type === f.ArrowFunctionExpression) {
              return false;
            }
            if (!this.isStatic()) {
              return true;
            }
            const e3 = this.set.get("arguments");
            o["default"](e3, "Always have arguments variable.");
            return e3.tainted || e3.references.length !== 0;
          }
          isThisMaterialized() {
            if (!this.isStatic()) {
              return true;
            }
            return this.thisFound;
          }
          __defineArguments() {
            this.__defineGeneric("arguments", this.set, this.variables, null, null);
            this.taints.set("arguments", true);
          }
          __isValidResolution(e3, t3) {
            if (this.block.type === "Program") {
              return true;
            }
            const r3 = this.block.body.range[0];
            return !(t3.scope === this && e3.identifier.range[0] < r3 && t3.defs.every((e4) => e4.name.range[0] >= r3));
          }
        }
        class ForScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "for", t3, r3, false);
          }
        }
        class ClassScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "class", t3, r3, false);
          }
        }
        class ClassFieldInitializerScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "class-field-initializer", t3, r3, true);
          }
        }
        class ClassStaticBlockScope extends Scope {
          constructor(e3, t3, r3) {
            super(e3, "class-static-block", t3, r3, true);
          }
        }
        class ScopeManager {
          constructor(e3) {
            this.scopes = [];
            this.globalScope = null;
            this.__nodeToScope = /* @__PURE__ */ new WeakMap();
            this.__currentScope = null;
            this.__options = e3;
            this.__declaredVariables = /* @__PURE__ */ new WeakMap();
          }
          __useDirective() {
            return this.__options.directive;
          }
          __isOptimistic() {
            return this.__options.optimistic;
          }
          __ignoreEval() {
            return this.__options.ignoreEval;
          }
          __isNodejsScope() {
            return this.__options.nodejsScope || this.__options.sourceType === "commonjs";
          }
          isModule() {
            return this.__options.sourceType === "module";
          }
          isImpliedStrict() {
            return this.__options.impliedStrict;
          }
          isStrictModeSupported() {
            return this.__options.ecmaVersion >= 5;
          }
          __get(e3) {
            return this.__nodeToScope.get(e3);
          }
          getDeclaredVariables(e3) {
            return this.__declaredVariables.get(e3) || [];
          }
          acquire(e3, t3) {
            function predicate(e4) {
              if (e4.type === "function" && e4.functionExpressionScope) {
                return false;
              }
              return true;
            }
            const r3 = this.__get(e3);
            if (!r3 || r3.length === 0) {
              return null;
            }
            if (r3.length === 1) {
              return r3[0];
            }
            if (t3) {
              for (let e4 = r3.length - 1; e4 >= 0; --e4) {
                const t4 = r3[e4];
                if (predicate(t4)) {
                  return t4;
                }
              }
            } else {
              for (let e4 = 0, t4 = r3.length; e4 < t4; ++e4) {
                const t5 = r3[e4];
                if (predicate(t5)) {
                  return t5;
                }
              }
            }
            return null;
          }
          acquireAll(e3) {
            return this.__get(e3);
          }
          release(e3, t3) {
            const r3 = this.__get(e3);
            if (r3 && r3.length) {
              const e4 = r3[0].upper;
              if (!e4) {
                return null;
              }
              return this.acquire(e4.block, t3);
            }
            return null;
          }
          attach() {
          }
          detach() {
          }
          __nestScope(e3) {
            if (e3 instanceof GlobalScope) {
              o["default"](this.__currentScope === null);
              this.globalScope = e3;
            }
            this.__currentScope = e3;
            return e3;
          }
          __nestGlobalScope(e3) {
            return this.__nestScope(new GlobalScope(this, e3));
          }
          __nestBlockScope(e3) {
            return this.__nestScope(new BlockScope(this, this.__currentScope, e3));
          }
          __nestFunctionScope(e3, t3) {
            return this.__nestScope(new FunctionScope(this, this.__currentScope, e3, t3));
          }
          __nestForScope(e3) {
            return this.__nestScope(new ForScope(this, this.__currentScope, e3));
          }
          __nestCatchScope(e3) {
            return this.__nestScope(new CatchScope(this, this.__currentScope, e3));
          }
          __nestWithScope(e3) {
            return this.__nestScope(new WithScope(this, this.__currentScope, e3));
          }
          __nestClassScope(e3) {
            return this.__nestScope(new ClassScope(this, this.__currentScope, e3));
          }
          __nestClassFieldInitializerScope(e3) {
            return this.__nestScope(new ClassFieldInitializerScope(this, this.__currentScope, e3));
          }
          __nestClassStaticBlockScope(e3) {
            return this.__nestScope(new ClassStaticBlockScope(this, this.__currentScope, e3));
          }
          __nestSwitchScope(e3) {
            return this.__nestScope(new SwitchScope(this, this.__currentScope, e3));
          }
          __nestModuleScope(e3) {
            return this.__nestScope(new ModuleScope(this, this.__currentScope, e3));
          }
          __nestFunctionExpressionNameScope(e3) {
            return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, e3));
          }
          __isES6() {
            return this.__options.ecmaVersion >= 6;
          }
        }
        const { Syntax: d } = a["default"];
        function getLast(e3) {
          return e3[e3.length - 1] || null;
        }
        class PatternVisitor extends l["default"].Visitor {
          static isPattern(e3) {
            const t3 = e3.type;
            return t3 === d.Identifier || t3 === d.ObjectPattern || t3 === d.ArrayPattern || t3 === d.SpreadElement || t3 === d.RestElement || t3 === d.AssignmentPattern;
          }
          constructor(e3, t3, r3) {
            super(null, e3);
            this.rootPattern = t3;
            this.callback = r3;
            this.assignments = [];
            this.rightHandNodes = [];
            this.restElements = [];
          }
          Identifier(e3) {
            const t3 = getLast(this.restElements);
            this.callback(e3, { topLevel: e3 === this.rootPattern, rest: t3 !== null && t3 !== void 0 && t3.argument === e3, assignments: this.assignments });
          }
          Property(e3) {
            if (e3.computed) {
              this.rightHandNodes.push(e3.key);
            }
            this.visit(e3.value);
          }
          ArrayPattern(e3) {
            for (let t3 = 0, r3 = e3.elements.length; t3 < r3; ++t3) {
              const r4 = e3.elements[t3];
              this.visit(r4);
            }
          }
          AssignmentPattern(e3) {
            this.assignments.push(e3);
            this.visit(e3.left);
            this.rightHandNodes.push(e3.right);
            this.assignments.pop();
          }
          RestElement(e3) {
            this.restElements.push(e3);
            this.visit(e3.argument);
            this.restElements.pop();
          }
          MemberExpression(e3) {
            if (e3.computed) {
              this.rightHandNodes.push(e3.property);
            }
            this.rightHandNodes.push(e3.object);
          }
          SpreadElement(e3) {
            this.visit(e3.argument);
          }
          ArrayExpression(e3) {
            e3.elements.forEach(this.visit, this);
          }
          AssignmentExpression(e3) {
            this.assignments.push(e3);
            this.visit(e3.left);
            this.rightHandNodes.push(e3.right);
            this.assignments.pop();
          }
          CallExpression(e3) {
            e3.arguments.forEach((e4) => {
              this.rightHandNodes.push(e4);
            });
            this.visit(e3.callee);
          }
        }
        const { Syntax: h } = a["default"];
        function traverseIdentifierInPattern(e3, t3, r3, n2) {
          const s2 = new PatternVisitor(e3, t3, n2);
          s2.visit(t3);
          if (r3 !== null && r3 !== void 0) {
            s2.rightHandNodes.forEach(r3.visit, r3);
          }
        }
        class Importer extends l["default"].Visitor {
          constructor(e3, t3) {
            super(null, t3.options);
            this.declaration = e3;
            this.referencer = t3;
          }
          visitImport(e3, t3) {
            this.referencer.visitPattern(e3, (e4) => {
              this.referencer.currentScope().__define(e4, new Definition(Variable.ImportBinding, e4, t3, this.declaration, null, null));
            });
          }
          ImportNamespaceSpecifier(e3) {
            const t3 = e3.local || e3.id;
            if (t3) {
              this.visitImport(t3, e3);
            }
          }
          ImportDefaultSpecifier(e3) {
            const t3 = e3.local || e3.id;
            this.visitImport(t3, e3);
          }
          ImportSpecifier(e3) {
            const t3 = e3.local || e3.id;
            if (e3.name) {
              this.visitImport(e3.name, e3);
            } else {
              this.visitImport(t3, e3);
            }
          }
        }
        class Referencer extends l["default"].Visitor {
          constructor(e3, t3) {
            super(null, e3);
            this.options = e3;
            this.scopeManager = t3;
            this.parent = null;
            this.isInnerMethodDefinition = false;
          }
          currentScope() {
            return this.scopeManager.__currentScope;
          }
          close(e3) {
            while (this.currentScope() && e3 === this.currentScope().block) {
              this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
            }
          }
          pushInnerMethodDefinition(e3) {
            const t3 = this.isInnerMethodDefinition;
            this.isInnerMethodDefinition = e3;
            return t3;
          }
          popInnerMethodDefinition(e3) {
            this.isInnerMethodDefinition = e3;
          }
          referencingDefaultValue(e3, t3, r3, n2) {
            const s2 = this.currentScope();
            t3.forEach((t4) => {
              s2.__referencing(e3, Reference.WRITE, t4.right, r3, e3 !== t4.left, n2);
            });
          }
          visitPattern(e3, t3, r3) {
            let n2 = t3;
            let s2 = r3;
            if (typeof t3 === "function") {
              s2 = t3;
              n2 = { processRightHandNodes: false };
            }
            traverseIdentifierInPattern(this.options, e3, n2.processRightHandNodes ? this : null, s2);
          }
          visitFunction(e3) {
            let t3, r3;
            if (e3.type === h.FunctionDeclaration) {
              this.currentScope().__define(e3.id, new Definition(Variable.FunctionName, e3.id, e3, null, null, null));
            }
            if (e3.type === h.FunctionExpression && e3.id) {
              this.scopeManager.__nestFunctionExpressionNameScope(e3);
            }
            this.scopeManager.__nestFunctionScope(e3, this.isInnerMethodDefinition);
            const n2 = this;
            function visitPatternCallback(r4, s2) {
              n2.currentScope().__define(r4, new ParameterDefinition(r4, e3, t3, s2.rest));
              n2.referencingDefaultValue(r4, s2.assignments, null, true);
            }
            for (t3 = 0, r3 = e3.params.length; t3 < r3; ++t3) {
              this.visitPattern(e3.params[t3], { processRightHandNodes: true }, visitPatternCallback);
            }
            if (e3.rest) {
              this.visitPattern({ type: "RestElement", argument: e3.rest }, (t4) => {
                this.currentScope().__define(t4, new ParameterDefinition(t4, e3, e3.params.length, true));
              });
            }
            if (e3.body) {
              if (e3.body.type === h.BlockStatement) {
                this.visitChildren(e3.body);
              } else {
                this.visit(e3.body);
              }
            }
            this.close(e3);
          }
          visitClass(e3) {
            if (e3.type === h.ClassDeclaration) {
              this.currentScope().__define(e3.id, new Definition(Variable.ClassName, e3.id, e3, null, null, null));
            }
            this.visit(e3.superClass);
            this.scopeManager.__nestClassScope(e3);
            if (e3.id) {
              this.currentScope().__define(e3.id, new Definition(Variable.ClassName, e3.id, e3));
            }
            this.visit(e3.body);
            this.close(e3);
          }
          visitProperty(e3) {
            let t3;
            if (e3.computed) {
              this.visit(e3.key);
            }
            const r3 = e3.type === h.MethodDefinition;
            if (r3) {
              t3 = this.pushInnerMethodDefinition(true);
            }
            this.visit(e3.value);
            if (r3) {
              this.popInnerMethodDefinition(t3);
            }
          }
          visitForIn(e3) {
            if (e3.left.type === h.VariableDeclaration && e3.left.kind !== "var") {
              this.scopeManager.__nestForScope(e3);
            }
            if (e3.left.type === h.VariableDeclaration) {
              this.visit(e3.left);
              this.visitPattern(e3.left.declarations[0].id, (t3) => {
                this.currentScope().__referencing(t3, Reference.WRITE, e3.right, null, true, true);
              });
            } else {
              this.visitPattern(e3.left, { processRightHandNodes: true }, (t3, r3) => {
                let n2 = null;
                if (!this.currentScope().isStrict) {
                  n2 = { pattern: t3, node: e3 };
                }
                this.referencingDefaultValue(t3, r3.assignments, n2, false);
                this.currentScope().__referencing(t3, Reference.WRITE, e3.right, n2, true, false);
              });
            }
            this.visit(e3.right);
            this.visit(e3.body);
            this.close(e3);
          }
          visitVariableDeclaration(e3, t3, r3, n2) {
            const s2 = r3.declarations[n2];
            const i2 = s2.init;
            this.visitPattern(s2.id, { processRightHandNodes: true }, (o2, a2) => {
              e3.__define(o2, new Definition(t3, o2, s2, r3, n2, r3.kind));
              this.referencingDefaultValue(o2, a2.assignments, null, true);
              if (i2) {
                this.currentScope().__referencing(o2, Reference.WRITE, i2, null, !a2.topLevel, true);
              }
            });
          }
          AssignmentExpression(e3) {
            if (PatternVisitor.isPattern(e3.left)) {
              if (e3.operator === "=") {
                this.visitPattern(e3.left, { processRightHandNodes: true }, (t3, r3) => {
                  let n2 = null;
                  if (!this.currentScope().isStrict) {
                    n2 = { pattern: t3, node: e3 };
                  }
                  this.referencingDefaultValue(t3, r3.assignments, n2, false);
                  this.currentScope().__referencing(t3, Reference.WRITE, e3.right, n2, !r3.topLevel, false);
                });
              } else {
                this.currentScope().__referencing(e3.left, Reference.RW, e3.right);
              }
            } else {
              this.visit(e3.left);
            }
            this.visit(e3.right);
          }
          CatchClause(e3) {
            this.scopeManager.__nestCatchScope(e3);
            this.visitPattern(e3.param, { processRightHandNodes: true }, (t3, r3) => {
              this.currentScope().__define(t3, new Definition(Variable.CatchClause, e3.param, e3, null, null, null));
              this.referencingDefaultValue(t3, r3.assignments, null, true);
            });
            this.visit(e3.body);
            this.close(e3);
          }
          Program(e3) {
            this.scopeManager.__nestGlobalScope(e3);
            if (this.scopeManager.__isNodejsScope()) {
              this.currentScope().isStrict = false;
              this.scopeManager.__nestFunctionScope(e3, false);
            }
            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
              this.scopeManager.__nestModuleScope(e3);
            }
            if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
              this.currentScope().isStrict = true;
            }
            this.visitChildren(e3);
            this.close(e3);
          }
          Identifier(e3) {
            this.currentScope().__referencing(e3);
          }
          PrivateIdentifier() {
          }
          UpdateExpression(e3) {
            if (PatternVisitor.isPattern(e3.argument)) {
              this.currentScope().__referencing(e3.argument, Reference.RW, null);
            } else {
              this.visitChildren(e3);
            }
          }
          MemberExpression(e3) {
            this.visit(e3.object);
            if (e3.computed) {
              this.visit(e3.property);
            }
          }
          Property(e3) {
            this.visitProperty(e3);
          }
          PropertyDefinition(e3) {
            const { computed: t3, key: r3, value: n2 } = e3;
            if (t3) {
              this.visit(r3);
            }
            if (n2) {
              this.scopeManager.__nestClassFieldInitializerScope(n2);
              this.visit(n2);
              this.close(n2);
            }
          }
          StaticBlock(e3) {
            this.scopeManager.__nestClassStaticBlockScope(e3);
            this.visitChildren(e3);
            this.close(e3);
          }
          MethodDefinition(e3) {
            this.visitProperty(e3);
          }
          BreakStatement() {
          }
          ContinueStatement() {
          }
          LabeledStatement(e3) {
            this.visit(e3.body);
          }
          ForStatement(e3) {
            if (e3.init && e3.init.type === h.VariableDeclaration && e3.init.kind !== "var") {
              this.scopeManager.__nestForScope(e3);
            }
            this.visitChildren(e3);
            this.close(e3);
          }
          ClassExpression(e3) {
            this.visitClass(e3);
          }
          ClassDeclaration(e3) {
            this.visitClass(e3);
          }
          CallExpression(e3) {
            if (!this.scopeManager.__ignoreEval() && e3.callee.type === h.Identifier && e3.callee.name === "eval") {
              this.currentScope().variableScope.__detectEval();
            }
            this.visitChildren(e3);
          }
          BlockStatement(e3) {
            if (this.scopeManager.__isES6()) {
              this.scopeManager.__nestBlockScope(e3);
            }
            this.visitChildren(e3);
            this.close(e3);
          }
          ThisExpression() {
            this.currentScope().variableScope.__detectThis();
          }
          WithStatement(e3) {
            this.visit(e3.object);
            this.scopeManager.__nestWithScope(e3);
            this.visit(e3.body);
            this.close(e3);
          }
          VariableDeclaration(e3) {
            const t3 = e3.kind === "var" ? this.currentScope().variableScope : this.currentScope();
            for (let r3 = 0, n2 = e3.declarations.length; r3 < n2; ++r3) {
              const n3 = e3.declarations[r3];
              this.visitVariableDeclaration(t3, Variable.Variable, e3, r3);
              if (n3.init) {
                this.visit(n3.init);
              }
            }
          }
          SwitchStatement(e3) {
            this.visit(e3.discriminant);
            if (this.scopeManager.__isES6()) {
              this.scopeManager.__nestSwitchScope(e3);
            }
            for (let t3 = 0, r3 = e3.cases.length; t3 < r3; ++t3) {
              this.visit(e3.cases[t3]);
            }
            this.close(e3);
          }
          FunctionDeclaration(e3) {
            this.visitFunction(e3);
          }
          FunctionExpression(e3) {
            this.visitFunction(e3);
          }
          ForOfStatement(e3) {
            this.visitForIn(e3);
          }
          ForInStatement(e3) {
            this.visitForIn(e3);
          }
          ArrowFunctionExpression(e3) {
            this.visitFunction(e3);
          }
          ImportDeclaration(e3) {
            o["default"](this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
            const t3 = new Importer(e3, this);
            t3.visit(e3);
          }
          visitExportDeclaration(e3) {
            if (e3.source) {
              return;
            }
            if (e3.declaration) {
              this.visit(e3.declaration);
              return;
            }
            this.visitChildren(e3);
          }
          ExportDeclaration(e3) {
            this.visitExportDeclaration(e3);
          }
          ExportAllDeclaration(e3) {
            this.visitExportDeclaration(e3);
          }
          ExportDefaultDeclaration(e3) {
            this.visitExportDeclaration(e3);
          }
          ExportNamedDeclaration(e3) {
            this.visitExportDeclaration(e3);
          }
          ExportSpecifier(e3) {
            const t3 = e3.id || e3.local;
            this.visit(t3);
          }
          MetaProperty() {
          }
        }
        const m = "7.1.1";
        function defaultOptions() {
          return { optimistic: false, directive: false, nodejsScope: false, impliedStrict: false, sourceType: "script", ecmaVersion: 5, childVisitorKeys: null, fallback: "iteration" };
        }
        function updateDeeply(e3, t3) {
          function isHashObject(e4) {
            return typeof e4 === "object" && e4 instanceof Object && !(e4 instanceof Array) && !(e4 instanceof RegExp);
          }
          for (const r3 in t3) {
            if (Object.prototype.hasOwnProperty.call(t3, r3)) {
              const n2 = t3[r3];
              if (isHashObject(n2)) {
                if (isHashObject(e3[r3])) {
                  updateDeeply(e3[r3], n2);
                } else {
                  e3[r3] = updateDeeply({}, n2);
                }
              } else {
                e3[r3] = n2;
              }
            }
          }
          return e3;
        }
        function analyze(e3, t3) {
          const r3 = updateDeeply(defaultOptions(), t3);
          const n2 = new ScopeManager(r3);
          const s2 = new Referencer(r3, n2);
          s2.visit(e3);
          o["default"](n2.__currentScope === null, "currentScope should be null.");
          return n2;
        }
        t2.Definition = Definition;
        t2.PatternVisitor = PatternVisitor;
        t2.Reference = Reference;
        t2.Referencer = Referencer;
        t2.Scope = Scope;
        t2.ScopeManager = ScopeManager;
        t2.Variable = Variable;
        t2.analyze = analyze;
        t2.version = m;
      }, 631: (e2, t2) => {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        const r2 = { [0]: "Unexpected token", [28]: "Unexpected token: '%0'", [1]: "Octal escape sequences are not allowed in strict mode", [2]: "Octal escape sequences are not allowed in template strings", [3]: "Unexpected token `#`", [4]: "Illegal Unicode escape sequence", [5]: "Invalid code point %0", [6]: "Invalid hexadecimal escape sequence", [8]: "Octal literals are not allowed in strict mode", [7]: "Decimal integer literals with a leading zero are forbidden in strict mode", [9]: "Expected number in radix %0", [145]: "Invalid left-hand side assignment to a destructible right-hand side", [10]: "Non-number found after exponent indicator", [11]: "Invalid BigIntLiteral", [12]: "No identifiers allowed directly after numeric literal", [13]: "Escapes \\8 or \\9 are not syntactically valid escapes", [14]: "Unterminated string literal", [15]: "Unterminated template literal", [16]: "Multiline comment was not closed properly", [17]: "The identifier contained dynamic unicode escape that was not closed", [18]: "Illegal character '%0'", [19]: "Missing hexadecimal digits", [20]: "Invalid implicit octal", [21]: "Invalid line break in string literal", [22]: "Only unicode escapes are legal in identifier names", [23]: "Expected '%0'", [24]: "Invalid left-hand side in assignment", [25]: "Invalid left-hand side in async arrow", [26]: 'Calls to super must be in the "constructor" method of a class expression or class declaration that has a superclass', [27]: "Member access on super must be in a method", [29]: "Await expression not allowed in formal parameter", [30]: "Yield expression not allowed in formal parameter", [92]: "Unexpected token: 'escaped keyword'", [31]: "Unary expressions as the left operand of an exponentiation expression must be disambiguated with parentheses", [119]: "Async functions can only be declared at the top level or inside a block", [32]: "Unterminated regular expression", [33]: "Unexpected regular expression flag", [34]: "Duplicate regular expression flag '%0'", [35]: "%0 functions must have exactly %1 argument%2", [36]: "Setter function argument must not be a rest parameter", [37]: "%0 declaration must have a name in this context", [38]: "Function name may not contain any reserved words or be eval or arguments in strict mode", [39]: "The rest operator is missing an argument", [40]: "A getter cannot be a generator", [41]: "A computed property name must be followed by a colon or paren", [130]: "Object literal keys that are strings or numbers must be a method or have a colon", [43]: "Found `* async x(){}` but this should be `async * x(){}`", [42]: "Getters and setters can not be generators", [44]: "'%0' can not be generator method", [45]: "No line break is allowed after '=>'", [46]: "The left-hand side of the arrow can only be destructed through assignment", [47]: "The binding declaration is not destructible", [48]: "Async arrow can not be followed by new expression", [49]: "Classes may not have a static property named 'prototype'", [50]: "Class constructor may not be a %0", [51]: "Duplicate constructor method in class", [52]: "Invalid increment/decrement operand", [53]: "Invalid use of `new` keyword on an increment/decrement expression", [54]: "`=>` is an invalid assignment target", [55]: "Rest element may not have a trailing comma", [56]: "Missing initializer in %0 declaration", [57]: "'for-%0' loop head declarations can not have an initializer", [58]: "Invalid left-hand side in for-%0 loop: Must have a single binding", [59]: "Invalid shorthand property initializer", [60]: "Property name __proto__ appears more than once in object literal", [61]: "Let is disallowed as a lexically bound name", [62]: "Invalid use of '%0' inside new expression", [63]: "Illegal 'use strict' directive in function with non-simple parameter list", [64]: 'Identifier "let" disallowed as left-hand side expression in strict mode', [65]: "Illegal continue statement", [66]: "Illegal break statement", [67]: "Cannot have `let[...]` as a var name in strict mode", [68]: "Invalid destructuring assignment target", [69]: "Rest parameter may not have a default initializer", [70]: "The rest argument must the be last parameter", [71]: "Invalid rest argument", [73]: "In strict mode code, functions can only be declared at top level or inside a block", [74]: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement", [75]: "Without web compatibility enabled functions can not be declared at top level, inside a block, or as the body of an if statement", [76]: "Class declaration can't appear in single-statement context", [77]: "Invalid left-hand side in for-%0", [78]: "Invalid assignment in for-%0", [79]: "for await (... of ...) is only valid in async functions and async generators", [80]: "The first token after the template expression should be a continuation of the template", [82]: "`let` declaration not allowed here and `let` cannot be a regular var name in strict mode", [81]: "`let \n [` is a restricted production at the start of a statement", [83]: "Catch clause requires exactly one parameter, not more (and no trailing comma)", [84]: "Catch clause parameter does not support default values", [85]: "Missing catch or finally after try", [86]: "More than one default clause in switch statement", [87]: "Illegal newline after throw", [88]: "Strict mode code may not include a with statement", [89]: "Illegal return statement", [90]: "The left hand side of the for-header binding declaration is not destructible", [91]: "new.target only allowed within functions", [93]: "'#' not followed by identifier", [99]: "Invalid keyword", [98]: "Can not use 'let' as a class name", [97]: "'A lexical declaration can't define a 'let' binding", [96]: "Can not use `let` as variable name in strict mode", [94]: "'%0' may not be used as an identifier in this context", [95]: "Await is only valid in async functions", [100]: "The %0 keyword can only be used with the module goal", [101]: "Unicode codepoint must not be greater than 0x10FFFF", [102]: "%0 source must be string", [103]: "Only a identifier can be used to indicate alias", [104]: "Only '*' or '{...}' can be imported after default", [105]: "Trailing decorator may be followed by method", [106]: "Decorators can't be used with a constructor", [108]: "HTML comments are only allowed with web compatibility (Annex B)", [109]: "The identifier 'let' must not be in expression position in strict mode", [110]: "Cannot assign to `eval` and `arguments` in strict mode", [111]: "The left-hand side of a for-of loop may not start with 'let'", [112]: "Block body arrows can not be immediately invoked without a group", [113]: "Block body arrows can not be immediately accessed without a group", [114]: "Unexpected strict mode reserved word", [115]: "Unexpected eval or arguments in strict mode", [116]: "Decorators must not be followed by a semicolon", [117]: "Calling delete on expression not allowed in strict mode", [118]: "Pattern can not have a tail", [120]: "Can not have a `yield` expression on the left side of a ternary", [121]: "An arrow function can not have a postfix update operator", [122]: "Invalid object literal key character after generator star", [123]: "Private fields can not be deleted", [125]: "Classes may not have a field called constructor", [124]: "Classes may not have a private element named constructor", [126]: "A class field initializer may not contain arguments", [127]: "Generators can only be declared at the top level or inside a block", [128]: "Async methods are a restricted production and cannot have a newline following it", [129]: "Unexpected character after object literal property name", [131]: "Invalid key token", [132]: "Label '%0' has already been declared", [133]: "continue statement must be nested within an iteration statement", [134]: "Undefined label '%0'", [135]: "Trailing comma is disallowed inside import(...) arguments", [136]: "import() requires exactly one argument", [137]: "Cannot use new with import(...)", [138]: "... is not allowed in import()", [139]: "Expected '=>'", [140]: "Duplicate binding '%0'", [141]: "Cannot export a duplicate name '%0'", [144]: "Duplicate %0 for-binding", [142]: "Exported binding '%0' needs to refer to a top-level declared variable", [143]: "Unexpected private field", [147]: "Numeric separators are not allowed at the end of numeric literals", [146]: "Only one underscore is allowed as numeric separator", [148]: "JSX value should be either an expression or a quoted JSX text", [149]: "Expected corresponding JSX closing tag for %0", [150]: "Adjacent JSX elements must be wrapped in an enclosing tag", [151]: "JSX attributes must only be assigned a non-empty 'expression'", [152]: "'%0' has already been declared", [153]: "'%0' shadowed a catch clause binding", [154]: "Dot property must be an identifier", [155]: "Encountered invalid input after spread/rest argument", [156]: "Catch without try", [157]: "Finally without try", [158]: "Expected corresponding closing tag for JSX fragment", [159]: "Coalescing and logical operators used together in the same expression must be disambiguated with parentheses", [160]: "Invalid tagged template on optional chain", [161]: "Invalid optional chain from super property", [162]: "Invalid optional chain from new expression", [163]: 'Cannot use "import.meta" outside a module', [164]: "Leading decorators must be attached to a class declaration" };
        class ParseError extends SyntaxError {
          constructor(e3, t3, n2, s2, ...i2) {
            const o2 = "[" + t3 + ":" + n2 + "]: " + r2[s2].replace(/%(\d+)/g, (e4, t4) => i2[t4]);
            super(`${o2}`);
            this.index = e3;
            this.line = t3;
            this.column = n2;
            this.description = o2;
            this.loc = { line: t3, column: n2 };
          }
        }
        function report(e3, t3, ...r3) {
          throw new ParseError(e3.index, e3.line, e3.column, t3, ...r3);
        }
        function reportScopeError(e3) {
          throw new ParseError(e3.index, e3.line, e3.column, e3.type, e3.params);
        }
        function reportMessageAt(e3, t3, r3, n2, ...s2) {
          throw new ParseError(e3, t3, r3, n2, ...s2);
        }
        function reportScannerError(e3, t3, r3, n2) {
          throw new ParseError(e3, t3, r3, n2);
        }
        const n = ((e3, t3) => {
          const r3 = new Uint32Array(104448);
          let n2 = 0;
          let s2 = 0;
          while (n2 < 3540) {
            const i2 = e3[n2++];
            if (i2 < 0) {
              s2 -= i2;
            } else {
              let o2 = e3[n2++];
              if (i2 & 2)
                o2 = t3[o2];
              if (i2 & 1) {
                r3.fill(o2, s2, s2 += e3[n2++]);
              } else {
                r3[s2++] = o2;
              }
            }
          }
          return r3;
        })([-1, 2, 24, 2, 25, 2, 5, -1, 0, 77595648, 3, 44, 2, 3, 0, 14, 2, 57, 2, 58, 3, 0, 3, 0, 3168796671, 0, 4294956992, 2, 1, 2, 0, 2, 59, 3, 0, 4, 0, 4294966523, 3, 0, 4, 2, 16, 2, 60, 2, 0, 0, 4294836735, 0, 3221225471, 0, 4294901942, 2, 61, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0, 2683305983, 0, 2684354047, 2, 17, 2, 0, 0, 4294961151, 3, 0, 2, 2, 19, 2, 0, 0, 608174079, 2, 0, 2, 131, 2, 6, 2, 56, -1, 2, 37, 0, 4294443263, 2, 1, 3, 0, 3, 0, 4294901711, 2, 39, 0, 4089839103, 0, 2961209759, 0, 1342439375, 0, 4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2, 2, 0, 80831, 0, 4261478351, 0, 4294549486, 2, 2, 0, 2967484831, 0, 196559, 0, 3594373100, 0, 3288319768, 0, 8469959, 2, 194, 2, 3, 0, 3825204735, 0, 123747807, 0, 65487, 0, 4294828015, 0, 4092591615, 0, 1080049119, 0, 458703, 2, 3, 2, 0, 0, 2163244511, 0, 4227923919, 0, 4236247022, 2, 66, 0, 4284449919, 0, 851904, 2, 4, 2, 11, 0, 67076095, -1, 2, 67, 0, 1073741743, 0, 4093591391, -1, 0, 50331649, 0, 3265266687, 2, 32, 0, 4294844415, 0, 4278190047, 2, 18, 2, 129, -1, 3, 0, 2, 2, 21, 2, 0, 2, 9, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 69, 2, 0, 2, 70, 2, 71, 2, 72, 2, 0, 2, 73, 2, 0, 2, 10, 0, 261632, 2, 23, 3, 0, 2, 2, 12, 2, 4, 3, 0, 18, 2, 74, 2, 5, 3, 0, 2, 2, 75, 0, 2088959, 2, 27, 2, 8, 0, 909311, 3, 0, 2, 0, 814743551, 2, 41, 0, 67057664, 3, 0, 2, 2, 40, 2, 0, 2, 28, 2, 0, 2, 29, 2, 7, 0, 268374015, 2, 26, 2, 49, 2, 0, 2, 76, 0, 134153215, -1, 2, 6, 2, 0, 2, 7, 0, 2684354559, 0, 67044351, 0, 3221160064, 0, 1, -1, 3, 0, 2, 2, 42, 0, 1046528, 3, 0, 3, 2, 8, 2, 0, 2, 51, 0, 4294960127, 2, 9, 2, 38, 2, 10, 0, 4294377472, 2, 11, 3, 0, 7, 0, 4227858431, 3, 0, 8, 2, 12, 2, 0, 2, 78, 2, 9, 2, 0, 2, 79, 2, 80, 2, 81, -1, 2, 124, 0, 1048577, 2, 82, 2, 13, -1, 2, 13, 0, 131042, 2, 83, 2, 84, 2, 85, 2, 0, 2, 33, -83, 2, 0, 2, 53, 2, 7, 3, 0, 4, 0, 1046559, 2, 0, 2, 14, 2, 0, 0, 2147516671, 2, 20, 3, 86, 2, 2, 0, -16, 2, 87, 0, 524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 2, 0, 2, 15, 2, 77, 2, 16, 3, 0, 2, 2, 47, 2, 0, -1, 2, 17, -16, 3, 0, 206, -2, 3, 0, 655, 2, 18, 3, 0, 36, 2, 68, -1, 2, 17, 2, 9, 3, 0, 8, 2, 89, 2, 121, 2, 0, 0, 3220242431, 3, 0, 3, 2, 19, 2, 90, 2, 91, 3, 0, 2, 2, 92, 2, 0, 2, 93, 2, 94, 2, 0, 0, 4351, 2, 0, 2, 8, 3, 0, 2, 0, 67043391, 0, 3909091327, 2, 0, 2, 22, 2, 8, 2, 18, 3, 0, 2, 0, 67076097, 2, 7, 2, 0, 2, 20, 0, 67059711, 0, 4236247039, 3, 0, 2, 0, 939524103, 0, 8191999, 2, 97, 2, 98, 2, 15, 2, 21, 3, 0, 3, 0, 67057663, 3, 0, 349, 2, 99, 2, 100, 2, 6, -264, 3, 0, 11, 2, 22, 3, 0, 2, 2, 31, -1, 0, 3774349439, 2, 101, 2, 102, 3, 0, 2, 2, 19, 2, 103, 3, 0, 10, 2, 9, 2, 17, 2, 0, 2, 45, 2, 0, 2, 30, 2, 104, 2, 23, 0, 1638399, 2, 172, 2, 105, 3, 0, 3, 2, 18, 2, 24, 2, 25, 2, 5, 2, 26, 2, 0, 2, 7, 2, 106, -1, 2, 107, 2, 108, 2, 109, -1, 3, 0, 3, 2, 11, -2, 2, 0, 2, 27, -3, 2, 150, -4, 2, 18, 2, 0, 2, 35, 0, 1, 2, 0, 2, 62, 2, 28, 2, 11, 2, 9, 2, 0, 2, 110, -1, 3, 0, 4, 2, 9, 2, 21, 2, 111, 2, 6, 2, 0, 2, 112, 2, 0, 2, 48, -4, 3, 0, 9, 2, 20, 2, 29, 2, 30, -4, 2, 113, 2, 114, 2, 29, 2, 20, 2, 7, -2, 2, 115, 2, 29, 2, 31, -2, 2, 0, 2, 116, -2, 0, 4277137519, 0, 2269118463, -1, 3, 18, 2, -1, 2, 32, 2, 36, 2, 0, 3, 29, 2, 2, 34, 2, 19, -3, 3, 0, 2, 2, 33, -1, 2, 0, 2, 34, 2, 0, 2, 34, 2, 0, 2, 46, -10, 2, 0, 0, 203775, -2, 2, 18, 2, 43, 2, 35, -2, 2, 17, 2, 117, 2, 20, 3, 0, 2, 2, 36, 0, 2147549120, 2, 0, 2, 11, 2, 17, 2, 135, 2, 0, 2, 37, 2, 52, 0, 5242879, 3, 0, 2, 0, 402644511, -1, 2, 120, 0, 1090519039, -2, 2, 122, 2, 38, 2, 0, 0, 67045375, 2, 39, 0, 4226678271, 0, 3766565279, 0, 2039759, -4, 3, 0, 2, 0, 3288270847, 0, 3, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0, 1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 40, 2, 41, -1, 2, 10, 2, 42, -6, 2, 0, 2, 11, -3, 3, 0, 2, 0, 2147484671, 2, 125, 0, 4190109695, 2, 50, -2, 2, 126, 0, 4244635647, 0, 27, 2, 0, 2, 7, 2, 43, 2, 0, 2, 63, -1, 2, 0, 2, 40, -8, 2, 54, 2, 44, 0, 67043329, 2, 127, 2, 45, 0, 8388351, -2, 2, 128, 0, 3028287487, 2, 46, 2, 130, 0, 33259519, 2, 41, -9, 2, 20, -5, 2, 64, -2, 3, 0, 28, 2, 31, -3, 3, 0, 3, 2, 47, 3, 0, 6, 2, 48, -85, 3, 0, 33, 2, 47, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 40, 2, 7, 2, 41, -2, 2, 17, 2, 49, 2, 0, 2, 20, 2, 50, 2, 132, 2, 23, -21, 3, 0, 2, -4, 3, 0, 2, 0, 4294936575, 2, 0, 0, 4294934783, -2, 0, 196635, 3, 0, 191, 2, 51, 3, 0, 38, 2, 29, -1, 2, 33, -279, 3, 0, 8, 2, 7, -1, 2, 133, 2, 52, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 134, 0, 1677656575, -166, 0, 4161266656, 0, 4071, 0, 15360, -4, 0, 28, -13, 3, 0, 2, 2, 37, 2, 0, 2, 136, 2, 137, 2, 55, 2, 0, 2, 138, 2, 139, 2, 140, 3, 0, 10, 2, 141, 2, 142, 2, 15, 3, 37, 2, 3, 53, 2, 3, 54, 2, 0, 4294954999, 2, 0, -16, 2, 0, 2, 88, 2, 0, 0, 2105343, 0, 4160749584, 0, 65534, -42, 0, 4194303871, 0, 2011, -6, 2, 0, 0, 1073684479, 0, 17407, -11, 2, 0, 2, 31, -40, 3, 0, 6, 0, 8323103, -1, 3, 0, 2, 2, 42, -37, 2, 55, 2, 144, 2, 145, 2, 146, 2, 147, 2, 148, -105, 2, 24, -32, 3, 0, 1334, 2, 9, -1, 3, 0, 129, 2, 27, 3, 0, 6, 2, 9, 3, 0, 180, 2, 149, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 9, -47, 3, 0, 154, 2, 56, -22381, 3, 0, 7, 2, 23, -6130, 3, 5, 2, -1, 0, 69207040, 3, 44, 2, 3, 0, 14, 2, 57, 2, 58, -3, 0, 3168731136, 0, 4294956864, 2, 1, 2, 0, 2, 59, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 16, 2, 60, 2, 0, 2, 33, -1, 2, 17, 2, 61, -1, 2, 0, 2, 56, 0, 4294885376, 3, 0, 2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2, 23, 2, 62, 3, 0, 2, 0, 131135, 2, 95, 0, 70256639, 0, 71303167, 0, 272, 2, 40, 2, 56, -1, 2, 37, 2, 30, -1, 2, 96, 2, 63, 0, 4278255616, 0, 4294836227, 0, 4294549473, 0, 600178175, 0, 2952806400, 0, 268632067, 0, 4294543328, 0, 57540095, 0, 1577058304, 0, 1835008, 0, 4294688736, 2, 65, 2, 64, 0, 33554435, 2, 123, 2, 65, 2, 151, 0, 131075, 0, 3594373096, 0, 67094296, 2, 64, -1, 0, 4294828e3, 0, 603979263, 2, 160, 0, 3, 0, 4294828001, 0, 602930687, 2, 183, 0, 393219, 0, 4294828016, 0, 671088639, 0, 2154840064, 0, 4227858435, 0, 4236247008, 2, 66, 2, 36, -1, 2, 4, 0, 917503, 2, 36, -1, 2, 67, 0, 537788335, 0, 4026531935, -1, 0, 1, -1, 2, 32, 2, 68, 0, 7936, -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 69, 2, 0, 2, 70, 2, 71, 2, 72, 2, 0, 2, 73, 2, 0, 2, 11, -1, 2, 23, 3, 0, 2, 2, 12, 2, 4, 3, 0, 18, 2, 74, 2, 5, 3, 0, 2, 2, 75, 0, 253951, 3, 19, 2, 0, 122879, 2, 0, 2, 8, 0, 276824064, -2, 3, 0, 2, 2, 40, 2, 0, 0, 4294903295, 2, 0, 2, 29, 2, 7, -1, 2, 17, 2, 49, 2, 0, 2, 76, 2, 41, -1, 2, 20, 2, 0, 2, 27, -2, 0, 128, -2, 2, 77, 2, 8, 0, 4064, -1, 2, 119, 0, 4227907585, 2, 0, 2, 118, 2, 0, 2, 48, 2, 173, 2, 9, 2, 38, 2, 10, -1, 0, 74440192, 3, 0, 6, -2, 3, 0, 8, 2, 12, 2, 0, 2, 78, 2, 9, 2, 0, 2, 79, 2, 80, 2, 81, -3, 2, 82, 2, 13, -3, 2, 83, 2, 84, 2, 85, 2, 0, 2, 33, -83, 2, 0, 2, 53, 2, 7, 3, 0, 4, 0, 817183, 2, 0, 2, 14, 2, 0, 0, 33023, 2, 20, 3, 86, 2, -17, 2, 87, 0, 524157950, 2, 4, 2, 0, 2, 88, 2, 4, 2, 0, 2, 15, 2, 77, 2, 16, 3, 0, 2, 2, 47, 2, 0, -1, 2, 17, -16, 3, 0, 206, -2, 3, 0, 655, 2, 18, 3, 0, 36, 2, 68, -1, 2, 17, 2, 9, 3, 0, 8, 2, 89, 0, 3072, 2, 0, 0, 2147516415, 2, 9, 3, 0, 2, 2, 23, 2, 90, 2, 91, 3, 0, 2, 2, 92, 2, 0, 2, 93, 2, 94, 0, 4294965179, 0, 7, 2, 0, 2, 8, 2, 91, 2, 8, -1, 0, 1761345536, 2, 95, 0, 4294901823, 2, 36, 2, 18, 2, 96, 2, 34, 2, 166, 0, 2080440287, 2, 0, 2, 33, 2, 143, 0, 3296722943, 2, 0, 0, 1046675455, 0, 939524101, 0, 1837055, 2, 97, 2, 98, 2, 15, 2, 21, 3, 0, 3, 0, 7, 3, 0, 349, 2, 99, 2, 100, 2, 6, -264, 3, 0, 11, 2, 22, 3, 0, 2, 2, 31, -1, 0, 2700607615, 2, 101, 2, 102, 3, 0, 2, 2, 19, 2, 103, 3, 0, 10, 2, 9, 2, 17, 2, 0, 2, 45, 2, 0, 2, 30, 2, 104, -3, 2, 105, 3, 0, 3, 2, 18, -1, 3, 5, 2, 2, 26, 2, 0, 2, 7, 2, 106, -1, 2, 107, 2, 108, 2, 109, -1, 3, 0, 3, 2, 11, -2, 2, 0, 2, 27, -8, 2, 18, 2, 0, 2, 35, -1, 2, 0, 2, 62, 2, 28, 2, 29, 2, 9, 2, 0, 2, 110, -1, 3, 0, 4, 2, 9, 2, 17, 2, 111, 2, 6, 2, 0, 2, 112, 2, 0, 2, 48, -4, 3, 0, 9, 2, 20, 2, 29, 2, 30, -4, 2, 113, 2, 114, 2, 29, 2, 20, 2, 7, -2, 2, 115, 2, 29, 2, 31, -2, 2, 0, 2, 116, -2, 0, 4277075969, 2, 29, -1, 3, 18, 2, -1, 2, 32, 2, 117, 2, 0, 3, 29, 2, 2, 34, 2, 19, -3, 3, 0, 2, 2, 33, -1, 2, 0, 2, 34, 2, 0, 2, 34, 2, 0, 2, 48, -10, 2, 0, 0, 197631, -2, 2, 18, 2, 43, 2, 118, -2, 2, 17, 2, 117, 2, 20, 2, 119, 2, 51, -2, 2, 119, 2, 23, 2, 17, 2, 33, 2, 119, 2, 36, 0, 4294901904, 0, 4718591, 2, 119, 2, 34, 0, 335544350, -1, 2, 120, 2, 121, -2, 2, 122, 2, 38, 2, 7, -1, 2, 123, 2, 65, 0, 3758161920, 0, 3, -4, 2, 0, 2, 27, 0, 2147485568, 0, 3, 2, 0, 2, 23, 0, 176, -5, 2, 0, 2, 47, 2, 186, -1, 2, 0, 2, 23, 2, 197, -1, 2, 0, 0, 16779263, -2, 2, 11, -7, 2, 0, 2, 121, -3, 3, 0, 2, 2, 124, 2, 125, 0, 2147549183, 0, 2, -2, 2, 126, 2, 35, 0, 10, 0, 4294965249, 0, 67633151, 0, 4026597376, 2, 0, 0, 536871935, -1, 2, 0, 2, 40, -8, 2, 54, 2, 47, 0, 1, 2, 127, 2, 23, -3, 2, 128, 2, 35, 2, 129, 2, 130, 0, 16778239, -10, 2, 34, -5, 2, 64, -2, 3, 0, 28, 2, 31, -3, 3, 0, 3, 2, 47, 3, 0, 6, 2, 48, -85, 3, 0, 33, 2, 47, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 40, 2, 7, -3, 2, 17, 2, 131, 2, 0, 2, 23, 2, 48, 2, 132, 2, 23, -21, 3, 0, 2, -4, 3, 0, 2, 0, 67583, -1, 2, 103, -2, 0, 11, 3, 0, 191, 2, 51, 3, 0, 38, 2, 29, -1, 2, 33, -279, 3, 0, 8, 2, 7, -1, 2, 133, 2, 52, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 134, 2, 135, -187, 3, 0, 2, 2, 37, 2, 0, 2, 136, 2, 137, 2, 55, 2, 0, 2, 138, 2, 139, 2, 140, 3, 0, 10, 2, 141, 2, 142, 2, 15, 3, 37, 2, 3, 53, 2, 3, 54, 2, 2, 143, -73, 2, 0, 0, 1065361407, 0, 16384, -11, 2, 0, 2, 121, -40, 3, 0, 6, 2, 117, -1, 3, 0, 2, 0, 2063, -37, 2, 55, 2, 144, 2, 145, 2, 146, 2, 147, 2, 148, -138, 3, 0, 1334, 2, 9, -1, 3, 0, 129, 2, 27, 3, 0, 6, 2, 9, 3, 0, 180, 2, 149, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 9, -47, 3, 0, 154, 2, 56, -28517, 2, 0, 0, 1, -1, 2, 124, 2, 0, 0, 8193, -21, 2, 193, 0, 10255, 0, 4, -11, 2, 64, 2, 171, -1, 0, 71680, -1, 2, 161, 0, 4292900864, 0, 805306431, -5, 2, 150, -1, 2, 157, -1, 0, 6144, -2, 2, 127, -1, 2, 154, -1, 0, 2147532800, 2, 151, 2, 165, 2, 0, 2, 164, 0, 524032, 0, 4, -4, 2, 190, 0, 205128192, 0, 1333757536, 0, 2147483696, 0, 423953, 0, 747766272, 0, 2717763192, 0, 4286578751, 0, 278545, 2, 152, 0, 4294886464, 0, 33292336, 0, 417809, 2, 152, 0, 1327482464, 0, 4278190128, 0, 700594195, 0, 1006647527, 0, 4286497336, 0, 4160749631, 2, 153, 0, 469762560, 0, 4171219488, 0, 8323120, 2, 153, 0, 202375680, 0, 3214918176, 0, 4294508592, 2, 153, -1, 0, 983584, 0, 48, 0, 58720273, 0, 3489923072, 0, 10517376, 0, 4293066815, 0, 1, 0, 2013265920, 2, 177, 2, 0, 0, 2089, 0, 3221225552, 0, 201375904, 2, 0, -2, 0, 256, 0, 122880, 0, 16777216, 2, 150, 0, 4160757760, 2, 0, -6, 2, 167, -11, 0, 3263218176, -1, 0, 49664, 0, 2160197632, 0, 8388802, -1, 0, 12713984, -1, 2, 154, 2, 159, 2, 178, -2, 2, 162, -20, 0, 3758096385, -2, 2, 155, 0, 4292878336, 2, 90, 2, 169, 0, 4294057984, -2, 2, 163, 2, 156, 2, 175, -2, 2, 155, -1, 2, 182, -1, 2, 170, 2, 124, 0, 4026593280, 0, 14, 0, 4292919296, -1, 2, 158, 0, 939588608, -1, 0, 805306368, -1, 2, 124, 0, 1610612736, 2, 156, 2, 157, 2, 4, 2, 0, -2, 2, 158, 2, 159, -3, 0, 267386880, -1, 2, 160, 0, 7168, -1, 0, 65024, 2, 154, 2, 161, 2, 179, -7, 2, 168, -8, 2, 162, -1, 0, 1426112704, 2, 163, -1, 2, 164, 0, 271581216, 0, 2149777408, 2, 23, 2, 161, 2, 124, 0, 851967, 2, 180, -1, 2, 23, 2, 181, -4, 2, 158, -20, 2, 195, 2, 165, -56, 0, 3145728, 2, 185, -4, 2, 166, 2, 124, -4, 0, 32505856, -1, 2, 167, -1, 0, 2147385088, 2, 90, 1, 2155905152, 2, -3, 2, 103, 2, 0, 2, 168, -2, 2, 169, -6, 2, 170, 0, 4026597375, 0, 1, -1, 0, 1, -1, 2, 171, -3, 2, 117, 2, 64, -2, 2, 166, -2, 2, 176, 2, 124, -878, 2, 159, -36, 2, 172, -1, 2, 201, -10, 2, 188, -5, 2, 174, -6, 0, 4294965251, 2, 27, -1, 2, 173, -1, 2, 174, -2, 0, 4227874752, -3, 0, 2146435072, 2, 159, -2, 0, 1006649344, 2, 124, -1, 2, 90, 0, 201375744, -3, 0, 134217720, 2, 90, 0, 4286677377, 0, 32896, -1, 2, 158, -3, 2, 175, -349, 2, 176, 0, 1920, 2, 177, 3, 0, 264, -11, 2, 157, -2, 2, 178, 2, 0, 0, 520617856, 0, 2692743168, 0, 36, -3, 0, 524284, -11, 2, 23, -1, 2, 187, -1, 2, 184, 0, 3221291007, 2, 178, -1, 2, 202, 0, 2158720, -3, 2, 159, 0, 1, -4, 2, 124, 0, 3808625411, 0, 3489628288, 2, 200, 0, 1207959680, 0, 3221274624, 2, 0, -3, 2, 179, 0, 120, 0, 7340032, -2, 2, 180, 2, 4, 2, 23, 2, 163, 3, 0, 4, 2, 159, -1, 2, 181, 2, 177, -1, 0, 8176, 2, 182, 2, 179, 2, 183, -1, 0, 4290773232, 2, 0, -4, 2, 163, 2, 189, 0, 15728640, 2, 177, -1, 2, 161, -1, 0, 4294934512, 3, 0, 4, -9, 2, 90, 2, 170, 2, 184, 3, 0, 4, 0, 704, 0, 1849688064, 2, 185, -1, 2, 124, 0, 4294901887, 2, 0, 0, 130547712, 0, 1879048192, 2, 199, 3, 0, 2, -1, 2, 186, 2, 187, -1, 0, 17829776, 0, 2025848832, 0, 4261477888, -2, 2, 0, -1, 0, 4286580608, -1, 0, 29360128, 2, 192, 0, 16252928, 0, 3791388672, 2, 38, 3, 0, 2, -2, 2, 196, 2, 0, -1, 2, 103, -1, 0, 66584576, -1, 2, 191, 3, 0, 9, 2, 124, -1, 0, 4294755328, 3, 0, 2, -1, 2, 161, 2, 178, 3, 0, 2, 2, 23, 2, 188, 2, 90, -2, 0, 245760, 0, 2147418112, -1, 2, 150, 2, 203, 0, 4227923456, -1, 2, 164, 2, 161, 2, 90, -3, 0, 4292870145, 0, 262144, 2, 124, 3, 0, 2, 0, 1073758848, 2, 189, -1, 0, 4227921920, 2, 190, 0, 68289024, 0, 528402016, 0, 4292927536, 3, 0, 4, -2, 0, 268435456, 2, 91, -2, 2, 191, 3, 0, 5, -1, 2, 192, 2, 163, 2, 0, -2, 0, 4227923936, 2, 62, -1, 2, 155, 2, 95, 2, 0, 2, 154, 2, 158, 3, 0, 6, -1, 2, 177, 3, 0, 3, -2, 0, 2146959360, 0, 9440640, 0, 104857600, 0, 4227923840, 3, 0, 2, 0, 768, 2, 193, 2, 77, -2, 2, 161, -2, 2, 119, -1, 2, 155, 3, 0, 8, 0, 512, 0, 8388608, 2, 194, 2, 172, 2, 187, 0, 4286578944, 3, 0, 2, 0, 1152, 0, 1266679808, 2, 191, 0, 576, 0, 4261707776, 2, 95, 3, 0, 9, 2, 155, 3, 0, 5, 2, 16, -1, 0, 2147221504, -28, 2, 178, 3, 0, 3, -3, 0, 4292902912, -6, 2, 96, 3, 0, 85, -33, 0, 4294934528, 3, 0, 126, -18, 2, 195, 3, 0, 269, -17, 2, 155, 2, 124, 2, 198, 3, 0, 2, 2, 23, 0, 4290822144, -2, 0, 67174336, 0, 520093700, 2, 17, 3, 0, 21, -2, 2, 179, 3, 0, 3, -2, 0, 30720, -1, 0, 32512, 3, 0, 2, 0, 4294770656, -191, 2, 174, -38, 2, 170, 2, 0, 2, 196, 3, 0, 279, -8, 2, 124, 2, 0, 0, 4294508543, 0, 65295, -11, 2, 177, 3, 0, 72, -3, 0, 3758159872, 0, 201391616, 3, 0, 155, -7, 2, 170, -1, 0, 384, -1, 0, 133693440, -3, 2, 196, -2, 2, 26, 3, 0, 4, 2, 169, -2, 2, 90, 2, 155, 3, 0, 4, -2, 2, 164, -1, 2, 150, 0, 335552923, 2, 197, -1, 0, 538974272, 0, 2214592512, 0, 132e3, -10, 0, 192, -8, 0, 12288, -21, 0, 134213632, 0, 4294901761, 3, 0, 42, 0, 100663424, 0, 4294965284, 3, 0, 6, -1, 0, 3221282816, 2, 198, 3, 0, 11, -1, 2, 199, 3, 0, 40, -6, 0, 4286578784, 2, 0, -2, 0, 1006694400, 3, 0, 24, 2, 35, -1, 2, 94, 3, 0, 2, 0, 1, 2, 163, 3, 0, 6, 2, 197, 0, 4110942569, 0, 1432950139, 0, 2701658217, 0, 4026532864, 0, 4026532881, 2, 0, 2, 45, 3, 0, 8, -1, 2, 158, -2, 2, 169, 0, 98304, 0, 65537, 2, 170, -5, 0, 4294950912, 2, 0, 2, 118, 0, 65528, 2, 177, 0, 4294770176, 2, 26, 3, 0, 4, -30, 2, 174, 0, 3758153728, -3, 2, 169, -2, 2, 155, 2, 188, 2, 158, -1, 2, 191, -1, 2, 161, 0, 4294754304, 3, 0, 2, -3, 0, 33554432, -2, 2, 200, -3, 2, 169, 0, 4175478784, 2, 201, 0, 4286643712, 0, 4286644216, 2, 0, -4, 2, 202, -1, 2, 165, 0, 4227923967, 3, 0, 32, -1334, 2, 163, 2, 0, -129, 2, 94, -6, 2, 163, -180, 2, 203, -233, 2, 4, 3, 0, 96, -16, 2, 163, 3, 0, 47, -154, 2, 165, 3, 0, 22381, -7, 2, 17, 3, 0, 6128], [4294967295, 4294967291, 4092460543, 4294828031, 4294967294, 134217726, 268435455, 2147483647, 1048575, 1073741823, 3892314111, 134217727, 1061158911, 536805376, 4294910143, 4160749567, 4294901759, 4294901760, 536870911, 262143, 8388607, 4294902783, 4294918143, 65535, 67043328, 2281701374, 4294967232, 2097151, 4294903807, 4194303, 255, 67108863, 4294967039, 511, 524287, 131071, 127, 4292870143, 4294902271, 4294549487, 33554431, 1023, 67047423, 4294901888, 4286578687, 4294770687, 67043583, 32767, 15, 2047999, 67043343, 16777215, 4294902e3, 4294934527, 4294966783, 4294967279, 2047, 262083, 20511, 4290772991, 41943039, 493567, 4294959104, 603979775, 65536, 602799615, 805044223, 4294965206, 8191, 1031749119, 4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095, 4294905855, 4294967264, 2868854591, 1608515583, 265232348, 534519807, 2147614720, 1060109444, 4093640016, 17376, 2139062143, 224, 4169138175, 4294909951, 4286578688, 4294967292, 4294965759, 2044, 4292870144, 4294966272, 4294967280, 8289918, 4294934399, 4294901775, 4294965375, 1602223615, 4294967259, 4294443008, 268369920, 4292804608, 486341884, 4294963199, 3087007615, 1073692671, 4128527, 4279238655, 4294902015, 4294966591, 2445279231, 3670015, 3238002687, 31, 63, 4294967288, 4294705151, 4095, 3221208447, 4294549472, 2147483648, 4285526655, 4294966527, 4294705152, 4294966143, 64, 4294966719, 16383, 3774873592, 458752, 536807423, 67043839, 3758096383, 3959414372, 3755993023, 2080374783, 4294835295, 4294967103, 4160749565, 4087, 184024726, 2862017156, 1593309078, 268434431, 268434414, 4294901763, 536870912, 2952790016, 202506752, 139264, 402653184, 4261412864, 4227922944, 49152, 61440, 3758096384, 117440512, 65280, 3233808384, 3221225472, 2097152, 4294965248, 32768, 57152, 67108864, 4293918720, 4290772992, 25165824, 57344, 4227915776, 4278190080, 4227907584, 65520, 4026531840, 4227858432, 4160749568, 3758129152, 4294836224, 63488, 1073741824, 4294967040, 4194304, 251658240, 196608, 4294963200, 64512, 417808, 4227923712, 12582912, 50331648, 65472, 4294967168, 4294966784, 16, 4294917120, 2080374784, 4096, 65408, 524288, 65532]);
        function advanceChar(e3) {
          e3.column++;
          return e3.currentChar = e3.source.charCodeAt(++e3.index);
        }
        function consumeMultiUnitCodePoint(e3, t3) {
          if ((t3 & 64512) !== 55296)
            return 0;
          const r3 = e3.source.charCodeAt(e3.index + 1);
          if ((r3 & 64512) !== 56320)
            return 0;
          t3 = e3.currentChar = 65536 + ((t3 & 1023) << 10) + (r3 & 1023);
          if ((n[(t3 >>> 5) + 0] >>> t3 & 31 & 1) === 0) {
            report(e3, 18, fromCodePoint(t3));
          }
          e3.index++;
          e3.column++;
          return 1;
        }
        function consumeLineFeed(e3, t3) {
          e3.currentChar = e3.source.charCodeAt(++e3.index);
          e3.flags |= 1;
          if ((t3 & 4) === 0) {
            e3.column = 0;
            e3.line++;
          }
        }
        function scanNewLine(e3) {
          e3.flags |= 1;
          e3.currentChar = e3.source.charCodeAt(++e3.index);
          e3.column = 0;
          e3.line++;
        }
        function isExoticECMAScriptWhitespace(e3) {
          return e3 === 160 || e3 === 65279 || e3 === 133 || e3 === 5760 || e3 >= 8192 && e3 <= 8203 || e3 === 8239 || e3 === 8287 || e3 === 12288 || e3 === 8201 || e3 === 65519;
        }
        function fromCodePoint(e3) {
          return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(e3 >>> 10) + String.fromCharCode(e3 & 1023);
        }
        function toHex(e3) {
          return e3 < 65 ? e3 - 48 : e3 - 65 + 10 & 15;
        }
        function convertTokenType(e3) {
          switch (e3) {
            case 134283266:
              return "NumericLiteral";
            case 134283267:
              return "StringLiteral";
            case 86021:
            case 86022:
              return "BooleanLiteral";
            case 86023:
              return "NullLiteral";
            case 65540:
              return "RegularExpression";
            case 67174408:
            case 67174409:
            case 132:
              return "TemplateLiteral";
            default:
              if ((e3 & 143360) === 143360)
                return "Identifier";
              if ((e3 & 4096) === 4096)
                return "Keyword";
              return "Punctuator";
          }
        }
        const s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8 | 1024, 0, 0, 8 | 2048, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8192, 0, 1 | 2, 0, 0, 8192, 0, 0, 0, 256, 0, 256 | 32768, 0, 0, 2 | 16 | 128 | 32 | 64, 2 | 16 | 128 | 32 | 64, 2 | 16 | 32 | 64, 2 | 16 | 32 | 64, 2 | 16 | 32 | 64, 2 | 16 | 32 | 64, 2 | 16 | 32 | 64, 2 | 16 | 32 | 64, 2 | 16 | 512 | 64, 2 | 16 | 512 | 64, 0, 0, 16384, 0, 0, 0, 0, 1 | 2 | 64, 1 | 2 | 64, 1 | 2 | 64, 1 | 2 | 64, 1 | 2 | 64, 1 | 2 | 64, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 1 | 2, 0, 1, 0, 0, 1 | 2 | 4096, 0, 1 | 2 | 4 | 64, 1 | 2 | 4 | 64, 1 | 2 | 4 | 64, 1 | 2 | 4 | 64, 1 | 2 | 4 | 64, 1 | 2 | 4 | 64, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 1 | 2 | 4, 16384, 0, 0, 0, 0];
        const i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
        const o = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
        function isIdentifierStart(e3) {
          return e3 <= 127 ? i[e3] : n[(e3 >>> 5) + 34816] >>> e3 & 31 & 1;
        }
        function isIdentifierPart(e3) {
          return e3 <= 127 ? o[e3] : n[(e3 >>> 5) + 0] >>> e3 & 31 & 1 || (e3 === 8204 || e3 === 8205);
        }
        const a = ["SingleLine", "MultiLine", "HTMLOpen", "HTMLClose", "HashbangComment"];
        function skipHashBang(e3) {
          const t3 = e3.source;
          if (e3.currentChar === 35 && t3.charCodeAt(e3.index + 1) === 33) {
            advanceChar(e3);
            advanceChar(e3);
            skipSingleLineComment(e3, t3, 0, 4, e3.tokenPos, e3.linePos, e3.colPos);
          }
        }
        function skipSingleHTMLComment(e3, t3, r3, n2, s2, i2, o2, a2) {
          if (n2 & 2048)
            report(e3, 0);
          return skipSingleLineComment(e3, t3, r3, s2, i2, o2, a2);
        }
        function skipSingleLineComment(e3, t3, r3, n2, i2, o2, l2) {
          const { index: c2 } = e3;
          e3.tokenPos = e3.index;
          e3.linePos = e3.line;
          e3.colPos = e3.column;
          while (e3.index < e3.end) {
            if (s[e3.currentChar] & 8) {
              const r4 = e3.currentChar === 13;
              scanNewLine(e3);
              if (r4 && e3.index < e3.end && e3.currentChar === 10)
                e3.currentChar = t3.charCodeAt(++e3.index);
              break;
            } else if ((e3.currentChar ^ 8232) <= 1) {
              scanNewLine(e3);
              break;
            }
            advanceChar(e3);
            e3.tokenPos = e3.index;
            e3.linePos = e3.line;
            e3.colPos = e3.column;
          }
          if (e3.onComment) {
            const r4 = { start: { line: o2, column: l2 }, end: { line: e3.linePos, column: e3.colPos } };
            e3.onComment(a[n2 & 255], t3.slice(c2, e3.tokenPos), i2, e3.tokenPos, r4);
          }
          return r3 | 1;
        }
        function skipMultiLineComment(e3, t3, r3) {
          const { index: n2 } = e3;
          while (e3.index < e3.end) {
            if (e3.currentChar < 43) {
              let i2 = false;
              while (e3.currentChar === 42) {
                if (!i2) {
                  r3 &= ~4;
                  i2 = true;
                }
                if (advanceChar(e3) === 47) {
                  advanceChar(e3);
                  if (e3.onComment) {
                    const r4 = { start: { line: e3.linePos, column: e3.colPos }, end: { line: e3.line, column: e3.column } };
                    e3.onComment(a[1 & 255], t3.slice(n2, e3.index - 2), n2 - 2, e3.index, r4);
                  }
                  e3.tokenPos = e3.index;
                  e3.linePos = e3.line;
                  e3.colPos = e3.column;
                  return r3;
                }
              }
              if (i2) {
                continue;
              }
              if (s[e3.currentChar] & 8) {
                if (e3.currentChar === 13) {
                  r3 |= 1 | 4;
                  scanNewLine(e3);
                } else {
                  consumeLineFeed(e3, r3);
                  r3 = r3 & ~4 | 1;
                }
              } else {
                advanceChar(e3);
              }
            } else if ((e3.currentChar ^ 8232) <= 1) {
              r3 = r3 & ~4 | 1;
              scanNewLine(e3);
            } else {
              r3 &= ~4;
              advanceChar(e3);
            }
          }
          report(e3, 16);
        }
        function scanRegularExpression(e3, t3) {
          const r3 = e3.index;
          let n2 = 0;
          e:
            while (true) {
              const t4 = e3.currentChar;
              advanceChar(e3);
              if (n2 & 1) {
                n2 &= ~1;
              } else {
                switch (t4) {
                  case 47:
                    if (!n2)
                      break e;
                    else
                      break;
                  case 92:
                    n2 |= 1;
                    break;
                  case 91:
                    n2 |= 2;
                    break;
                  case 93:
                    n2 &= 1;
                    break;
                  case 13:
                  case 10:
                  case 8232:
                  case 8233:
                    report(e3, 32);
                }
              }
              if (e3.index >= e3.source.length) {
                return report(e3, 32);
              }
            }
          const s2 = e3.index - 1;
          let i2 = 0;
          let o2 = e3.currentChar;
          const { index: a2 } = e3;
          while (isIdentifierPart(o2)) {
            switch (o2) {
              case 103:
                if (i2 & 2)
                  report(e3, 34, "g");
                i2 |= 2;
                break;
              case 105:
                if (i2 & 1)
                  report(e3, 34, "i");
                i2 |= 1;
                break;
              case 109:
                if (i2 & 4)
                  report(e3, 34, "m");
                i2 |= 4;
                break;
              case 117:
                if (i2 & 16)
                  report(e3, 34, "g");
                i2 |= 16;
                break;
              case 121:
                if (i2 & 8)
                  report(e3, 34, "y");
                i2 |= 8;
                break;
              case 115:
                if (i2 & 32)
                  report(e3, 34, "s");
                i2 |= 32;
                break;
              default:
                report(e3, 33);
            }
            o2 = advanceChar(e3);
          }
          const l2 = e3.source.slice(a2, e3.index);
          const c2 = e3.source.slice(r3, s2);
          e3.tokenRegExp = { pattern: c2, flags: l2 };
          if (t3 & 512)
            e3.tokenRaw = e3.source.slice(e3.tokenPos, e3.index);
          e3.tokenValue = validate(e3, c2, l2);
          return 65540;
        }
        function validate(e3, t3, r3) {
          try {
            return new RegExp(t3, r3);
          } catch (t4) {
            report(e3, 32);
          }
        }
        function scanString(e3, t3, r3) {
          const { index: n2 } = e3;
          let i2 = "";
          let o2 = advanceChar(e3);
          let a2 = e3.index;
          while ((s[o2] & 8) === 0) {
            if (o2 === r3) {
              i2 += e3.source.slice(a2, e3.index);
              advanceChar(e3);
              if (t3 & 512)
                e3.tokenRaw = e3.source.slice(n2, e3.index);
              e3.tokenValue = i2;
              return 134283267;
            }
            if ((o2 & 8) === 8 && o2 === 92) {
              i2 += e3.source.slice(a2, e3.index);
              o2 = advanceChar(e3);
              if (o2 < 127 || o2 === 8232 || o2 === 8233) {
                const r4 = parseEscape(e3, t3, o2);
                if (r4 >= 0)
                  i2 += fromCodePoint(r4);
                else
                  handleStringError(e3, r4, 0);
              } else {
                i2 += fromCodePoint(o2);
              }
              a2 = e3.index + 1;
            }
            if (e3.index >= e3.end)
              report(e3, 14);
            o2 = advanceChar(e3);
          }
          report(e3, 14);
        }
        function parseEscape(e3, t3, r3) {
          switch (r3) {
            case 98:
              return 8;
            case 102:
              return 12;
            case 114:
              return 13;
            case 110:
              return 10;
            case 116:
              return 9;
            case 118:
              return 11;
            case 13: {
              if (e3.index < e3.end) {
                const t4 = e3.source.charCodeAt(e3.index + 1);
                if (t4 === 10) {
                  e3.index = e3.index + 1;
                  e3.currentChar = t4;
                }
              }
            }
            case 10:
            case 8232:
            case 8233:
              e3.column = -1;
              e3.line++;
              return -1;
            case 48:
            case 49:
            case 50:
            case 51: {
              let n2 = r3 - 48;
              let i2 = e3.index + 1;
              let o2 = e3.column + 1;
              if (i2 < e3.end) {
                const r4 = e3.source.charCodeAt(i2);
                if ((s[r4] & 32) === 0) {
                  if ((n2 !== 0 || s[r4] & 512) && t3 & 1024)
                    return -2;
                } else if (t3 & 1024) {
                  return -2;
                } else {
                  e3.currentChar = r4;
                  n2 = n2 << 3 | r4 - 48;
                  i2++;
                  o2++;
                  if (i2 < e3.end) {
                    const t4 = e3.source.charCodeAt(i2);
                    if (s[t4] & 32) {
                      e3.currentChar = t4;
                      n2 = n2 << 3 | t4 - 48;
                      i2++;
                      o2++;
                    }
                  }
                  e3.flags |= 64;
                  e3.index = i2 - 1;
                  e3.column = o2 - 1;
                }
              }
              return n2;
            }
            case 52:
            case 53:
            case 54:
            case 55: {
              if (t3 & 1024)
                return -2;
              let n2 = r3 - 48;
              const i2 = e3.index + 1;
              const o2 = e3.column + 1;
              if (i2 < e3.end) {
                const t4 = e3.source.charCodeAt(i2);
                if (s[t4] & 32) {
                  n2 = n2 << 3 | t4 - 48;
                  e3.currentChar = t4;
                  e3.index = i2;
                  e3.column = o2;
                }
              }
              e3.flags |= 64;
              return n2;
            }
            case 120: {
              const t4 = advanceChar(e3);
              if ((s[t4] & 64) === 0)
                return -4;
              const r4 = toHex(t4);
              const n2 = advanceChar(e3);
              if ((s[n2] & 64) === 0)
                return -4;
              const i2 = toHex(n2);
              return r4 << 4 | i2;
            }
            case 117: {
              const t4 = advanceChar(e3);
              if (e3.currentChar === 123) {
                let t5 = 0;
                while ((s[advanceChar(e3)] & 64) !== 0) {
                  t5 = t5 << 4 | toHex(e3.currentChar);
                  if (t5 > 1114111)
                    return -5;
                }
                if (e3.currentChar < 1 || e3.currentChar !== 125) {
                  return -4;
                }
                return t5;
              } else {
                if ((s[t4] & 64) === 0)
                  return -4;
                const r4 = e3.source.charCodeAt(e3.index + 1);
                if ((s[r4] & 64) === 0)
                  return -4;
                const n2 = e3.source.charCodeAt(e3.index + 2);
                if ((s[n2] & 64) === 0)
                  return -4;
                const i2 = e3.source.charCodeAt(e3.index + 3);
                if ((s[i2] & 64) === 0)
                  return -4;
                e3.index += 3;
                e3.column += 3;
                e3.currentChar = e3.source.charCodeAt(e3.index);
                return toHex(t4) << 12 | toHex(r4) << 8 | toHex(n2) << 4 | toHex(i2);
              }
            }
            case 56:
            case 57:
              if ((t3 & 256) === 0)
                return -3;
            default:
              return r3;
          }
        }
        function handleStringError(e3, t3, r3) {
          switch (t3) {
            case -1:
              return;
            case -2:
              report(e3, r3 ? 2 : 1);
            case -3:
              report(e3, 13);
            case -4:
              report(e3, 6);
            case -5:
              report(e3, 101);
          }
        }
        function scanTemplate(e3, t3) {
          const { index: r3 } = e3;
          let n2 = 67174409;
          let s2 = "";
          let i2 = advanceChar(e3);
          while (i2 !== 96) {
            if (i2 === 36 && e3.source.charCodeAt(e3.index + 1) === 123) {
              advanceChar(e3);
              n2 = 67174408;
              break;
            } else if ((i2 & 8) === 8 && i2 === 92) {
              i2 = advanceChar(e3);
              if (i2 > 126) {
                s2 += fromCodePoint(i2);
              } else {
                const r4 = parseEscape(e3, t3 | 1024, i2);
                if (r4 >= 0) {
                  s2 += fromCodePoint(r4);
                } else if (r4 !== -1 && t3 & 65536) {
                  s2 = void 0;
                  i2 = scanBadTemplate(e3, i2);
                  if (i2 < 0)
                    n2 = 67174408;
                  break;
                } else {
                  handleStringError(e3, r4, 1);
                }
              }
            } else {
              if (e3.index < e3.end && i2 === 13 && e3.source.charCodeAt(e3.index) === 10) {
                s2 += fromCodePoint(i2);
                e3.currentChar = e3.source.charCodeAt(++e3.index);
              }
              if ((i2 & 83) < 3 && i2 === 10 || (i2 ^ 8232) <= 1) {
                e3.column = -1;
                e3.line++;
              }
              s2 += fromCodePoint(i2);
            }
            if (e3.index >= e3.end)
              report(e3, 15);
            i2 = advanceChar(e3);
          }
          advanceChar(e3);
          e3.tokenValue = s2;
          e3.tokenRaw = e3.source.slice(r3 + 1, e3.index - (n2 === 67174409 ? 1 : 2));
          return n2;
        }
        function scanBadTemplate(e3, t3) {
          while (t3 !== 96) {
            switch (t3) {
              case 36: {
                const r3 = e3.index + 1;
                if (r3 < e3.end && e3.source.charCodeAt(r3) === 123) {
                  e3.index = r3;
                  e3.column++;
                  return -t3;
                }
                break;
              }
              case 10:
              case 8232:
              case 8233:
                e3.column = -1;
                e3.line++;
            }
            if (e3.index >= e3.end)
              report(e3, 15);
            t3 = advanceChar(e3);
          }
          return t3;
        }
        function scanTemplateTail(e3, t3) {
          if (e3.index >= e3.end)
            report(e3, 0);
          e3.index--;
          e3.column--;
          return scanTemplate(e3, t3);
        }
        function scanNumber(e3, t3, r3) {
          let n2 = e3.currentChar;
          let i2 = 0;
          let o2 = 9;
          let a2 = r3 & 64 ? 0 : 1;
          let l2 = 0;
          let c2 = 0;
          if (r3 & 64) {
            i2 = "." + scanDecimalDigitsOrSeparator(e3, n2);
            n2 = e3.currentChar;
            if (n2 === 110)
              report(e3, 11);
          } else {
            if (n2 === 48) {
              n2 = advanceChar(e3);
              if ((n2 | 32) === 120) {
                r3 = 8 | 128;
                n2 = advanceChar(e3);
                while (s[n2] & (64 | 4096)) {
                  if (n2 === 95) {
                    if (!c2)
                      report(e3, 146);
                    c2 = 0;
                    n2 = advanceChar(e3);
                    continue;
                  }
                  c2 = 1;
                  i2 = i2 * 16 + toHex(n2);
                  l2++;
                  n2 = advanceChar(e3);
                }
                if (l2 < 1 || !c2) {
                  report(e3, l2 < 1 ? 19 : 147);
                }
              } else if ((n2 | 32) === 111) {
                r3 = 4 | 128;
                n2 = advanceChar(e3);
                while (s[n2] & (32 | 4096)) {
                  if (n2 === 95) {
                    if (!c2) {
                      report(e3, 146);
                    }
                    c2 = 0;
                    n2 = advanceChar(e3);
                    continue;
                  }
                  c2 = 1;
                  i2 = i2 * 8 + (n2 - 48);
                  l2++;
                  n2 = advanceChar(e3);
                }
                if (l2 < 1 || !c2) {
                  report(e3, l2 < 1 ? 0 : 147);
                }
              } else if ((n2 | 32) === 98) {
                r3 = 2 | 128;
                n2 = advanceChar(e3);
                while (s[n2] & (128 | 4096)) {
                  if (n2 === 95) {
                    if (!c2) {
                      report(e3, 146);
                    }
                    c2 = 0;
                    n2 = advanceChar(e3);
                    continue;
                  }
                  c2 = 1;
                  i2 = i2 * 2 + (n2 - 48);
                  l2++;
                  n2 = advanceChar(e3);
                }
                if (l2 < 1 || !c2) {
                  report(e3, l2 < 1 ? 0 : 147);
                }
              } else if (s[n2] & 32) {
                if (t3 & 1024)
                  report(e3, 1);
                r3 = 1;
                while (s[n2] & 16) {
                  if (s[n2] & 512) {
                    r3 = 32;
                    a2 = 0;
                    break;
                  }
                  i2 = i2 * 8 + (n2 - 48);
                  n2 = advanceChar(e3);
                }
              } else if (s[n2] & 512) {
                if (t3 & 1024)
                  report(e3, 1);
                e3.flags |= 64;
                r3 = 32;
              } else if (n2 === 95) {
                report(e3, 0);
              }
            }
            if (r3 & 48) {
              if (a2) {
                while (o2 >= 0 && s[n2] & (16 | 4096)) {
                  if (n2 === 95) {
                    n2 = advanceChar(e3);
                    if (n2 === 95 || r3 & 32) {
                      reportScannerError(e3.index, e3.line, e3.index + 1, 146);
                    }
                    c2 = 1;
                    continue;
                  }
                  c2 = 0;
                  i2 = 10 * i2 + (n2 - 48);
                  n2 = advanceChar(e3);
                  --o2;
                }
                if (c2) {
                  reportScannerError(e3.index, e3.line, e3.index + 1, 147);
                }
                if (o2 >= 0 && !isIdentifierStart(n2) && n2 !== 46) {
                  e3.tokenValue = i2;
                  if (t3 & 512)
                    e3.tokenRaw = e3.source.slice(e3.tokenPos, e3.index);
                  return 134283266;
                }
              }
              i2 += scanDecimalDigitsOrSeparator(e3, n2);
              n2 = e3.currentChar;
              if (n2 === 46) {
                if (advanceChar(e3) === 95)
                  report(e3, 0);
                r3 = 64;
                i2 += "." + scanDecimalDigitsOrSeparator(e3, e3.currentChar);
                n2 = e3.currentChar;
              }
            }
          }
          const p2 = e3.index;
          let u2 = 0;
          if (n2 === 110 && r3 & 128) {
            u2 = 1;
            n2 = advanceChar(e3);
          } else {
            if ((n2 | 32) === 101) {
              n2 = advanceChar(e3);
              if (s[n2] & 256)
                n2 = advanceChar(e3);
              const { index: t4 } = e3;
              if ((s[n2] & 16) < 1)
                report(e3, 10);
              i2 += e3.source.substring(p2, t4) + scanDecimalDigitsOrSeparator(e3, n2);
              n2 = e3.currentChar;
            }
          }
          if (e3.index < e3.end && s[n2] & 16 || isIdentifierStart(n2)) {
            report(e3, 12);
          }
          if (u2) {
            e3.tokenRaw = e3.source.slice(e3.tokenPos, e3.index);
            e3.tokenValue = BigInt(i2);
            return 134283389;
          }
          e3.tokenValue = r3 & (1 | 2 | 8 | 4) ? i2 : r3 & 32 ? parseFloat(e3.source.substring(e3.tokenPos, e3.index)) : +i2;
          if (t3 & 512)
            e3.tokenRaw = e3.source.slice(e3.tokenPos, e3.index);
          return 134283266;
        }
        function scanDecimalDigitsOrSeparator(e3, t3) {
          let r3 = 0;
          let n2 = e3.index;
          let i2 = "";
          while (s[t3] & (16 | 4096)) {
            if (t3 === 95) {
              const { index: s2 } = e3;
              t3 = advanceChar(e3);
              if (t3 === 95) {
                reportScannerError(e3.index, e3.line, e3.index + 1, 146);
              }
              r3 = 1;
              i2 += e3.source.substring(n2, s2);
              n2 = e3.index;
              continue;
            }
            r3 = 0;
            t3 = advanceChar(e3);
          }
          if (r3) {
            reportScannerError(e3.index, e3.line, e3.index + 1, 147);
          }
          return i2 + e3.source.substring(n2, e3.index);
        }
        const l = ["end of source", "identifier", "number", "string", "regular expression", "false", "true", "null", "template continuation", "template tail", "=>", "(", "{", ".", "...", "}", ")", ";", ",", "[", "]", ":", "?", "'", '"', "</", "/>", "++", "--", "=", "<<=", ">>=", ">>>=", "**=", "+=", "-=", "*=", "/=", "%=", "^=", "|=", "&=", "||=", "&&=", "??=", "typeof", "delete", "void", "!", "~", "+", "-", "in", "instanceof", "*", "%", "/", "**", "&&", "||", "===", "!==", "==", "!=", "<=", ">=", "<", ">", "<<", ">>", ">>>", "&", "|", "^", "var", "let", "const", "break", "case", "catch", "class", "continue", "debugger", "default", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "new", "return", "super", "switch", "this", "throw", "try", "while", "with", "implements", "interface", "package", "private", "protected", "public", "static", "yield", "as", "async", "await", "constructor", "get", "set", "from", "of", "enum", "eval", "arguments", "escaped keyword", "escaped future reserved keyword", "reserved if strict", "#", "BigIntLiteral", "??", "?.", "WhiteSpace", "Illegal", "LineTerminator", "PrivateField", "Template", "@", "target", "meta", "LineFeed", "Escaped", "JSXText"];
        const c = Object.create(null, { this: { value: 86113 }, function: { value: 86106 }, if: { value: 20571 }, return: { value: 20574 }, var: { value: 86090 }, else: { value: 20565 }, for: { value: 20569 }, new: { value: 86109 }, in: { value: 8738868 }, typeof: { value: 16863277 }, while: { value: 20580 }, case: { value: 20558 }, break: { value: 20557 }, try: { value: 20579 }, catch: { value: 20559 }, delete: { value: 16863278 }, throw: { value: 86114 }, switch: { value: 86112 }, continue: { value: 20561 }, default: { value: 20563 }, instanceof: { value: 8476725 }, do: { value: 20564 }, void: { value: 16863279 }, finally: { value: 20568 }, async: { value: 209007 }, await: { value: 209008 }, class: { value: 86096 }, const: { value: 86092 }, constructor: { value: 12401 }, debugger: { value: 20562 }, export: { value: 20566 }, extends: { value: 20567 }, false: { value: 86021 }, from: { value: 12404 }, get: { value: 12402 }, implements: { value: 36966 }, import: { value: 86108 }, interface: { value: 36967 }, let: { value: 241739 }, null: { value: 86023 }, of: { value: 274549 }, package: { value: 36968 }, private: { value: 36969 }, protected: { value: 36970 }, public: { value: 36971 }, set: { value: 12403 }, static: { value: 36972 }, super: { value: 86111 }, true: { value: 86022 }, with: { value: 20581 }, yield: { value: 241773 }, enum: { value: 86134 }, eval: { value: 537079927 }, as: { value: 77934 }, arguments: { value: 537079928 }, target: { value: 143494 }, meta: { value: 143495 } });
        function scanIdentifier(e3, t3, r3) {
          while (o[advanceChar(e3)]) {
          }
          e3.tokenValue = e3.source.slice(e3.tokenPos, e3.index);
          return e3.currentChar !== 92 && e3.currentChar < 126 ? c[e3.tokenValue] || 208897 : scanIdentifierSlowCase(e3, t3, 0, r3);
        }
        function scanUnicodeIdentifier(e3, t3) {
          const r3 = scanIdentifierUnicodeEscape(e3);
          if (!isIdentifierPart(r3))
            report(e3, 4);
          e3.tokenValue = fromCodePoint(r3);
          return scanIdentifierSlowCase(e3, t3, 1, s[r3] & 4);
        }
        function scanIdentifierSlowCase(e3, t3, r3, n2) {
          let i2 = e3.index;
          while (e3.index < e3.end) {
            if (e3.currentChar === 92) {
              e3.tokenValue += e3.source.slice(i2, e3.index);
              r3 = 1;
              const t4 = scanIdentifierUnicodeEscape(e3);
              if (!isIdentifierPart(t4))
                report(e3, 4);
              n2 = n2 && s[t4] & 4;
              e3.tokenValue += fromCodePoint(t4);
              i2 = e3.index;
            } else if (isIdentifierPart(e3.currentChar) || consumeMultiUnitCodePoint(e3, e3.currentChar)) {
              advanceChar(e3);
            } else {
              break;
            }
          }
          if (e3.index <= e3.end) {
            e3.tokenValue += e3.source.slice(i2, e3.index);
          }
          const o2 = e3.tokenValue.length;
          if (n2 && o2 >= 2 && o2 <= 11) {
            const n3 = c[e3.tokenValue];
            if (n3 === void 0)
              return 208897;
            if (!r3)
              return n3;
            if (t3 & 1024) {
              return n3 === 209008 && (t3 & (2048 | 4194304)) === 0 ? n3 : n3 === 36972 ? 122 : (n3 & 36864) === 36864 ? 122 : 121;
            }
            if (t3 & 1073741824 && (t3 & 8192) === 0 && (n3 & 20480) === 20480)
              return n3;
            if (n3 === 241773) {
              return t3 & 1073741824 ? 143483 : t3 & 2097152 ? 121 : n3;
            }
            return n3 === 209007 && t3 & 1073741824 ? 143483 : (n3 & 36864) === 36864 ? n3 : n3 === 209008 && (t3 & 4194304) === 0 ? n3 : 121;
          }
          return 208897;
        }
        function scanPrivateIdentifier(e3) {
          if (!isIdentifierStart(advanceChar(e3)))
            report(e3, 93);
          return 131;
        }
        function scanIdentifierUnicodeEscape(e3) {
          if (e3.source.charCodeAt(e3.index + 1) !== 117) {
            report(e3, 4);
          }
          e3.currentChar = e3.source.charCodeAt(e3.index += 2);
          return scanUnicodeEscape(e3);
        }
        function scanUnicodeEscape(e3) {
          let t3 = 0;
          const r3 = e3.currentChar;
          if (r3 === 123) {
            const r4 = e3.index - 2;
            while (s[advanceChar(e3)] & 64) {
              t3 = t3 << 4 | toHex(e3.currentChar);
              if (t3 > 1114111)
                reportScannerError(r4, e3.line, e3.index + 1, 101);
            }
            if (e3.currentChar !== 125) {
              reportScannerError(r4, e3.line, e3.index - 1, 6);
            }
            advanceChar(e3);
            return t3;
          }
          if ((s[r3] & 64) === 0)
            report(e3, 6);
          const n2 = e3.source.charCodeAt(e3.index + 1);
          if ((s[n2] & 64) === 0)
            report(e3, 6);
          const i2 = e3.source.charCodeAt(e3.index + 2);
          if ((s[i2] & 64) === 0)
            report(e3, 6);
          const o2 = e3.source.charCodeAt(e3.index + 3);
          if ((s[o2] & 64) === 0)
            report(e3, 6);
          t3 = toHex(r3) << 12 | toHex(n2) << 8 | toHex(i2) << 4 | toHex(o2);
          e3.currentChar = e3.source.charCodeAt(e3.index += 4);
          return t3;
        }
        const p = [129, 129, 129, 129, 129, 129, 129, 129, 129, 128, 136, 128, 128, 130, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 128, 16842800, 134283267, 131, 208897, 8457015, 8455751, 134283267, 67174411, 16, 8457014, 25233970, 18, 25233971, 67108877, 8457016, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 21, 1074790417, 8456258, 1077936157, 8456259, 22, 133, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 69271571, 137, 20, 8455497, 208897, 132, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 208897, 4096, 208897, 208897, 4096, 208897, 4096, 208897, 4096, 208897, 4096, 4096, 4096, 208897, 4096, 4096, 208897, 4096, 4096, 2162700, 8455240, 1074790415, 16842801, 129];
        function nextToken(e3, t3) {
          e3.flags = (e3.flags | 1) ^ 1;
          e3.startPos = e3.index;
          e3.startColumn = e3.column;
          e3.startLine = e3.line;
          e3.token = scanSingleToken(e3, t3, 0);
          if (e3.onToken && e3.token !== 1048576) {
            const t4 = { start: { line: e3.linePos, column: e3.colPos }, end: { line: e3.line, column: e3.column } };
            e3.onToken(convertTokenType(e3.token), e3.tokenPos, e3.index, t4);
          }
        }
        function scanSingleToken(e3, t3, r3) {
          const s2 = e3.index === 0;
          const i2 = e3.source;
          let o2 = e3.index;
          let a2 = e3.line;
          let l2 = e3.column;
          while (e3.index < e3.end) {
            e3.tokenPos = e3.index;
            e3.colPos = e3.column;
            e3.linePos = e3.line;
            let c2 = e3.currentChar;
            if (c2 <= 126) {
              const n2 = p[c2];
              switch (n2) {
                case 67174411:
                case 16:
                case 2162700:
                case 1074790415:
                case 69271571:
                case 20:
                case 21:
                case 1074790417:
                case 18:
                case 16842801:
                case 133:
                case 129:
                  advanceChar(e3);
                  return n2;
                case 208897:
                  return scanIdentifier(e3, t3, 0);
                case 4096:
                  return scanIdentifier(e3, t3, 1);
                case 134283266:
                  return scanNumber(e3, t3, 16 | 128);
                case 134283267:
                  return scanString(e3, t3, c2);
                case 132:
                  return scanTemplate(e3, t3);
                case 137:
                  return scanUnicodeIdentifier(e3, t3);
                case 131:
                  return scanPrivateIdentifier(e3);
                case 128:
                  advanceChar(e3);
                  break;
                case 130:
                  r3 |= 1 | 4;
                  scanNewLine(e3);
                  break;
                case 136:
                  consumeLineFeed(e3, r3);
                  r3 = r3 & ~4 | 1;
                  break;
                case 8456258:
                  let p2 = advanceChar(e3);
                  if (e3.index < e3.end) {
                    if (p2 === 60) {
                      if (e3.index < e3.end && advanceChar(e3) === 61) {
                        advanceChar(e3);
                        return 4194334;
                      }
                      return 8456516;
                    } else if (p2 === 61) {
                      advanceChar(e3);
                      return 8456256;
                    }
                    if (p2 === 33) {
                      const n3 = e3.index + 1;
                      if (n3 + 1 < e3.end && i2.charCodeAt(n3) === 45 && i2.charCodeAt(n3 + 1) == 45) {
                        e3.column += 3;
                        e3.currentChar = i2.charCodeAt(e3.index += 3);
                        r3 = skipSingleHTMLComment(e3, i2, r3, t3, 2, e3.tokenPos, e3.linePos, e3.colPos);
                        o2 = e3.tokenPos;
                        a2 = e3.linePos;
                        l2 = e3.colPos;
                        continue;
                      }
                      return 8456258;
                    }
                    if (p2 === 47) {
                      if ((t3 & 16) < 1)
                        return 8456258;
                      const r4 = e3.index + 1;
                      if (r4 < e3.end) {
                        p2 = i2.charCodeAt(r4);
                        if (p2 === 42 || p2 === 47)
                          break;
                      }
                      advanceChar(e3);
                      return 25;
                    }
                  }
                  return 8456258;
                case 1077936157: {
                  advanceChar(e3);
                  const t4 = e3.currentChar;
                  if (t4 === 61) {
                    if (advanceChar(e3) === 61) {
                      advanceChar(e3);
                      return 8455996;
                    }
                    return 8455998;
                  }
                  if (t4 === 62) {
                    advanceChar(e3);
                    return 10;
                  }
                  return 1077936157;
                }
                case 16842800:
                  if (advanceChar(e3) !== 61) {
                    return 16842800;
                  }
                  if (advanceChar(e3) !== 61) {
                    return 8455999;
                  }
                  advanceChar(e3);
                  return 8455997;
                case 8457015:
                  if (advanceChar(e3) !== 61)
                    return 8457015;
                  advanceChar(e3);
                  return 4194342;
                case 8457014: {
                  advanceChar(e3);
                  if (e3.index >= e3.end)
                    return 8457014;
                  const t4 = e3.currentChar;
                  if (t4 === 61) {
                    advanceChar(e3);
                    return 4194340;
                  }
                  if (t4 !== 42)
                    return 8457014;
                  if (advanceChar(e3) !== 61)
                    return 8457273;
                  advanceChar(e3);
                  return 4194337;
                }
                case 8455497:
                  if (advanceChar(e3) !== 61)
                    return 8455497;
                  advanceChar(e3);
                  return 4194343;
                case 25233970: {
                  advanceChar(e3);
                  const t4 = e3.currentChar;
                  if (t4 === 43) {
                    advanceChar(e3);
                    return 33619995;
                  }
                  if (t4 === 61) {
                    advanceChar(e3);
                    return 4194338;
                  }
                  return 25233970;
                }
                case 25233971: {
                  advanceChar(e3);
                  const n3 = e3.currentChar;
                  if (n3 === 45) {
                    advanceChar(e3);
                    if ((r3 & 1 || s2) && e3.currentChar === 62) {
                      if ((t3 & 256) === 0)
                        report(e3, 108);
                      advanceChar(e3);
                      r3 = skipSingleHTMLComment(e3, i2, r3, t3, 3, o2, a2, l2);
                      o2 = e3.tokenPos;
                      a2 = e3.linePos;
                      l2 = e3.colPos;
                      continue;
                    }
                    return 33619996;
                  }
                  if (n3 === 61) {
                    advanceChar(e3);
                    return 4194339;
                  }
                  return 25233971;
                }
                case 8457016: {
                  advanceChar(e3);
                  if (e3.index < e3.end) {
                    const n3 = e3.currentChar;
                    if (n3 === 47) {
                      advanceChar(e3);
                      r3 = skipSingleLineComment(e3, i2, r3, 0, e3.tokenPos, e3.linePos, e3.colPos);
                      o2 = e3.tokenPos;
                      a2 = e3.linePos;
                      l2 = e3.colPos;
                      continue;
                    }
                    if (n3 === 42) {
                      advanceChar(e3);
                      r3 = skipMultiLineComment(e3, i2, r3);
                      o2 = e3.tokenPos;
                      a2 = e3.linePos;
                      l2 = e3.colPos;
                      continue;
                    }
                    if (t3 & 32768) {
                      return scanRegularExpression(e3, t3);
                    }
                    if (n3 === 61) {
                      advanceChar(e3);
                      return 4259877;
                    }
                  }
                  return 8457016;
                }
                case 67108877:
                  const u2 = advanceChar(e3);
                  if (u2 >= 48 && u2 <= 57)
                    return scanNumber(e3, t3, 64 | 16);
                  if (u2 === 46) {
                    const t4 = e3.index + 1;
                    if (t4 < e3.end && i2.charCodeAt(t4) === 46) {
                      e3.column += 2;
                      e3.currentChar = i2.charCodeAt(e3.index += 2);
                      return 14;
                    }
                  }
                  return 67108877;
                case 8455240: {
                  advanceChar(e3);
                  const t4 = e3.currentChar;
                  if (t4 === 124) {
                    advanceChar(e3);
                    if (e3.currentChar === 61) {
                      advanceChar(e3);
                      return 4194346;
                    }
                    return 8979003;
                  }
                  if (t4 === 61) {
                    advanceChar(e3);
                    return 4194344;
                  }
                  return 8455240;
                }
                case 8456259: {
                  advanceChar(e3);
                  const t4 = e3.currentChar;
                  if (t4 === 61) {
                    advanceChar(e3);
                    return 8456257;
                  }
                  if (t4 !== 62)
                    return 8456259;
                  advanceChar(e3);
                  if (e3.index < e3.end) {
                    const t5 = e3.currentChar;
                    if (t5 === 62) {
                      if (advanceChar(e3) === 61) {
                        advanceChar(e3);
                        return 4194336;
                      }
                      return 8456518;
                    }
                    if (t5 === 61) {
                      advanceChar(e3);
                      return 4194335;
                    }
                  }
                  return 8456517;
                }
                case 8455751: {
                  advanceChar(e3);
                  const t4 = e3.currentChar;
                  if (t4 === 38) {
                    advanceChar(e3);
                    if (e3.currentChar === 61) {
                      advanceChar(e3);
                      return 4194347;
                    }
                    return 8979258;
                  }
                  if (t4 === 61) {
                    advanceChar(e3);
                    return 4194345;
                  }
                  return 8455751;
                }
                case 22: {
                  let t4 = advanceChar(e3);
                  if (t4 === 63) {
                    advanceChar(e3);
                    if (e3.currentChar === 61) {
                      advanceChar(e3);
                      return 4194348;
                    }
                    return 276889982;
                  }
                  if (t4 === 46) {
                    const r4 = e3.index + 1;
                    if (r4 < e3.end) {
                      t4 = i2.charCodeAt(r4);
                      if (!(t4 >= 48 && t4 <= 57)) {
                        advanceChar(e3);
                        return 67108991;
                      }
                    }
                  }
                  return 22;
                }
              }
            } else {
              if ((c2 ^ 8232) <= 1) {
                r3 = r3 & ~4 | 1;
                scanNewLine(e3);
                continue;
              }
              if ((c2 & 64512) === 55296 || (n[(c2 >>> 5) + 34816] >>> c2 & 31 & 1) !== 0) {
                if ((c2 & 64512) === 56320) {
                  c2 = (c2 & 1023) << 10 | c2 & 1023 | 65536;
                  if ((n[(c2 >>> 5) + 0] >>> c2 & 31 & 1) === 0) {
                    report(e3, 18, fromCodePoint(c2));
                  }
                  e3.index++;
                  e3.currentChar = c2;
                }
                e3.column++;
                e3.tokenValue = "";
                return scanIdentifierSlowCase(e3, t3, 0, 0);
              }
              if (isExoticECMAScriptWhitespace(c2)) {
                advanceChar(e3);
                continue;
              }
              report(e3, 18, fromCodePoint(c2));
            }
          }
          return 1048576;
        }
        const u = { AElig: "\xC6", AMP: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", Aring: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", Bcy: "\u0411", Because: "\u2235", Bernoullis: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", Bscr: "\u212C", Bumpeq: "\u224E", CHcy: "\u0427", COPY: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", Cayleys: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", CenterDot: "\xB7", Cfr: "\u212D", Chi: "\u03A7", CircleDot: "\u2299", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", Colon: "\u2237", Colone: "\u2A74", Congruent: "\u2261", Conint: "\u222F", ContourIntegral: "\u222E", Copf: "\u2102", Coproduct: "\u2210", CounterClockwiseContourIntegral: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", DD: "\u2145", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", Diamond: "\u22C4", DifferentialD: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", Downarrow: "\u21D3", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrave: "\xC8", Element: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", Equilibrium: "\u21CC", Escr: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", ExponentialE: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", HilbertSpace: "\u210B", Hopf: "\u210D", HorizontalLine: "\u2500", Hscr: "\u210B", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Igrave: "\xCC", Im: "\u2111", Imacr: "\u012A", ImaginaryI: "\u2148", Implies: "\u21D2", Int: "\u222C", Integral: "\u222B", Intersection: "\u22C2", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", LT: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Larr: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", LeftRightArrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", Leftarrow: "\u21D0", Leftrightarrow: "\u21D4", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", LongLeftRightArrow: "\u27F7", LongRightArrow: "\u27F6", Longleftarrow: "\u27F8", Longleftrightarrow: "\u27FA", Longrightarrow: "\u27F9", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", Lscr: "\u2112", Lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", Mopf: "\u{1D544}", Mscr: "\u2133", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", Nscr: "\u{1D4A9}", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", Poincareplane: "\u210C", Popf: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", Prime: "\u2033", Product: "\u220F", Proportion: "\u2237", Proportional: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUOT: '"', Qfr: "\u{1D514}", Qopf: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", REG: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", Rfr: "\u211C", Rho: "\u03A1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", Rightarrow: "\u21D2", Ropf: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", Rscr: "\u211B", Rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", SuchThat: "\u220B", Sum: "\u2211", Sup: "\u22D1", Superset: "\u2283", SupersetEqual: "\u2287", Supset: "\u22D1", THORN: "\xDE", TRADE: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", UpTee: "\u22A5", UpTeeArrow: "\u21A5", Uparrow: "\u21D1", Updownarrow: "\u21D5", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", ZeroWidthSpace: "\u200B", Zeta: "\u0396", Zfr: "\u2128", Zopf: "\u2124", Zscr: "\u{1D4B5}", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acute: "\xB4", acy: "\u0430", aelig: "\xE6", af: "\u2061", afr: "\u{1D51E}", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", amp: "&", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", ap: "\u2248", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", apid: "\u224B", apos: "'", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", beta: "\u03B2", beth: "\u2136", between: "\u226C", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxh: "\u2500", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", bprime: "\u2035", breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", bumpeq: "\u224F", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cedil: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledR: "\xAE", circledS: "\u24C8", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", conint: "\u222E", copf: "\u{1D554}", coprod: "\u2210", copy: "\xA9", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dArr: "\u21D3", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", darr: "\u2193", dash: "\u2010", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", dcy: "\u0434", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", ddotseq: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", dharl: "\u21C3", dharr: "\u21C2", diam: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", dot: "\u02D9", doteq: "\u2250", doteqdot: "\u2251", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", downarrow: "\u2193", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eDDot: "\u2A77", eDot: "\u2251", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", ecirc: "\xEA", ecolon: "\u2255", ecy: "\u044D", edot: "\u0117", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", equals: "=", equest: "\u225F", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", erarr: "\u2971", escr: "\u212F", esdot: "\u2250", esim: "\u2242", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", expectation: "\u2130", exponentiale: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", gE: "\u2267", gEl: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gammad: "\u03DD", gap: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", ge: "\u2265", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", gl: "\u2277", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", grave: "`", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hArr: "\u21D4", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", hbar: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hslash: "\u210F", hstrok: "\u0127", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", ic: "\u2063", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", image: "\u2111", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", intcal: "\u22BA", integers: "\u2124", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", isin: "\u2208", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAarr: "\u21DA", lArr: "\u21D0", lAtail: "\u291B", lBarr: "\u290E", lE: "\u2266", lEg: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", laquo: "\xAB", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lceil: "\u2308", lcub: "{", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leftarrow: "\u2190", leftarrowtail: "\u21A2", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", leftthreetimes: "\u22CB", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", lessgtr: "\u2276", lesssim: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", measuredangle: "\u2221", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", mstpos: "\u223E", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nGtv: "\u226B\u0338", nLeftarrow: "\u21CD", nLeftrightarrow: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nLtv: "\u226A\u0338", nRightarrow: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nabla: "\u2207", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", neArr: "\u21D7", nearhk: "\u2924", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", ngsim: "\u2275", ngt: "\u226F", ngtr: "\u226F", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", nlArr: "\u21CD", nlE: "\u2266\u0338", nlarr: "\u219A", nldr: "\u2025", nle: "\u2270", nleftarrow: "\u219A", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nlsim: "\u2274", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nmid: "\u2224", nopf: "\u{1D55F}", not: "\xAC", notin: "\u2209", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", oS: "\u24C8", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", ocy: "\u043E", odash: "\u229D", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", oplus: "\u2295", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oscr: "\u2134", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimes: "\u2297", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", pointint: "\u2A15", popf: "\u{1D561}", pound: "\xA3", pr: "\u227A", prE: "\u2AB3", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", primes: "\u2119", prnE: "\u2AB5", prnap: "\u2AB9", prnsim: "\u22E8", prod: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', rAarr: "\u21DB", rArr: "\u21D2", rAtail: "\u291C", rBarr: "\u290F", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rceil: "\u2309", rcub: "}", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", rightarrow: "\u2192", rightarrowtail: "\u21A3", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", rightthreetimes: "\u22CC", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", rsaquo: "\u203A", rscr: "\u{1D4C7}", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", sbquo: "\u201A", sc: "\u227B", scE: "\u2AB4", scap: "\u2AB8", scaron: "\u0161", sccue: "\u227D", sce: "\u2AB0", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", scnap: "\u2ABA", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", seArr: "\u21D8", searhk: "\u2925", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shortmid: "\u2223", shortparallel: "\u2225", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", subE: "\u2AC5", subdot: "\u2ABD", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", supE: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swarhk: "\u2926", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tbrk: "\u23B4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", thorn: "\xFE", tilde: "\u02DC", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uArr: "\u21D1", uHar: "\u2963", uacute: "\xFA", uarr: "\u2191", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udarr: "\u21C5", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", ufr: "\u{1D532}", ugrave: "\xF9", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uml: "\xA8", uogon: "\u0173", uopf: "\u{1D566}", uparrow: "\u2191", updownarrow: "\u2195", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", upsi: "\u03C5", upsih: "\u03D2", upsilon: "\u03C5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uuml: "\xFC", uwangle: "\u29A7", vArr: "\u21D5", vBar: "\u2AE8", vBarv: "\u2AE9", vDash: "\u22A8", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vcy: "\u0432", vdash: "\u22A2", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", vert: "|", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeetrf: "\u2128", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
        const f = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
        function decodeHTMLStrict(e3) {
          return e3.replace(/&(?:[a-zA-Z]+|#[xX][\da-fA-F]+|#\d+);/g, (e4) => {
            if (e4.charAt(1) === "#") {
              const t3 = e4.charAt(2);
              const r3 = t3 === "X" || t3 === "x" ? parseInt(e4.slice(3), 16) : parseInt(e4.slice(2), 10);
              return decodeCodePoint(r3);
            }
            return u[e4.slice(1, -1)] || e4;
          });
        }
        function decodeCodePoint(e3) {
          if (e3 >= 55296 && e3 <= 57343 || e3 > 1114111) {
            return "\uFFFD";
          }
          if (e3 in f) {
            e3 = f[e3];
          }
          return String.fromCodePoint(e3);
        }
        function scanJSXAttributeValue(e3, t3) {
          e3.startPos = e3.tokenPos = e3.index;
          e3.startColumn = e3.colPos = e3.column;
          e3.startLine = e3.linePos = e3.line;
          e3.token = s[e3.currentChar] & 8192 ? scanJSXString(e3, t3) : scanSingleToken(e3, t3, 0);
          return e3.token;
        }
        function scanJSXString(e3, t3) {
          const r3 = e3.currentChar;
          let n2 = advanceChar(e3);
          const s2 = e3.index;
          while (n2 !== r3) {
            if (e3.index >= e3.end)
              report(e3, 14);
            n2 = advanceChar(e3);
          }
          if (n2 !== r3)
            report(e3, 14);
          e3.tokenValue = e3.source.slice(s2, e3.index);
          advanceChar(e3);
          if (t3 & 512)
            e3.tokenRaw = e3.source.slice(e3.tokenPos, e3.index);
          return 134283267;
        }
        function scanJSXToken(e3, t3) {
          e3.startPos = e3.tokenPos = e3.index;
          e3.startColumn = e3.colPos = e3.column;
          e3.startLine = e3.linePos = e3.line;
          if (e3.index >= e3.end)
            return e3.token = 1048576;
          const r3 = p[e3.source.charCodeAt(e3.index)];
          switch (r3) {
            case 8456258: {
              advanceChar(e3);
              if (e3.currentChar === 47) {
                advanceChar(e3);
                e3.token = 25;
              } else {
                e3.token = 8456258;
              }
              break;
            }
            case 2162700: {
              advanceChar(e3);
              e3.token = 2162700;
              break;
            }
            default: {
              let r4 = 0;
              while (e3.index < e3.end) {
                const t4 = s[e3.source.charCodeAt(e3.index)];
                if (t4 & 1024) {
                  r4 |= 1 | 4;
                  scanNewLine(e3);
                } else if (t4 & 2048) {
                  consumeLineFeed(e3, r4);
                  r4 = r4 & ~4 | 1;
                } else {
                  advanceChar(e3);
                }
                if (s[e3.currentChar] & 16384)
                  break;
              }
              const n2 = e3.source.slice(e3.tokenPos, e3.index);
              if (t3 & 512)
                e3.tokenRaw = n2;
              e3.tokenValue = decodeHTMLStrict(n2);
              e3.token = 138;
            }
          }
          return e3.token;
        }
        function scanJSXIdentifier(e3) {
          if ((e3.token & 143360) === 143360) {
            const { index: t3 } = e3;
            let r3 = e3.currentChar;
            while (s[r3] & (32768 | 2)) {
              r3 = advanceChar(e3);
            }
            e3.tokenValue += e3.source.slice(t3, e3.index);
          }
          e3.token = 208897;
          return e3.token;
        }
        function matchOrInsertSemicolon(e3, t3, r3) {
          if ((e3.flags & 1) === 0 && (e3.token & 1048576) !== 1048576 && !r3) {
            report(e3, 28, l[e3.token & 255]);
          }
          consumeOpt(e3, t3, 1074790417);
        }
        function isValidStrictMode(e3, t3, r3, n2) {
          if (t3 - r3 < 13 && n2 === "use strict") {
            if ((e3.token & 1048576) === 1048576 || e3.flags & 1) {
              return 1;
            }
          }
          return 0;
        }
        function optionalBit(e3, t3, r3) {
          if (e3.token !== r3)
            return 0;
          nextToken(e3, t3);
          return 1;
        }
        function consumeOpt(e3, t3, r3) {
          if (e3.token !== r3)
            return false;
          nextToken(e3, t3);
          return true;
        }
        function consume(e3, t3, r3) {
          if (e3.token !== r3)
            report(e3, 23, l[r3 & 255]);
          nextToken(e3, t3);
        }
        function reinterpretToPattern(e3, t3) {
          switch (t3.type) {
            case "ArrayExpression":
              t3.type = "ArrayPattern";
              const r3 = t3.elements;
              for (let t4 = 0, n3 = r3.length; t4 < n3; ++t4) {
                const n4 = r3[t4];
                if (n4)
                  reinterpretToPattern(e3, n4);
              }
              return;
            case "ObjectExpression":
              t3.type = "ObjectPattern";
              const n2 = t3.properties;
              for (let t4 = 0, r4 = n2.length; t4 < r4; ++t4) {
                reinterpretToPattern(e3, n2[t4]);
              }
              return;
            case "AssignmentExpression":
              t3.type = "AssignmentPattern";
              if (t3.operator !== "=")
                report(e3, 68);
              delete t3.operator;
              reinterpretToPattern(e3, t3.left);
              return;
            case "Property":
              reinterpretToPattern(e3, t3.value);
              return;
            case "SpreadElement":
              t3.type = "RestElement";
              reinterpretToPattern(e3, t3.argument);
          }
        }
        function validateBindingIdentifier(e3, t3, r3, n2, s2) {
          if (t3 & 1024) {
            if ((n2 & 36864) === 36864) {
              report(e3, 114);
            }
            if (!s2 && (n2 & 537079808) === 537079808) {
              report(e3, 115);
            }
          }
          if ((n2 & 20480) === 20480) {
            report(e3, 99);
          }
          if (r3 & (8 | 16) && n2 === 241739) {
            report(e3, 97);
          }
          if (t3 & (4194304 | 2048) && n2 === 209008) {
            report(e3, 95);
          }
          if (t3 & (2097152 | 1024) && n2 === 241773) {
            report(e3, 94, "yield");
          }
        }
        function validateFunctionName(e3, t3, r3) {
          if (t3 & 1024) {
            if ((r3 & 36864) === 36864) {
              report(e3, 114);
            }
            if ((r3 & 537079808) === 537079808) {
              report(e3, 115);
            }
            if (r3 === 122) {
              report(e3, 92);
            }
            if (r3 === 121) {
              report(e3, 92);
            }
          }
          if ((r3 & 20480) === 20480) {
            report(e3, 99);
          }
          if (t3 & (4194304 | 2048) && r3 === 209008) {
            report(e3, 95);
          }
          if (t3 & (2097152 | 1024) && r3 === 241773) {
            report(e3, 94, "yield");
          }
        }
        function isStrictReservedWord(e3, t3, r3) {
          if (r3 === 209008) {
            if (t3 & (4194304 | 2048))
              report(e3, 95);
            e3.destructible |= 128;
          }
          if (r3 === 241773 && t3 & 2097152)
            report(e3, 94, "yield");
          return (r3 & 20480) === 20480 || (r3 & 36864) === 36864 || r3 == 122;
        }
        function isPropertyWithPrivateFieldKey(e3) {
          return !e3.property ? false : e3.property.type === "PrivateIdentifier";
        }
        function isValidLabel(e3, t3, r3, n2) {
          while (t3) {
            if (t3["$" + r3]) {
              if (n2)
                report(e3, 133);
              return 1;
            }
            if (n2 && t3.loop)
              n2 = 0;
            t3 = t3["$"];
          }
          return 0;
        }
        function validateAndDeclareLabel(e3, t3, r3) {
          let n2 = t3;
          while (n2) {
            if (n2["$" + r3])
              report(e3, 132, r3);
            n2 = n2["$"];
          }
          t3["$" + r3] = 1;
        }
        function finishNode(e3, t3, r3, n2, s2, i2) {
          if (t3 & 2) {
            i2.start = r3;
            i2.end = e3.startPos;
            i2.range = [r3, e3.startPos];
          }
          if (t3 & 4) {
            i2.loc = { start: { line: n2, column: s2 }, end: { line: e3.startLine, column: e3.startColumn } };
            if (e3.sourceFile) {
              i2.loc.source = e3.sourceFile;
            }
          }
          return i2;
        }
        function isEqualTagName(e3) {
          switch (e3.type) {
            case "JSXIdentifier":
              return e3.name;
            case "JSXNamespacedName":
              return e3.namespace + ":" + e3.name;
            case "JSXMemberExpression":
              return isEqualTagName(e3.object) + "." + isEqualTagName(e3.property);
          }
        }
        function createArrowHeadParsingScope(e3, t3, r3) {
          const n2 = addChildScope(createScope(), 1024);
          addBlockName(e3, t3, n2, r3, 1, 0);
          return n2;
        }
        function recordScopeError(e3, t3, ...r3) {
          const { index: n2, line: s2, column: i2 } = e3;
          return { type: t3, params: r3, index: n2, line: s2, column: i2 };
        }
        function createScope() {
          return { parent: void 0, type: 2 };
        }
        function addChildScope(e3, t3) {
          return { parent: e3, type: t3, scopeError: void 0 };
        }
        function addVarOrBlock(e3, t3, r3, n2, s2, i2) {
          if (s2 & 4) {
            addVarName(e3, t3, r3, n2, s2);
          } else {
            addBlockName(e3, t3, r3, n2, s2, i2);
          }
          if (i2 & 64) {
            declareUnboundVariable(e3, n2);
          }
        }
        function addBlockName(e3, t3, r3, n2, s2, i2) {
          const o2 = r3["#" + n2];
          if (o2 && (o2 & 2) === 0) {
            if (s2 & 1) {
              r3.scopeError = recordScopeError(e3, 140, n2);
            } else if (t3 & 256 && o2 & 64 && i2 & 2)
              ;
            else {
              report(e3, 140, n2);
            }
          }
          if (r3.type & 128 && (r3.parent["#" + n2] && (r3.parent["#" + n2] & 2) === 0)) {
            report(e3, 140, n2);
          }
          if (r3.type & 1024 && o2 && (o2 & 2) === 0) {
            if (s2 & 1) {
              r3.scopeError = recordScopeError(e3, 140, n2);
            }
          }
          if (r3.type & 64) {
            if (r3.parent["#" + n2] & 768)
              report(e3, 153, n2);
          }
          r3["#" + n2] = s2;
        }
        function addVarName(e3, t3, r3, n2, s2) {
          let i2 = r3;
          while (i2 && (i2.type & 256) === 0) {
            const o2 = i2["#" + n2];
            if (o2 & 248) {
              if (t3 & 256 && (t3 & 1024) === 0 && (s2 & 128 && o2 & 68 || o2 & 128 && s2 & 68))
                ;
              else {
                report(e3, 140, n2);
              }
            }
            if (i2 === r3) {
              if (o2 & 1 && s2 & 1) {
                i2.scopeError = recordScopeError(e3, 140, n2);
              }
            }
            if (o2 & (512 | 256)) {
              if ((o2 & 512) === 0 || (t3 & 256) === 0 || t3 & 1024) {
                report(e3, 140, n2);
              }
            }
            i2["#" + n2] = s2;
            i2 = i2.parent;
          }
        }
        function declareUnboundVariable(e3, t3) {
          if (e3.exportedNames !== void 0 && t3 !== "") {
            if (e3.exportedNames["#" + t3]) {
              report(e3, 141, t3);
            }
            e3.exportedNames["#" + t3] = 1;
          }
        }
        function addBindingToExports(e3, t3) {
          if (e3.exportedBindings !== void 0 && t3 !== "") {
            e3.exportedBindings["#" + t3] = 1;
          }
        }
        function pushComment(e3, t3) {
          return function(r3, n2, s2, i2, o2) {
            const a2 = { type: r3, value: n2 };
            if (e3 & 2) {
              a2.start = s2;
              a2.end = i2;
              a2.range = [s2, i2];
            }
            if (e3 & 4) {
              a2.loc = o2;
            }
            t3.push(a2);
          };
        }
        function pushToken(e3, t3) {
          return function(r3, n2, s2, i2) {
            const o2 = { token: r3 };
            if (e3 & 2) {
              o2.start = n2;
              o2.end = s2;
              o2.range = [n2, s2];
            }
            if (e3 & 4) {
              o2.loc = i2;
            }
            t3.push(o2);
          };
        }
        function isValidIdentifier(e3, t3) {
          if (e3 & (1024 | 2097152)) {
            if (e3 & 2048 && t3 === 209008)
              return false;
            if (e3 & 2097152 && t3 === 241773)
              return false;
            return (t3 & 143360) === 143360 || (t3 & 12288) === 12288;
          }
          return (t3 & 143360) === 143360 || (t3 & 12288) === 12288 || (t3 & 36864) === 36864;
        }
        function classifyIdentifier(e3, t3, r3, n2) {
          if ((r3 & 537079808) === 537079808) {
            if (t3 & 1024)
              report(e3, 115);
            if (n2)
              e3.flags |= 512;
          }
          if (!isValidIdentifier(t3, r3))
            report(e3, 0);
        }
        function create2(e3, t3, r3, n2) {
          return { source: e3, flags: 0, index: 0, line: 1, column: 0, startPos: 0, end: e3.length, tokenPos: 0, startColumn: 0, colPos: 0, linePos: 1, startLine: 1, sourceFile: t3, tokenValue: "", token: 1048576, tokenRaw: "", tokenRegExp: void 0, currentChar: e3.charCodeAt(0), exportedNames: [], exportedBindings: [], assignable: 1, destructible: 0, onComment: r3, onToken: n2, leadingDecorators: [] };
        }
        function parseSource(e3, t3, r3) {
          let n2 = "";
          let s2;
          let i2;
          if (t3 != null) {
            if (t3.module)
              r3 |= 2048 | 1024;
            if (t3.next)
              r3 |= 1;
            if (t3.loc)
              r3 |= 4;
            if (t3.ranges)
              r3 |= 2;
            if (t3.uniqueKeyInPattern)
              r3 |= -2147483648;
            if (t3.lexical)
              r3 |= 64;
            if (t3.webcompat)
              r3 |= 256;
            if (t3.directives)
              r3 |= 8 | 512;
            if (t3.globalReturn)
              r3 |= 32;
            if (t3.raw)
              r3 |= 512;
            if (t3.preserveParens)
              r3 |= 128;
            if (t3.impliedStrict)
              r3 |= 1024;
            if (t3.jsx)
              r3 |= 16;
            if (t3.identifierPattern)
              r3 |= 268435456;
            if (t3.specDeviation)
              r3 |= 536870912;
            if (t3.source)
              n2 = t3.source;
            if (t3.onComment != null) {
              s2 = Array.isArray(t3.onComment) ? pushComment(r3, t3.onComment) : t3.onComment;
            }
            if (t3.onToken != null) {
              i2 = Array.isArray(t3.onToken) ? pushToken(r3, t3.onToken) : t3.onToken;
            }
          }
          const o2 = create2(e3, n2, s2, i2);
          if (r3 & 1)
            skipHashBang(o2);
          const a2 = r3 & 64 ? createScope() : void 0;
          let l2 = [];
          let c2 = "script";
          if (r3 & 2048) {
            c2 = "module";
            l2 = parseModuleItemList(o2, r3 | 8192, a2);
            if (a2) {
              for (const e4 in o2.exportedBindings) {
                if (e4[0] === "#" && !a2[e4])
                  report(o2, 142, e4.slice(1));
              }
            }
          } else {
            l2 = parseStatementList(o2, r3 | 8192, a2);
          }
          const p2 = { type: "Program", sourceType: c2, body: l2 };
          if (r3 & 2) {
            p2.start = 0;
            p2.end = e3.length;
            p2.range = [0, e3.length];
          }
          if (r3 & 4) {
            p2.loc = { start: { line: 1, column: 0 }, end: { line: o2.line, column: o2.column } };
            if (o2.sourceFile)
              p2.loc.source = n2;
          }
          return p2;
        }
        function parseStatementList(e3, t3, r3) {
          nextToken(e3, t3 | 32768 | 1073741824);
          const n2 = [];
          while (e3.token === 134283267) {
            const { index: r4, tokenPos: s2, tokenValue: i2, linePos: o2, colPos: a2, token: l2 } = e3;
            const c2 = parseLiteral(e3, t3);
            if (isValidStrictMode(e3, r4, s2, i2))
              t3 |= 1024;
            n2.push(parseDirective(e3, t3, c2, l2, s2, o2, a2));
          }
          while (e3.token !== 1048576) {
            n2.push(parseStatementListItem(e3, t3, r3, 4, {}));
          }
          return n2;
        }
        function parseModuleItemList(e3, t3, r3) {
          nextToken(e3, t3 | 32768);
          const n2 = [];
          if (t3 & 8) {
            while (e3.token === 134283267) {
              const { tokenPos: r4, linePos: s2, colPos: i2, token: o2 } = e3;
              n2.push(parseDirective(e3, t3, parseLiteral(e3, t3), o2, r4, s2, i2));
            }
          }
          while (e3.token !== 1048576) {
            n2.push(parseModuleItem(e3, t3, r3));
          }
          return n2;
        }
        function parseModuleItem(e3, t3, r3) {
          e3.leadingDecorators = parseDecorators(e3, t3);
          let n2;
          switch (e3.token) {
            case 20566:
              n2 = parseExportDeclaration(e3, t3, r3);
              break;
            case 86108:
              n2 = parseImportDeclaration(e3, t3, r3);
              break;
            default:
              n2 = parseStatementListItem(e3, t3, r3, 4, {});
          }
          if (e3.leadingDecorators.length) {
            report(e3, 164);
          }
          return n2;
        }
        function parseStatementListItem(e3, t3, r3, n2, s2) {
          const i2 = e3.tokenPos;
          const o2 = e3.linePos;
          const a2 = e3.colPos;
          switch (e3.token) {
            case 86106:
              return parseFunctionDeclaration(e3, t3, r3, n2, 1, 0, 0, i2, o2, a2);
            case 133:
            case 86096:
              return parseClassDeclaration(e3, t3, r3, 0, i2, o2, a2);
            case 86092:
              return parseLexicalDeclaration(e3, t3, r3, 16, 0, i2, o2, a2);
            case 241739:
              return parseLetIdentOrVarDeclarationStatement(e3, t3, r3, n2, i2, o2, a2);
            case 20566:
              report(e3, 100, "export");
            case 86108:
              nextToken(e3, t3);
              switch (e3.token) {
                case 67174411:
                  return parseImportCallDeclaration(e3, t3, i2, o2, a2);
                case 67108877:
                  return parseImportMetaDeclaration(e3, t3, i2, o2, a2);
                default:
                  report(e3, 100, "import");
              }
            case 209007:
              return parseAsyncArrowOrAsyncFunctionDeclaration(e3, t3, r3, n2, s2, 1, i2, o2, a2);
            default:
              return parseStatement(e3, t3, r3, n2, s2, 1, i2, o2, a2);
          }
        }
        function parseStatement(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          switch (e3.token) {
            case 86090:
              return parseVariableStatement(e3, t3, r3, 0, o2, a2, l2);
            case 20574:
              return parseReturnStatement(e3, t3, o2, a2, l2);
            case 20571:
              return parseIfStatement(e3, t3, r3, s2, o2, a2, l2);
            case 20569:
              return parseForStatement(e3, t3, r3, s2, o2, a2, l2);
            case 20564:
              return parseDoWhileStatement(e3, t3, r3, s2, o2, a2, l2);
            case 20580:
              return parseWhileStatement(e3, t3, r3, s2, o2, a2, l2);
            case 86112:
              return parseSwitchStatement(e3, t3, r3, s2, o2, a2, l2);
            case 1074790417:
              return parseEmptyStatement(e3, t3, o2, a2, l2);
            case 2162700:
              return parseBlock(e3, t3, r3 ? addChildScope(r3, 2) : r3, s2, o2, a2, l2);
            case 86114:
              return parseThrowStatement(e3, t3, o2, a2, l2);
            case 20557:
              return parseBreakStatement(e3, t3, s2, o2, a2, l2);
            case 20561:
              return parseContinueStatement(e3, t3, s2, o2, a2, l2);
            case 20579:
              return parseTryStatement(e3, t3, r3, s2, o2, a2, l2);
            case 20581:
              return parseWithStatement(e3, t3, r3, s2, o2, a2, l2);
            case 20562:
              return parseDebuggerStatement(e3, t3, o2, a2, l2);
            case 209007:
              return parseAsyncArrowOrAsyncFunctionDeclaration(e3, t3, r3, n2, s2, 0, o2, a2, l2);
            case 20559:
              report(e3, 156);
            case 20568:
              report(e3, 157);
            case 86106:
              report(e3, t3 & 1024 ? 73 : (t3 & 256) < 1 ? 75 : 74);
            case 86096:
              report(e3, 76);
            default:
              return parseExpressionOrLabelledStatement(e3, t3, r3, n2, s2, i2, o2, a2, l2);
          }
        }
        function parseExpressionOrLabelledStatement(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          const { tokenValue: c2, token: p2 } = e3;
          let u2;
          switch (p2) {
            case 241739:
              u2 = parseIdentifier(e3, t3, 0);
              if (t3 & 1024)
                report(e3, 82);
              if (e3.token === 69271571)
                report(e3, 81);
              break;
            default:
              u2 = parsePrimaryExpression(e3, t3, 2, 0, 1, 0, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          }
          if (p2 & 143360 && e3.token === 21) {
            return parseLabelledStatement(e3, t3, r3, n2, s2, c2, u2, p2, i2, o2, a2, l2);
          }
          u2 = parseMemberOrUpdateExpression(e3, t3, u2, 0, 0, o2, a2, l2);
          u2 = parseAssignmentExpression(e3, t3, 0, 0, o2, a2, l2, u2);
          if (e3.token === 18) {
            u2 = parseSequenceExpression(e3, t3, 0, o2, a2, l2, u2);
          }
          return parseExpressionStatement(e3, t3, u2, o2, a2, l2);
        }
        function parseBlock(e3, t3, r3, n2, s2, i2, o2) {
          const a2 = [];
          consume(e3, t3 | 32768, 2162700);
          while (e3.token !== 1074790415) {
            a2.push(parseStatementListItem(e3, t3, r3, 2, { $: n2 }));
          }
          consume(e3, t3 | 32768, 1074790415);
          return finishNode(e3, t3, s2, i2, o2, { type: "BlockStatement", body: a2 });
        }
        function parseReturnStatement(e3, t3, r3, n2, s2) {
          if ((t3 & 32) < 1 && t3 & 8192)
            report(e3, 89);
          nextToken(e3, t3 | 32768);
          const i2 = e3.flags & 1 || e3.token & 1048576 ? null : parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, r3, n2, s2, { type: "ReturnStatement", argument: i2 });
        }
        function parseExpressionStatement(e3, t3, r3, n2, s2, i2) {
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, n2, s2, i2, { type: "ExpressionStatement", expression: r3 });
        }
        function parseLabelledStatement(e3, t3, r3, n2, s2, i2, o2, a2, l2, c2, p2, u2) {
          validateBindingIdentifier(e3, t3, 0, a2, 1);
          validateAndDeclareLabel(e3, s2, i2);
          nextToken(e3, t3 | 32768);
          const f2 = l2 && (t3 & 1024) < 1 && t3 & 256 && e3.token === 86106 ? parseFunctionDeclaration(e3, t3, addChildScope(r3, 2), n2, 0, 0, 0, e3.tokenPos, e3.linePos, e3.colPos) : parseStatement(e3, t3, r3, n2, s2, l2, e3.tokenPos, e3.linePos, e3.colPos);
          return finishNode(e3, t3, c2, p2, u2, { type: "LabeledStatement", label: o2, body: f2 });
        }
        function parseAsyncArrowOrAsyncFunctionDeclaration(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          const { token: c2, tokenValue: p2 } = e3;
          let u2 = parseIdentifier(e3, t3, 0);
          if (e3.token === 21) {
            return parseLabelledStatement(e3, t3, r3, n2, s2, p2, u2, c2, 1, o2, a2, l2);
          }
          const f2 = e3.flags & 1;
          if (!f2) {
            if (e3.token === 86106) {
              if (!i2)
                report(e3, 119);
              return parseFunctionDeclaration(e3, t3, r3, n2, 1, 0, 1, o2, a2, l2);
            }
            if ((e3.token & 143360) === 143360) {
              u2 = parseAsyncArrowAfterIdent(e3, t3, 1, o2, a2, l2);
              if (e3.token === 18)
                u2 = parseSequenceExpression(e3, t3, 0, o2, a2, l2, u2);
              return parseExpressionStatement(e3, t3, u2, o2, a2, l2);
            }
          }
          if (e3.token === 67174411) {
            u2 = parseAsyncArrowOrCallExpression(e3, t3, u2, 1, 1, 0, f2, o2, a2, l2);
          } else {
            if (e3.token === 10) {
              classifyIdentifier(e3, t3, c2, 1);
              u2 = parseArrowFromIdentifier(e3, t3, e3.tokenValue, u2, 0, 1, 0, o2, a2, l2);
            }
            e3.assignable = 1;
          }
          u2 = parseMemberOrUpdateExpression(e3, t3, u2, 0, 0, o2, a2, l2);
          if (e3.token === 18)
            u2 = parseSequenceExpression(e3, t3, 0, o2, a2, l2, u2);
          u2 = parseAssignmentExpression(e3, t3, 0, 0, o2, a2, l2, u2);
          e3.assignable = 1;
          return parseExpressionStatement(e3, t3, u2, o2, a2, l2);
        }
        function parseDirective(e3, t3, r3, n2, s2, i2, o2) {
          if (n2 !== 1074790417) {
            e3.assignable = 2;
            r3 = parseMemberOrUpdateExpression(e3, t3, r3, 0, 0, s2, i2, o2);
            if (e3.token !== 1074790417) {
              r3 = parseAssignmentExpression(e3, t3, 0, 0, s2, i2, o2, r3);
              if (e3.token === 18) {
                r3 = parseSequenceExpression(e3, t3, 0, s2, i2, o2, r3);
              }
            }
            matchOrInsertSemicolon(e3, t3 | 32768);
          }
          return t3 & 8 && r3.type === "Literal" && typeof r3.value === "string" ? finishNode(e3, t3, s2, i2, o2, { type: "ExpressionStatement", expression: r3, directive: r3.raw.slice(1, -1) }) : finishNode(e3, t3, s2, i2, o2, { type: "ExpressionStatement", expression: r3 });
        }
        function parseEmptyStatement(e3, t3, r3, n2, s2) {
          nextToken(e3, t3 | 32768);
          return finishNode(e3, t3, r3, n2, s2, { type: "EmptyStatement" });
        }
        function parseThrowStatement(e3, t3, r3, n2, s2) {
          nextToken(e3, t3 | 32768);
          if (e3.flags & 1)
            report(e3, 87);
          const i2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, r3, n2, s2, { type: "ThrowStatement", argument: i2 });
        }
        function parseIfStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3);
          consume(e3, t3 | 32768, 67174411);
          e3.assignable = 1;
          const a2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.line, e3.colPos);
          consume(e3, t3 | 32768, 16);
          const l2 = parseConsequentOrAlternative(e3, t3, r3, n2, e3.tokenPos, e3.linePos, e3.colPos);
          let c2 = null;
          if (e3.token === 20565) {
            nextToken(e3, t3 | 32768);
            c2 = parseConsequentOrAlternative(e3, t3, r3, n2, e3.tokenPos, e3.linePos, e3.colPos);
          }
          return finishNode(e3, t3, s2, i2, o2, { type: "IfStatement", test: a2, consequent: l2, alternate: c2 });
        }
        function parseConsequentOrAlternative(e3, t3, r3, n2, s2, i2, o2) {
          return t3 & 1024 || (t3 & 256) < 1 || e3.token !== 86106 ? parseStatement(e3, t3, r3, 0, { $: n2 }, 0, e3.tokenPos, e3.linePos, e3.colPos) : parseFunctionDeclaration(e3, t3, addChildScope(r3, 2), 0, 0, 0, 0, s2, i2, o2);
        }
        function parseSwitchStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3);
          consume(e3, t3 | 32768, 67174411);
          const a2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3, 16);
          consume(e3, t3, 2162700);
          const l2 = [];
          let c2 = 0;
          if (r3)
            r3 = addChildScope(r3, 8);
          while (e3.token !== 1074790415) {
            const { tokenPos: s3, linePos: i3, colPos: o3 } = e3;
            let a3 = null;
            const p2 = [];
            if (consumeOpt(e3, t3 | 32768, 20558)) {
              a3 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
            } else {
              consume(e3, t3 | 32768, 20563);
              if (c2)
                report(e3, 86);
              c2 = 1;
            }
            consume(e3, t3 | 32768, 21);
            while (e3.token !== 20558 && e3.token !== 1074790415 && e3.token !== 20563) {
              p2.push(parseStatementListItem(e3, t3 | 4096, r3, 2, { $: n2 }));
            }
            l2.push(finishNode(e3, t3, s3, i3, o3, { type: "SwitchCase", test: a3, consequent: p2 }));
          }
          consume(e3, t3 | 32768, 1074790415);
          return finishNode(e3, t3, s2, i2, o2, { type: "SwitchStatement", discriminant: a2, cases: l2 });
        }
        function parseWhileStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3);
          consume(e3, t3 | 32768, 67174411);
          const a2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3 | 32768, 16);
          const l2 = parseIterationStatementBody(e3, t3, r3, n2);
          return finishNode(e3, t3, s2, i2, o2, { type: "WhileStatement", test: a2, body: l2 });
        }
        function parseIterationStatementBody(e3, t3, r3, n2) {
          return parseStatement(e3, (t3 | 134217728) ^ 134217728 | 131072, r3, 0, { loop: 1, $: n2 }, 0, e3.tokenPos, e3.linePos, e3.colPos);
        }
        function parseContinueStatement(e3, t3, r3, n2, s2, i2) {
          if ((t3 & 131072) < 1)
            report(e3, 65);
          nextToken(e3, t3);
          let o2 = null;
          if ((e3.flags & 1) < 1 && e3.token & 143360) {
            const { tokenValue: n3 } = e3;
            o2 = parseIdentifier(e3, t3 | 32768, 0);
            if (!isValidLabel(e3, r3, n3, 1))
              report(e3, 134, n3);
          }
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, n2, s2, i2, { type: "ContinueStatement", label: o2 });
        }
        function parseBreakStatement(e3, t3, r3, n2, s2, i2) {
          nextToken(e3, t3 | 32768);
          let o2 = null;
          if ((e3.flags & 1) < 1 && e3.token & 143360) {
            const { tokenValue: n3 } = e3;
            o2 = parseIdentifier(e3, t3 | 32768, 0);
            if (!isValidLabel(e3, r3, n3, 0))
              report(e3, 134, n3);
          } else if ((t3 & (4096 | 131072)) < 1) {
            report(e3, 66);
          }
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, n2, s2, i2, { type: "BreakStatement", label: o2 });
        }
        function parseWithStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3);
          if (t3 & 1024)
            report(e3, 88);
          consume(e3, t3 | 32768, 67174411);
          const a2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3 | 32768, 16);
          const l2 = parseStatement(e3, t3, r3, 2, n2, 0, e3.tokenPos, e3.linePos, e3.colPos);
          return finishNode(e3, t3, s2, i2, o2, { type: "WithStatement", object: a2, body: l2 });
        }
        function parseDebuggerStatement(e3, t3, r3, n2, s2) {
          nextToken(e3, t3 | 32768);
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, r3, n2, s2, { type: "DebuggerStatement" });
        }
        function parseTryStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3 | 32768);
          const a2 = r3 ? addChildScope(r3, 32) : void 0;
          const l2 = parseBlock(e3, t3, a2, { $: n2 }, e3.tokenPos, e3.linePos, e3.colPos);
          const { tokenPos: c2, linePos: p2, colPos: u2 } = e3;
          const f2 = consumeOpt(e3, t3 | 32768, 20559) ? parseCatchBlock(e3, t3, r3, n2, c2, p2, u2) : null;
          let d2 = null;
          if (e3.token === 20568) {
            nextToken(e3, t3 | 32768);
            const s3 = a2 ? addChildScope(r3, 4) : void 0;
            d2 = parseBlock(e3, t3, s3, { $: n2 }, e3.tokenPos, e3.linePos, e3.colPos);
          }
          if (!f2 && !d2) {
            report(e3, 85);
          }
          return finishNode(e3, t3, s2, i2, o2, { type: "TryStatement", block: l2, handler: f2, finalizer: d2 });
        }
        function parseCatchBlock(e3, t3, r3, n2, s2, i2, o2) {
          let a2 = null;
          let l2 = r3;
          if (consumeOpt(e3, t3, 67174411)) {
            if (r3)
              r3 = addChildScope(r3, 4);
            a2 = parseBindingPattern(e3, t3, r3, (e3.token & 2097152) === 2097152 ? 256 : 512, 0, e3.tokenPos, e3.linePos, e3.colPos);
            if (e3.token === 18) {
              report(e3, 83);
            } else if (e3.token === 1077936157) {
              report(e3, 84);
            }
            consume(e3, t3 | 32768, 16);
            if (r3)
              l2 = addChildScope(r3, 64);
          }
          const c2 = parseBlock(e3, t3, l2, { $: n2 }, e3.tokenPos, e3.linePos, e3.colPos);
          return finishNode(e3, t3, s2, i2, o2, { type: "CatchClause", param: a2, body: c2 });
        }
        function parseDoWhileStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3 | 32768);
          const a2 = parseIterationStatementBody(e3, t3, r3, n2);
          consume(e3, t3, 20580);
          consume(e3, t3 | 32768, 67174411);
          const l2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3 | 32768, 16);
          consumeOpt(e3, t3, 1074790417);
          return finishNode(e3, t3, s2, i2, o2, { type: "DoWhileStatement", body: a2, test: l2 });
        }
        function parseLetIdentOrVarDeclarationStatement(e3, t3, r3, n2, s2, i2, o2) {
          const { token: a2, tokenValue: l2 } = e3;
          let c2 = parseIdentifier(e3, t3, 0);
          if (e3.token & (143360 | 2097152)) {
            const n3 = parseVariableDeclarationList(e3, t3, r3, 8, 0);
            matchOrInsertSemicolon(e3, t3 | 32768);
            return finishNode(e3, t3, s2, i2, o2, { type: "VariableDeclaration", kind: "let", declarations: n3 });
          }
          e3.assignable = 1;
          if (t3 & 1024)
            report(e3, 82);
          if (e3.token === 21) {
            return parseLabelledStatement(e3, t3, r3, n2, {}, l2, c2, a2, 0, s2, i2, o2);
          }
          if (e3.token === 10) {
            let r4 = void 0;
            if (t3 & 64)
              r4 = createArrowHeadParsingScope(e3, t3, l2);
            e3.flags = (e3.flags | 128) ^ 128;
            c2 = parseArrowFunctionExpression(e3, t3, r4, [c2], 0, s2, i2, o2);
          } else {
            c2 = parseMemberOrUpdateExpression(e3, t3, c2, 0, 0, s2, i2, o2);
            c2 = parseAssignmentExpression(e3, t3, 0, 0, s2, i2, o2, c2);
          }
          if (e3.token === 18) {
            c2 = parseSequenceExpression(e3, t3, 0, s2, i2, o2, c2);
          }
          return parseExpressionStatement(e3, t3, c2, s2, i2, o2);
        }
        function parseLexicalDeclaration(e3, t3, r3, n2, s2, i2, o2, a2) {
          nextToken(e3, t3);
          const l2 = parseVariableDeclarationList(e3, t3, r3, n2, s2);
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, i2, o2, a2, { type: "VariableDeclaration", kind: n2 & 8 ? "let" : "const", declarations: l2 });
        }
        function parseVariableStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3);
          const a2 = parseVariableDeclarationList(e3, t3, r3, 4, n2);
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, s2, i2, o2, { type: "VariableDeclaration", kind: "var", declarations: a2 });
        }
        function parseVariableDeclarationList(e3, t3, r3, n2, s2) {
          let i2 = 1;
          const o2 = [parseVariableDeclaration(e3, t3, r3, n2, s2)];
          while (consumeOpt(e3, t3, 18)) {
            i2++;
            o2.push(parseVariableDeclaration(e3, t3, r3, n2, s2));
          }
          if (i2 > 1 && s2 & 32 && e3.token & 262144) {
            report(e3, 58, l[e3.token & 255]);
          }
          return o2;
        }
        function parseVariableDeclaration(e3, t3, r3, n2, s2) {
          const { token: i2, tokenPos: o2, linePos: a2, colPos: l2 } = e3;
          let c2 = null;
          const p2 = parseBindingPattern(e3, t3, r3, n2, s2, o2, a2, l2);
          if (e3.token === 1077936157) {
            nextToken(e3, t3 | 32768);
            c2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
            if (s2 & 32 || (i2 & 2097152) < 1) {
              if (e3.token === 274549 || e3.token === 8738868 && (i2 & 2097152 || (n2 & 4) < 1 || t3 & 1024)) {
                reportMessageAt(o2, e3.line, e3.index - 3, 57, e3.token === 274549 ? "of" : "in");
              }
            }
          } else if ((n2 & 16 || (i2 & 2097152) > 0) && (e3.token & 262144) !== 262144) {
            report(e3, 56, n2 & 16 ? "const" : "destructuring");
          }
          return finishNode(e3, t3, o2, a2, l2, { type: "VariableDeclarator", id: p2, init: c2 });
        }
        function parseForStatement(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3);
          const a2 = (t3 & 4194304) > 0 && consumeOpt(e3, t3, 209008);
          consume(e3, t3 | 32768, 67174411);
          if (r3)
            r3 = addChildScope(r3, 1);
          let l2 = null;
          let c2 = null;
          let p2 = 0;
          let u2 = null;
          let f2 = e3.token === 86090 || e3.token === 241739 || e3.token === 86092;
          let d2;
          const { token: h2, tokenPos: m2, linePos: g, colPos: k } = e3;
          if (f2) {
            if (h2 === 241739) {
              u2 = parseIdentifier(e3, t3, 0);
              if (e3.token & (143360 | 2097152)) {
                if (e3.token === 8738868) {
                  if (t3 & 1024)
                    report(e3, 64);
                } else {
                  u2 = finishNode(e3, t3, m2, g, k, { type: "VariableDeclaration", kind: "let", declarations: parseVariableDeclarationList(e3, t3 | 134217728, r3, 8, 32) });
                }
                e3.assignable = 1;
              } else if (t3 & 1024) {
                report(e3, 64);
              } else {
                f2 = false;
                e3.assignable = 1;
                u2 = parseMemberOrUpdateExpression(e3, t3, u2, 0, 0, m2, g, k);
                if (e3.token === 274549)
                  report(e3, 111);
              }
            } else {
              nextToken(e3, t3);
              u2 = finishNode(e3, t3, m2, g, k, h2 === 86090 ? { type: "VariableDeclaration", kind: "var", declarations: parseVariableDeclarationList(e3, t3 | 134217728, r3, 4, 32) } : { type: "VariableDeclaration", kind: "const", declarations: parseVariableDeclarationList(e3, t3 | 134217728, r3, 16, 32) });
              e3.assignable = 1;
            }
          } else if (h2 === 1074790417) {
            if (a2)
              report(e3, 79);
          } else if ((h2 & 2097152) === 2097152) {
            u2 = h2 === 2162700 ? parseObjectLiteralOrPattern(e3, t3, void 0, 1, 0, 0, 2, 32, m2, g, k) : parseArrayExpressionOrPattern(e3, t3, void 0, 1, 0, 0, 2, 32, m2, g, k);
            p2 = e3.destructible;
            if (t3 & 256 && p2 & 64) {
              report(e3, 60);
            }
            e3.assignable = p2 & 16 ? 2 : 1;
            u2 = parseMemberOrUpdateExpression(e3, t3 | 134217728, u2, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          } else {
            u2 = parseLeftHandSideExpression(e3, t3 | 134217728, 1, 0, 1, m2, g, k);
          }
          if ((e3.token & 262144) === 262144) {
            if (e3.token === 274549) {
              if (e3.assignable & 2)
                report(e3, 77, a2 ? "await" : "of");
              reinterpretToPattern(e3, u2);
              nextToken(e3, t3 | 32768);
              d2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
              consume(e3, t3 | 32768, 16);
              const l4 = parseIterationStatementBody(e3, t3, r3, n2);
              return finishNode(e3, t3, s2, i2, o2, { type: "ForOfStatement", left: u2, right: d2, body: l4, await: a2 });
            }
            if (e3.assignable & 2)
              report(e3, 77, "in");
            reinterpretToPattern(e3, u2);
            nextToken(e3, t3 | 32768);
            if (a2)
              report(e3, 79);
            d2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
            consume(e3, t3 | 32768, 16);
            const l3 = parseIterationStatementBody(e3, t3, r3, n2);
            return finishNode(e3, t3, s2, i2, o2, { type: "ForInStatement", body: l3, left: u2, right: d2 });
          }
          if (a2)
            report(e3, 79);
          if (!f2) {
            if (p2 & 8 && e3.token !== 1077936157) {
              report(e3, 77, "loop");
            }
            u2 = parseAssignmentExpression(e3, t3 | 134217728, 0, 0, m2, g, k, u2);
          }
          if (e3.token === 18)
            u2 = parseSequenceExpression(e3, t3, 0, e3.tokenPos, e3.linePos, e3.colPos, u2);
          consume(e3, t3 | 32768, 1074790417);
          if (e3.token !== 1074790417)
            l2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3 | 32768, 1074790417);
          if (e3.token !== 16)
            c2 = parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3 | 32768, 16);
          const b = parseIterationStatementBody(e3, t3, r3, n2);
          return finishNode(e3, t3, s2, i2, o2, { type: "ForStatement", init: u2, test: l2, update: c2, body: b });
        }
        function parseRestrictedIdentifier(e3, t3, r3) {
          if (!isValidIdentifier(t3, e3.token))
            report(e3, 114);
          if ((e3.token & 537079808) === 537079808)
            report(e3, 115);
          if (r3)
            addBlockName(e3, t3, r3, e3.tokenValue, 8, 0);
          return parseIdentifier(e3, t3, 0);
        }
        function parseImportDeclaration(e3, t3, r3) {
          const n2 = e3.tokenPos;
          const s2 = e3.linePos;
          const i2 = e3.colPos;
          nextToken(e3, t3);
          let o2 = null;
          const { tokenPos: a2, linePos: c2, colPos: p2 } = e3;
          let u2 = [];
          if (e3.token === 134283267) {
            o2 = parseLiteral(e3, t3);
          } else {
            if (e3.token & 143360) {
              const n3 = parseRestrictedIdentifier(e3, t3, r3);
              u2 = [finishNode(e3, t3, a2, c2, p2, { type: "ImportDefaultSpecifier", local: n3 })];
              if (consumeOpt(e3, t3, 18)) {
                switch (e3.token) {
                  case 8457014:
                    u2.push(parseImportNamespaceSpecifier(e3, t3, r3));
                    break;
                  case 2162700:
                    parseImportSpecifierOrNamedImports(e3, t3, r3, u2);
                    break;
                  default:
                    report(e3, 104);
                }
              }
            } else {
              switch (e3.token) {
                case 8457014:
                  u2 = [parseImportNamespaceSpecifier(e3, t3, r3)];
                  break;
                case 2162700:
                  parseImportSpecifierOrNamedImports(e3, t3, r3, u2);
                  break;
                case 67174411:
                  return parseImportCallDeclaration(e3, t3, n2, s2, i2);
                case 67108877:
                  return parseImportMetaDeclaration(e3, t3, n2, s2, i2);
                default:
                  report(e3, 28, l[e3.token & 255]);
              }
            }
            o2 = parseModuleSpecifier(e3, t3);
          }
          matchOrInsertSemicolon(e3, t3 | 32768);
          return finishNode(e3, t3, n2, s2, i2, { type: "ImportDeclaration", specifiers: u2, source: o2 });
        }
        function parseImportNamespaceSpecifier(e3, t3, r3) {
          const { tokenPos: n2, linePos: s2, colPos: i2 } = e3;
          nextToken(e3, t3);
          consume(e3, t3, 77934);
          if ((e3.token & 134217728) === 134217728) {
            reportMessageAt(n2, e3.line, e3.index, 28, l[e3.token & 255]);
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "ImportNamespaceSpecifier", local: parseRestrictedIdentifier(e3, t3, r3) });
        }
        function parseModuleSpecifier(e3, t3) {
          consumeOpt(e3, t3, 12404);
          if (e3.token !== 134283267)
            report(e3, 102, "Import");
          return parseLiteral(e3, t3);
        }
        function parseImportSpecifierOrNamedImports(e3, t3, r3, n2) {
          nextToken(e3, t3);
          while (e3.token & 143360) {
            let { token: s2, tokenValue: i2, tokenPos: o2, linePos: a2, colPos: l2 } = e3;
            const c2 = parseIdentifier(e3, t3, 0);
            let p2;
            if (consumeOpt(e3, t3, 77934)) {
              if ((e3.token & 134217728) === 134217728 || e3.token === 18) {
                report(e3, 103);
              } else {
                validateBindingIdentifier(e3, t3, 16, e3.token, 0);
              }
              i2 = e3.tokenValue;
              p2 = parseIdentifier(e3, t3, 0);
            } else {
              validateBindingIdentifier(e3, t3, 16, s2, 0);
              p2 = c2;
            }
            if (r3)
              addBlockName(e3, t3, r3, i2, 8, 0);
            n2.push(finishNode(e3, t3, o2, a2, l2, { type: "ImportSpecifier", local: p2, imported: c2 }));
            if (e3.token !== 1074790415)
              consume(e3, t3, 18);
          }
          consume(e3, t3, 1074790415);
          return n2;
        }
        function parseImportMetaDeclaration(e3, t3, r3, n2, s2) {
          let i2 = parseImportMetaExpression(e3, t3, finishNode(e3, t3, r3, n2, s2, { type: "Identifier", name: "import" }), r3, n2, s2);
          i2 = parseMemberOrUpdateExpression(e3, t3, i2, 0, 0, r3, n2, s2);
          i2 = parseAssignmentExpression(e3, t3, 0, 0, r3, n2, s2, i2);
          return parseExpressionStatement(e3, t3, i2, r3, n2, s2);
        }
        function parseImportCallDeclaration(e3, t3, r3, n2, s2) {
          let i2 = parseImportExpression(e3, t3, 0, r3, n2, s2);
          i2 = parseMemberOrUpdateExpression(e3, t3, i2, 0, 0, r3, n2, s2);
          return parseExpressionStatement(e3, t3, i2, r3, n2, s2);
        }
        function parseExportDeclaration(e3, t3, r3) {
          const n2 = e3.tokenPos;
          const s2 = e3.linePos;
          const i2 = e3.colPos;
          nextToken(e3, t3 | 32768);
          const o2 = [];
          let a2 = null;
          let c2 = null;
          let p2;
          if (consumeOpt(e3, t3 | 32768, 20563)) {
            switch (e3.token) {
              case 86106: {
                a2 = parseFunctionDeclaration(e3, t3, r3, 4, 1, 1, 0, e3.tokenPos, e3.linePos, e3.colPos);
                break;
              }
              case 133:
              case 86096:
                a2 = parseClassDeclaration(e3, t3, r3, 1, e3.tokenPos, e3.linePos, e3.colPos);
                break;
              case 209007:
                const { tokenPos: n3, linePos: s3, colPos: i3 } = e3;
                a2 = parseIdentifier(e3, t3, 0);
                const { flags: o3 } = e3;
                if ((o3 & 1) < 1) {
                  if (e3.token === 86106) {
                    a2 = parseFunctionDeclaration(e3, t3, r3, 4, 1, 1, 1, n3, s3, i3);
                  } else {
                    if (e3.token === 67174411) {
                      a2 = parseAsyncArrowOrCallExpression(e3, t3, a2, 1, 1, 0, o3, n3, s3, i3);
                      a2 = parseMemberOrUpdateExpression(e3, t3, a2, 0, 0, n3, s3, i3);
                      a2 = parseAssignmentExpression(e3, t3, 0, 0, n3, s3, i3, a2);
                    } else if (e3.token & 143360) {
                      if (r3)
                        r3 = createArrowHeadParsingScope(e3, t3, e3.tokenValue);
                      a2 = parseIdentifier(e3, t3, 0);
                      a2 = parseArrowFunctionExpression(e3, t3, r3, [a2], 1, n3, s3, i3);
                    }
                  }
                }
                break;
              default:
                a2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
                matchOrInsertSemicolon(e3, t3 | 32768);
            }
            if (r3)
              declareUnboundVariable(e3, "default");
            return finishNode(e3, t3, n2, s2, i2, { type: "ExportDefaultDeclaration", declaration: a2 });
          }
          switch (e3.token) {
            case 8457014: {
              nextToken(e3, t3);
              let o3 = null;
              const a3 = consumeOpt(e3, t3, 77934);
              if (a3) {
                if (r3)
                  declareUnboundVariable(e3, e3.tokenValue);
                o3 = parseIdentifier(e3, t3, 0);
              }
              consume(e3, t3, 12404);
              if (e3.token !== 134283267)
                report(e3, 102, "Export");
              c2 = parseLiteral(e3, t3);
              matchOrInsertSemicolon(e3, t3 | 32768);
              return finishNode(e3, t3, n2, s2, i2, { type: "ExportAllDeclaration", source: c2, exported: o3 });
            }
            case 2162700: {
              nextToken(e3, t3);
              const n3 = [];
              const s3 = [];
              while (e3.token & 143360) {
                const { tokenPos: i3, tokenValue: a3, linePos: l2, colPos: c3 } = e3;
                const p3 = parseIdentifier(e3, t3, 0);
                let u3;
                if (e3.token === 77934) {
                  nextToken(e3, t3);
                  if ((e3.token & 134217728) === 134217728) {
                    report(e3, 103);
                  }
                  if (r3) {
                    n3.push(e3.tokenValue);
                    s3.push(a3);
                  }
                  u3 = parseIdentifier(e3, t3, 0);
                } else {
                  if (r3) {
                    n3.push(e3.tokenValue);
                    s3.push(e3.tokenValue);
                  }
                  u3 = p3;
                }
                o2.push(finishNode(e3, t3, i3, l2, c3, { type: "ExportSpecifier", local: p3, exported: u3 }));
                if (e3.token !== 1074790415)
                  consume(e3, t3, 18);
              }
              consume(e3, t3, 1074790415);
              if (consumeOpt(e3, t3, 12404)) {
                if (e3.token !== 134283267)
                  report(e3, 102, "Export");
                c2 = parseLiteral(e3, t3);
              } else if (r3) {
                let t4 = 0;
                let r4 = n3.length;
                for (; t4 < r4; t4++) {
                  declareUnboundVariable(e3, n3[t4]);
                }
                t4 = 0;
                r4 = s3.length;
                for (; t4 < r4; t4++) {
                  addBindingToExports(e3, s3[t4]);
                }
              }
              matchOrInsertSemicolon(e3, t3 | 32768);
              break;
            }
            case 86096:
              a2 = parseClassDeclaration(e3, t3, r3, 2, e3.tokenPos, e3.linePos, e3.colPos);
              break;
            case 86106:
              a2 = parseFunctionDeclaration(e3, t3, r3, 4, 1, 2, 0, e3.tokenPos, e3.linePos, e3.colPos);
              break;
            case 241739:
              a2 = parseLexicalDeclaration(e3, t3, r3, 8, 64, e3.tokenPos, e3.linePos, e3.colPos);
              break;
            case 86092:
              a2 = parseLexicalDeclaration(e3, t3, r3, 16, 64, e3.tokenPos, e3.linePos, e3.colPos);
              break;
            case 86090:
              a2 = parseVariableStatement(e3, t3, r3, 64, e3.tokenPos, e3.linePos, e3.colPos);
              break;
            case 209007:
              const { tokenPos: u2, linePos: f2, colPos: d2 } = e3;
              nextToken(e3, t3);
              if ((e3.flags & 1) < 1 && e3.token === 86106) {
                a2 = parseFunctionDeclaration(e3, t3, r3, 4, 1, 2, 1, u2, f2, d2);
                if (r3) {
                  p2 = a2.id ? a2.id.name : "";
                  declareUnboundVariable(e3, p2);
                }
                break;
              }
            default:
              report(e3, 28, l[e3.token & 255]);
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "ExportNamedDeclaration", declaration: a2, specifiers: o2, source: c2 });
        }
        function parseExpression(e3, t3, r3, n2, s2, i2, o2, a2) {
          let l2 = parsePrimaryExpression(e3, t3, 2, 0, r3, n2, s2, 1, i2, o2, a2);
          l2 = parseMemberOrUpdateExpression(e3, t3, l2, s2, 0, i2, o2, a2);
          return parseAssignmentExpression(e3, t3, s2, 0, i2, o2, a2, l2);
        }
        function parseSequenceExpression(e3, t3, r3, n2, s2, i2, o2) {
          const a2 = [o2];
          while (consumeOpt(e3, t3 | 32768, 18)) {
            a2.push(parseExpression(e3, t3, 1, 0, r3, e3.tokenPos, e3.linePos, e3.colPos));
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "SequenceExpression", expressions: a2 });
        }
        function parseExpressions(e3, t3, r3, n2, s2, i2, o2) {
          const a2 = parseExpression(e3, t3, n2, 0, r3, s2, i2, o2);
          return e3.token === 18 ? parseSequenceExpression(e3, t3, r3, s2, i2, o2, a2) : a2;
        }
        function parseAssignmentExpression(e3, t3, r3, n2, s2, i2, o2, a2) {
          const { token: c2 } = e3;
          if ((c2 & 4194304) === 4194304) {
            if (e3.assignable & 2)
              report(e3, 24);
            if (!n2 && c2 === 1077936157 && a2.type === "ArrayExpression" || a2.type === "ObjectExpression") {
              reinterpretToPattern(e3, a2);
            }
            nextToken(e3, t3 | 32768);
            const p2 = parseExpression(e3, t3, 1, 1, r3, e3.tokenPos, e3.linePos, e3.colPos);
            e3.assignable = 2;
            return finishNode(e3, t3, s2, i2, o2, n2 ? { type: "AssignmentPattern", left: a2, right: p2 } : { type: "AssignmentExpression", left: a2, operator: l[c2 & 255], right: p2 });
          }
          if ((c2 & 8454144) === 8454144) {
            a2 = parseBinaryExpression(e3, t3, r3, s2, i2, o2, 4, c2, a2);
          }
          if (consumeOpt(e3, t3 | 32768, 22)) {
            a2 = parseConditionalExpression(e3, t3, a2, s2, i2, o2);
          }
          return a2;
        }
        function parseAssignmentExpressionOrPattern(e3, t3, r3, n2, s2, i2, o2, a2) {
          const { token: c2 } = e3;
          nextToken(e3, t3 | 32768);
          const p2 = parseExpression(e3, t3, 1, 1, r3, e3.tokenPos, e3.linePos, e3.colPos);
          a2 = finishNode(e3, t3, s2, i2, o2, n2 ? { type: "AssignmentPattern", left: a2, right: p2 } : { type: "AssignmentExpression", left: a2, operator: l[c2 & 255], right: p2 });
          e3.assignable = 2;
          return a2;
        }
        function parseConditionalExpression(e3, t3, r3, n2, s2, i2) {
          const o2 = parseExpression(e3, (t3 | 134217728) ^ 134217728, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3 | 32768, 21);
          e3.assignable = 1;
          const a2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          e3.assignable = 2;
          return finishNode(e3, t3, n2, s2, i2, { type: "ConditionalExpression", test: r3, consequent: o2, alternate: a2 });
        }
        function parseBinaryExpression(e3, t3, r3, n2, s2, i2, o2, a2, c2) {
          const p2 = -((t3 & 134217728) > 0) & 8738868;
          let u2;
          let f2;
          e3.assignable = 2;
          while (e3.token & 8454144) {
            u2 = e3.token;
            f2 = u2 & 3840;
            if (u2 & 524288 && a2 & 268435456 || a2 & 524288 && u2 & 268435456) {
              report(e3, 159);
            }
            if (f2 + ((u2 === 8457273) << 8) - ((p2 === u2) << 12) <= o2)
              break;
            nextToken(e3, t3 | 32768);
            c2 = finishNode(e3, t3, n2, s2, i2, { type: u2 & 524288 || u2 & 268435456 ? "LogicalExpression" : "BinaryExpression", left: c2, right: parseBinaryExpression(e3, t3, r3, e3.tokenPos, e3.linePos, e3.colPos, f2, u2, parseLeftHandSideExpression(e3, t3, 0, r3, 1, e3.tokenPos, e3.linePos, e3.colPos)), operator: l[u2 & 255] });
          }
          if (e3.token === 1077936157)
            report(e3, 24);
          return c2;
        }
        function parseUnaryExpression(e3, t3, r3, n2, s2, i2, o2) {
          if (!r3)
            report(e3, 0);
          const a2 = e3.token;
          nextToken(e3, t3 | 32768);
          const c2 = parseLeftHandSideExpression(e3, t3, 0, o2, 1, e3.tokenPos, e3.linePos, e3.colPos);
          if (e3.token === 8457273)
            report(e3, 31);
          if (t3 & 1024 && a2 === 16863278) {
            if (c2.type === "Identifier") {
              report(e3, 117);
            } else if (isPropertyWithPrivateFieldKey(c2)) {
              report(e3, 123);
            }
          }
          e3.assignable = 2;
          return finishNode(e3, t3, n2, s2, i2, { type: "UnaryExpression", operator: l[a2 & 255], argument: c2, prefix: true });
        }
        function parseAsyncExpression(e3, t3, r3, n2, s2, i2, o2, a2, l2, c2) {
          const { token: p2 } = e3;
          const u2 = parseIdentifier(e3, t3, i2);
          const { flags: f2 } = e3;
          if ((f2 & 1) < 1) {
            if (e3.token === 86106) {
              return parseFunctionExpression(e3, t3, 1, r3, a2, l2, c2);
            }
            if ((e3.token & 143360) === 143360) {
              if (!n2)
                report(e3, 0);
              return parseAsyncArrowAfterIdent(e3, t3, s2, a2, l2, c2);
            }
          }
          if (!o2 && e3.token === 67174411) {
            return parseAsyncArrowOrCallExpression(e3, t3, u2, s2, 1, 0, f2, a2, l2, c2);
          }
          if (e3.token === 10) {
            classifyIdentifier(e3, t3, p2, 1);
            if (o2)
              report(e3, 48);
            return parseArrowFromIdentifier(e3, t3, e3.tokenValue, u2, o2, s2, 0, a2, l2, c2);
          }
          return u2;
        }
        function parseYieldExpression(e3, t3, r3, n2, s2, i2, o2) {
          if (r3)
            e3.destructible |= 256;
          if (t3 & 2097152) {
            nextToken(e3, t3 | 32768);
            if (t3 & 8388608)
              report(e3, 30);
            if (!n2)
              report(e3, 24);
            if (e3.token === 22)
              report(e3, 120);
            let r4 = null;
            let a2 = false;
            if ((e3.flags & 1) < 1) {
              a2 = consumeOpt(e3, t3 | 32768, 8457014);
              if (e3.token & (12288 | 65536) || a2) {
                r4 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
              }
            }
            e3.assignable = 2;
            return finishNode(e3, t3, s2, i2, o2, { type: "YieldExpression", argument: r4, delegate: a2 });
          }
          if (t3 & 1024)
            report(e3, 94, "yield");
          return parseIdentifierOrArrow(e3, t3, s2, i2, o2);
        }
        function parseAwaitExpression(e3, t3, r3, n2, s2, i2, o2) {
          if (n2)
            e3.destructible |= 128;
          if (t3 & 4194304 || t3 & 2048 && t3 & 8192) {
            if (r3)
              report(e3, 0);
            if (t3 & 8388608) {
              reportMessageAt(e3.index, e3.line, e3.index, 29);
            }
            nextToken(e3, t3 | 32768);
            const n3 = parseLeftHandSideExpression(e3, t3, 0, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
            if (e3.token === 8457273)
              report(e3, 31);
            e3.assignable = 2;
            return finishNode(e3, t3, s2, i2, o2, { type: "AwaitExpression", argument: n3 });
          }
          if (t3 & 2048)
            report(e3, 95);
          return parseIdentifierOrArrow(e3, t3, s2, i2, o2);
        }
        function parseFunctionBody(e3, t3, r3, n2, s2, i2) {
          const { tokenPos: o2, linePos: a2, colPos: l2 } = e3;
          consume(e3, t3 | 32768, 2162700);
          const c2 = [];
          const p2 = t3;
          if (e3.token !== 1074790415) {
            while (e3.token === 134283267) {
              const { index: r4, tokenPos: n3, tokenValue: s3, token: i3 } = e3;
              const o3 = parseLiteral(e3, t3);
              if (isValidStrictMode(e3, r4, n3, s3)) {
                t3 |= 1024;
                if (e3.flags & 128) {
                  reportMessageAt(e3.index, e3.line, e3.tokenPos, 63);
                }
                if (e3.flags & 64) {
                  reportMessageAt(e3.index, e3.line, e3.tokenPos, 8);
                }
              }
              c2.push(parseDirective(e3, t3, o3, i3, n3, e3.linePos, e3.colPos));
            }
            if (t3 & 1024) {
              if (s2) {
                if ((s2 & 537079808) === 537079808) {
                  report(e3, 115);
                }
                if ((s2 & 36864) === 36864) {
                  report(e3, 38);
                }
              }
              if (e3.flags & 512)
                report(e3, 115);
              if (e3.flags & 256)
                report(e3, 114);
            }
            if (t3 & 64 && r3 && i2 !== void 0 && (p2 & 1024) < 1 && (t3 & 8192) < 1) {
              reportScopeError(i2);
            }
          }
          e3.flags = (e3.flags | 512 | 256 | 64) ^ (512 | 256 | 64);
          e3.destructible = (e3.destructible | 256) ^ 256;
          while (e3.token !== 1074790415) {
            c2.push(parseStatementListItem(e3, t3, r3, 4, {}));
          }
          consume(e3, n2 & (16 | 8) ? t3 | 32768 : t3, 1074790415);
          e3.flags &= ~(128 | 64);
          if (e3.token === 1077936157)
            report(e3, 24);
          return finishNode(e3, t3, o2, a2, l2, { type: "BlockStatement", body: c2 });
        }
        function parseSuperExpression(e3, t3, r3, n2, s2) {
          nextToken(e3, t3);
          switch (e3.token) {
            case 67108991:
              report(e3, 161);
            case 67174411: {
              if ((t3 & 524288) < 1)
                report(e3, 26);
              if (t3 & 16384)
                report(e3, 27);
              e3.assignable = 2;
              break;
            }
            case 69271571:
            case 67108877: {
              if ((t3 & 262144) < 1)
                report(e3, 27);
              if (t3 & 16384)
                report(e3, 27);
              e3.assignable = 1;
              break;
            }
            default:
              report(e3, 28, "super");
          }
          return finishNode(e3, t3, r3, n2, s2, { type: "Super" });
        }
        function parseLeftHandSideExpression(e3, t3, r3, n2, s2, i2, o2, a2) {
          const l2 = parsePrimaryExpression(e3, t3, 2, 0, r3, 0, n2, s2, i2, o2, a2);
          return parseMemberOrUpdateExpression(e3, t3, l2, n2, 0, i2, o2, a2);
        }
        function parseUpdateExpression(e3, t3, r3, n2, s2, i2) {
          if (e3.assignable & 2)
            report(e3, 52);
          const { token: o2 } = e3;
          nextToken(e3, t3);
          e3.assignable = 2;
          return finishNode(e3, t3, n2, s2, i2, { type: "UpdateExpression", argument: r3, operator: l[o2 & 255], prefix: false });
        }
        function parseMemberOrUpdateExpression(e3, t3, r3, n2, s2, i2, o2, a2) {
          if ((e3.token & 33619968) === 33619968 && (e3.flags & 1) < 1) {
            r3 = parseUpdateExpression(e3, t3, r3, i2, o2, a2);
          } else if ((e3.token & 67108864) === 67108864) {
            t3 = (t3 | 134217728) ^ 134217728;
            switch (e3.token) {
              case 67108877: {
                nextToken(e3, (t3 | 1073741824 | 8192) ^ 8192);
                e3.assignable = 1;
                const n3 = parsePropertyOrPrivatePropertyName(e3, t3);
                r3 = finishNode(e3, t3, i2, o2, a2, { type: "MemberExpression", object: r3, computed: false, property: n3 });
                break;
              }
              case 69271571: {
                let s3 = false;
                if ((e3.flags & 2048) === 2048) {
                  s3 = true;
                  e3.flags = (e3.flags | 2048) ^ 2048;
                }
                nextToken(e3, t3 | 32768);
                const { tokenPos: l2, linePos: c2, colPos: p2 } = e3;
                const u2 = parseExpressions(e3, t3, n2, 1, l2, c2, p2);
                consume(e3, t3, 20);
                e3.assignable = 1;
                r3 = finishNode(e3, t3, i2, o2, a2, { type: "MemberExpression", object: r3, computed: true, property: u2 });
                if (s3) {
                  e3.flags |= 2048;
                }
                break;
              }
              case 67174411: {
                if ((e3.flags & 1024) === 1024) {
                  e3.flags = (e3.flags | 1024) ^ 1024;
                  return r3;
                }
                let s3 = false;
                if ((e3.flags & 2048) === 2048) {
                  s3 = true;
                  e3.flags = (e3.flags | 2048) ^ 2048;
                }
                const l2 = parseArguments(e3, t3, n2);
                e3.assignable = 2;
                r3 = finishNode(e3, t3, i2, o2, a2, { type: "CallExpression", callee: r3, arguments: l2 });
                if (s3) {
                  e3.flags |= 2048;
                }
                break;
              }
              case 67108991: {
                nextToken(e3, (t3 | 1073741824 | 8192) ^ 8192);
                e3.flags |= 2048;
                e3.assignable = 2;
                r3 = parseOptionalChain(e3, t3, r3, i2, o2, a2);
                break;
              }
              default:
                if ((e3.flags & 2048) === 2048) {
                  report(e3, 160);
                }
                e3.assignable = 2;
                r3 = finishNode(e3, t3, i2, o2, a2, { type: "TaggedTemplateExpression", tag: r3, quasi: e3.token === 67174408 ? parseTemplate(e3, t3 | 65536) : parseTemplateLiteral(e3, t3, e3.tokenPos, e3.linePos, e3.colPos) });
            }
            r3 = parseMemberOrUpdateExpression(e3, t3, r3, 0, 1, i2, o2, a2);
          }
          if (s2 === 0 && (e3.flags & 2048) === 2048) {
            e3.flags = (e3.flags | 2048) ^ 2048;
            r3 = finishNode(e3, t3, i2, o2, a2, { type: "ChainExpression", expression: r3 });
          }
          return r3;
        }
        function parseOptionalChain(e3, t3, r3, n2, s2, i2) {
          let o2 = false;
          let a2;
          if (e3.token === 69271571 || e3.token === 67174411) {
            if ((e3.flags & 2048) === 2048) {
              o2 = true;
              e3.flags = (e3.flags | 2048) ^ 2048;
            }
          }
          if (e3.token === 69271571) {
            nextToken(e3, t3 | 32768);
            const { tokenPos: o3, linePos: l2, colPos: c2 } = e3;
            const p2 = parseExpressions(e3, t3, 0, 1, o3, l2, c2);
            consume(e3, t3, 20);
            e3.assignable = 2;
            a2 = finishNode(e3, t3, n2, s2, i2, { type: "MemberExpression", object: r3, computed: true, optional: true, property: p2 });
          } else if (e3.token === 67174411) {
            const o3 = parseArguments(e3, t3, 0);
            e3.assignable = 2;
            a2 = finishNode(e3, t3, n2, s2, i2, { type: "CallExpression", callee: r3, arguments: o3, optional: true });
          } else {
            if ((e3.token & (143360 | 4096)) < 1)
              report(e3, 154);
            const o3 = parseIdentifier(e3, t3, 0);
            e3.assignable = 2;
            a2 = finishNode(e3, t3, n2, s2, i2, { type: "MemberExpression", object: r3, computed: false, optional: true, property: o3 });
          }
          if (o2) {
            e3.flags |= 2048;
          }
          return a2;
        }
        function parsePropertyOrPrivatePropertyName(e3, t3) {
          if ((e3.token & (143360 | 4096)) < 1 && e3.token !== 131) {
            report(e3, 154);
          }
          return t3 & 1 && e3.token === 131 ? parsePrivateIdentifier(e3, t3, e3.tokenPos, e3.linePos, e3.colPos) : parseIdentifier(e3, t3, 0);
        }
        function parseUpdateExpressionPrefixed(e3, t3, r3, n2, s2, i2, o2) {
          if (r3)
            report(e3, 53);
          if (!n2)
            report(e3, 0);
          const { token: a2 } = e3;
          nextToken(e3, t3 | 32768);
          const c2 = parseLeftHandSideExpression(e3, t3, 0, 0, 1, e3.tokenPos, e3.linePos, e3.colPos);
          if (e3.assignable & 2) {
            report(e3, 52);
          }
          e3.assignable = 2;
          return finishNode(e3, t3, s2, i2, o2, { type: "UpdateExpression", argument: c2, operator: l[a2 & 255], prefix: true });
        }
        function parsePrimaryExpression(e3, t3, r3, n2, s2, i2, o2, a2, c2, p2, u2) {
          if ((e3.token & 143360) === 143360) {
            switch (e3.token) {
              case 209008:
                return parseAwaitExpression(e3, t3, n2, o2, c2, p2, u2);
              case 241773:
                return parseYieldExpression(e3, t3, o2, s2, c2, p2, u2);
              case 209007:
                return parseAsyncExpression(e3, t3, o2, a2, s2, i2, n2, c2, p2, u2);
            }
            const { token: l2, tokenValue: f2 } = e3;
            const d2 = parseIdentifier(e3, t3 | 65536, i2);
            if (e3.token === 10) {
              if (!a2)
                report(e3, 0);
              classifyIdentifier(e3, t3, l2, 1);
              return parseArrowFromIdentifier(e3, t3, f2, d2, n2, s2, 0, c2, p2, u2);
            }
            if (t3 & 16384 && l2 === 537079928)
              report(e3, 126);
            if (l2 === 241739) {
              if (t3 & 1024)
                report(e3, 109);
              if (r3 & (8 | 16))
                report(e3, 97);
            }
            e3.assignable = t3 & 1024 && (l2 & 537079808) === 537079808 ? 2 : 1;
            return d2;
          }
          if ((e3.token & 134217728) === 134217728) {
            return parseLiteral(e3, t3);
          }
          switch (e3.token) {
            case 33619995:
            case 33619996:
              return parseUpdateExpressionPrefixed(e3, t3, n2, a2, c2, p2, u2);
            case 16863278:
            case 16842800:
            case 16842801:
            case 25233970:
            case 25233971:
            case 16863277:
            case 16863279:
              return parseUnaryExpression(e3, t3, a2, c2, p2, u2, o2);
            case 86106:
              return parseFunctionExpression(e3, t3, 0, o2, c2, p2, u2);
            case 2162700:
              return parseObjectLiteral(e3, t3, s2 ? 0 : 1, o2, c2, p2, u2);
            case 69271571:
              return parseArrayLiteral(e3, t3, s2 ? 0 : 1, o2, c2, p2, u2);
            case 67174411:
              return parseParenthesizedExpression(e3, t3, s2, 1, 0, c2, p2, u2);
            case 86021:
            case 86022:
            case 86023:
              return parseNullOrTrueOrFalseLiteral(e3, t3, c2, p2, u2);
            case 86113:
              return parseThisExpression(e3, t3);
            case 65540:
              return parseRegExpLiteral(e3, t3, c2, p2, u2);
            case 133:
            case 86096:
              return parseClassExpression(e3, t3, o2, c2, p2, u2);
            case 86111:
              return parseSuperExpression(e3, t3, c2, p2, u2);
            case 67174409:
              return parseTemplateLiteral(e3, t3, c2, p2, u2);
            case 67174408:
              return parseTemplate(e3, t3);
            case 86109:
              return parseNewExpression(e3, t3, o2, c2, p2, u2);
            case 134283389:
              return parseBigIntLiteral(e3, t3, c2, p2, u2);
            case 131:
              return parsePrivateIdentifier(e3, t3, c2, p2, u2);
            case 86108:
              return parseImportCallOrMetaExpression(e3, t3, n2, o2, c2, p2, u2);
            case 8456258:
              if (t3 & 16)
                return parseJSXRootElementOrFragment(e3, t3, 1, c2, p2, u2);
            default:
              if (isValidIdentifier(t3, e3.token))
                return parseIdentifierOrArrow(e3, t3, c2, p2, u2);
              report(e3, 28, l[e3.token & 255]);
          }
        }
        function parseImportCallOrMetaExpression(e3, t3, r3, n2, s2, i2, o2) {
          let a2 = parseIdentifier(e3, t3, 0);
          if (e3.token === 67108877) {
            return parseImportMetaExpression(e3, t3, a2, s2, i2, o2);
          }
          if (r3)
            report(e3, 137);
          a2 = parseImportExpression(e3, t3, n2, s2, i2, o2);
          e3.assignable = 2;
          return parseMemberOrUpdateExpression(e3, t3, a2, n2, 0, s2, i2, o2);
        }
        function parseImportMetaExpression(e3, t3, r3, n2, s2, i2) {
          if ((t3 & 2048) === 0)
            report(e3, 163);
          nextToken(e3, t3);
          if (e3.token !== 143495 && e3.tokenValue !== "meta")
            report(e3, 28, l[e3.token & 255]);
          e3.assignable = 2;
          return finishNode(e3, t3, n2, s2, i2, { type: "MetaProperty", meta: r3, property: parseIdentifier(e3, t3, 0) });
        }
        function parseImportExpression(e3, t3, r3, n2, s2, i2) {
          consume(e3, t3 | 32768, 67174411);
          if (e3.token === 14)
            report(e3, 138);
          const o2 = parseExpression(e3, t3, 1, 0, r3, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3, 16);
          return finishNode(e3, t3, n2, s2, i2, { type: "ImportExpression", source: o2 });
        }
        function parseBigIntLiteral(e3, t3, r3, n2, s2) {
          const { tokenRaw: i2, tokenValue: o2 } = e3;
          nextToken(e3, t3);
          e3.assignable = 2;
          return finishNode(e3, t3, r3, n2, s2, t3 & 512 ? { type: "Literal", value: o2, bigint: i2.slice(0, -1), raw: i2 } : { type: "Literal", value: o2, bigint: i2.slice(0, -1) });
        }
        function parseTemplateLiteral(e3, t3, r3, n2, s2) {
          e3.assignable = 2;
          const { tokenValue: i2, tokenRaw: o2, tokenPos: a2, linePos: l2, colPos: c2 } = e3;
          consume(e3, t3, 67174409);
          const p2 = [parseTemplateElement(e3, t3, i2, o2, a2, l2, c2, true)];
          return finishNode(e3, t3, r3, n2, s2, { type: "TemplateLiteral", expressions: [], quasis: p2 });
        }
        function parseTemplate(e3, t3) {
          t3 = (t3 | 134217728) ^ 134217728;
          const { tokenValue: r3, tokenRaw: n2, tokenPos: s2, linePos: i2, colPos: o2 } = e3;
          consume(e3, t3 | 32768, 67174408);
          const a2 = [parseTemplateElement(e3, t3, r3, n2, s2, i2, o2, false)];
          const l2 = [parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos)];
          if (e3.token !== 1074790415)
            report(e3, 80);
          while ((e3.token = scanTemplateTail(e3, t3)) !== 67174409) {
            const { tokenValue: r4, tokenRaw: n3, tokenPos: s3, linePos: i3, colPos: o3 } = e3;
            consume(e3, t3 | 32768, 67174408);
            a2.push(parseTemplateElement(e3, t3, r4, n3, s3, i3, o3, false));
            l2.push(parseExpressions(e3, t3, 0, 1, e3.tokenPos, e3.linePos, e3.colPos));
            if (e3.token !== 1074790415)
              report(e3, 80);
          }
          {
            const { tokenValue: r4, tokenRaw: n3, tokenPos: s3, linePos: i3, colPos: o3 } = e3;
            consume(e3, t3, 67174409);
            a2.push(parseTemplateElement(e3, t3, r4, n3, s3, i3, o3, true));
          }
          return finishNode(e3, t3, s2, i2, o2, { type: "TemplateLiteral", expressions: l2, quasis: a2 });
        }
        function parseTemplateElement(e3, t3, r3, n2, s2, i2, o2, a2) {
          const l2 = finishNode(e3, t3, s2, i2, o2, { type: "TemplateElement", value: { cooked: r3, raw: n2 }, tail: a2 });
          const c2 = a2 ? 1 : 2;
          if (t3 & 2) {
            l2.start += 1;
            l2.range[0] += 1;
            l2.end -= c2;
            l2.range[1] -= c2;
          }
          if (t3 & 4) {
            l2.loc.start.column += 1;
            l2.loc.end.column -= c2;
          }
          return l2;
        }
        function parseSpreadElement(e3, t3, r3, n2, s2) {
          t3 = (t3 | 134217728) ^ 134217728;
          consume(e3, t3 | 32768, 14);
          const i2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          e3.assignable = 1;
          return finishNode(e3, t3, r3, n2, s2, { type: "SpreadElement", argument: i2 });
        }
        function parseArguments(e3, t3, r3) {
          nextToken(e3, t3 | 32768);
          const n2 = [];
          if (e3.token === 16) {
            nextToken(e3, t3);
            return n2;
          }
          while (e3.token !== 16) {
            if (e3.token === 14) {
              n2.push(parseSpreadElement(e3, t3, e3.tokenPos, e3.linePos, e3.colPos));
            } else {
              n2.push(parseExpression(e3, t3, 1, 0, r3, e3.tokenPos, e3.linePos, e3.colPos));
            }
            if (e3.token !== 18)
              break;
            nextToken(e3, t3 | 32768);
            if (e3.token === 16)
              break;
          }
          consume(e3, t3, 16);
          return n2;
        }
        function parseIdentifier(e3, t3, r3) {
          const { tokenValue: n2, tokenPos: s2, linePos: i2, colPos: o2 } = e3;
          nextToken(e3, t3);
          return finishNode(e3, t3, s2, i2, o2, t3 & 268435456 ? { type: "Identifier", name: n2, pattern: r3 === 1 } : { type: "Identifier", name: n2 });
        }
        function parseLiteral(e3, t3) {
          const { tokenValue: r3, tokenRaw: n2, tokenPos: s2, linePos: i2, colPos: o2 } = e3;
          if (e3.token === 134283389) {
            return parseBigIntLiteral(e3, t3, s2, i2, o2);
          }
          nextToken(e3, t3);
          e3.assignable = 2;
          return finishNode(e3, t3, s2, i2, o2, t3 & 512 ? { type: "Literal", value: r3, raw: n2 } : { type: "Literal", value: r3 });
        }
        function parseNullOrTrueOrFalseLiteral(e3, t3, r3, n2, s2) {
          const i2 = l[e3.token & 255];
          const o2 = e3.token === 86023 ? null : i2 === "true";
          nextToken(e3, t3);
          e3.assignable = 2;
          return finishNode(e3, t3, r3, n2, s2, t3 & 512 ? { type: "Literal", value: o2, raw: i2 } : { type: "Literal", value: o2 });
        }
        function parseThisExpression(e3, t3) {
          const { tokenPos: r3, linePos: n2, colPos: s2 } = e3;
          nextToken(e3, t3);
          e3.assignable = 2;
          return finishNode(e3, t3, r3, n2, s2, { type: "ThisExpression" });
        }
        function parseFunctionDeclaration(e3, t3, r3, n2, s2, i2, o2, a2, c2, p2) {
          nextToken(e3, t3 | 32768);
          const u2 = s2 ? optionalBit(e3, t3, 8457014) : 0;
          let f2 = null;
          let d2;
          let h2 = r3 ? createScope() : void 0;
          if (e3.token === 67174411) {
            if ((i2 & 1) < 1)
              report(e3, 37, "Function");
          } else {
            const s3 = n2 & 4 && ((t3 & 8192) < 1 || (t3 & 2048) < 1) ? 4 : 64;
            validateFunctionName(e3, t3 | (t3 & 3072) << 11, e3.token);
            if (r3) {
              if (s3 & 4) {
                addVarName(e3, t3, r3, e3.tokenValue, s3);
              } else {
                addBlockName(e3, t3, r3, e3.tokenValue, s3, n2);
              }
              h2 = addChildScope(h2, 256);
              if (i2) {
                if (i2 & 2) {
                  declareUnboundVariable(e3, e3.tokenValue);
                }
              }
            }
            d2 = e3.token;
            if (e3.token & 143360) {
              f2 = parseIdentifier(e3, t3, 0);
            } else {
              report(e3, 28, l[e3.token & 255]);
            }
          }
          t3 = (t3 | 32243712) ^ 32243712 | 67108864 | o2 * 2 + u2 << 21 | (u2 ? 0 : 1073741824);
          if (r3)
            h2 = addChildScope(h2, 512);
          const m2 = parseFormalParametersOrFormalList(e3, t3 | 8388608, h2, 0, 1);
          const g = parseFunctionBody(e3, (t3 | 8192 | 4096 | 131072) ^ (8192 | 4096 | 131072), r3 ? addChildScope(h2, 128) : h2, 8, d2, r3 ? h2.scopeError : void 0);
          return finishNode(e3, t3, a2, c2, p2, { type: "FunctionDeclaration", id: f2, params: m2, body: g, async: o2 === 1, generator: u2 === 1 });
        }
        function parseFunctionExpression(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3 | 32768);
          const a2 = optionalBit(e3, t3, 8457014);
          const l2 = r3 * 2 + a2 << 21;
          let c2 = null;
          let p2;
          let u2 = t3 & 64 ? createScope() : void 0;
          if ((e3.token & (143360 | 4096 | 36864)) > 0) {
            validateFunctionName(e3, (t3 | 32243712) ^ 32243712 | l2, e3.token);
            if (u2)
              u2 = addChildScope(u2, 256);
            p2 = e3.token;
            c2 = parseIdentifier(e3, t3, 0);
          }
          t3 = (t3 | 32243712) ^ 32243712 | 67108864 | l2 | (a2 ? 0 : 1073741824);
          if (u2)
            u2 = addChildScope(u2, 512);
          const f2 = parseFormalParametersOrFormalList(e3, t3 | 8388608, u2, n2, 1);
          const d2 = parseFunctionBody(e3, t3 & ~(134221824 | 8192 | 4096 | 131072 | 16384), u2 ? addChildScope(u2, 128) : u2, 0, p2, void 0);
          e3.assignable = 2;
          return finishNode(e3, t3, s2, i2, o2, { type: "FunctionExpression", id: c2, params: f2, body: d2, async: r3 === 1, generator: a2 === 1 });
        }
        function parseArrayLiteral(e3, t3, r3, n2, s2, i2, o2) {
          const a2 = parseArrayExpressionOrPattern(e3, t3, void 0, r3, n2, 0, 2, 0, s2, i2, o2);
          if (t3 & 256 && e3.destructible & 64) {
            report(e3, 60);
          }
          if (e3.destructible & 8) {
            report(e3, 59);
          }
          return a2;
        }
        function parseArrayExpressionOrPattern(e3, t3, r3, n2, s2, i2, o2, a2, c2, p2, u2) {
          nextToken(e3, t3 | 32768);
          const f2 = [];
          let d2 = 0;
          t3 = (t3 | 134217728) ^ 134217728;
          while (e3.token !== 20) {
            if (consumeOpt(e3, t3 | 32768, 18)) {
              f2.push(null);
            } else {
              let n3;
              const { token: c3, tokenPos: p3, linePos: u3, colPos: h3, tokenValue: m2 } = e3;
              if (c3 & 143360) {
                n3 = parsePrimaryExpression(e3, t3, o2, 0, 1, 0, s2, 1, p3, u3, h3);
                if (e3.token === 1077936157) {
                  if (e3.assignable & 2)
                    report(e3, 24);
                  nextToken(e3, t3 | 32768);
                  if (r3)
                    addVarOrBlock(e3, t3, r3, m2, o2, a2);
                  const l2 = parseExpression(e3, t3, 1, 1, s2, e3.tokenPos, e3.linePos, e3.colPos);
                  n3 = finishNode(e3, t3, p3, u3, h3, i2 ? { type: "AssignmentPattern", left: n3, right: l2 } : { type: "AssignmentExpression", operator: "=", left: n3, right: l2 });
                  d2 |= e3.destructible & 256 ? 256 : 0 | e3.destructible & 128 ? 128 : 0;
                } else if (e3.token === 18 || e3.token === 20) {
                  if (e3.assignable & 2) {
                    d2 |= 16;
                  } else if (r3) {
                    addVarOrBlock(e3, t3, r3, m2, o2, a2);
                  }
                  d2 |= e3.destructible & 256 ? 256 : 0 | e3.destructible & 128 ? 128 : 0;
                } else {
                  d2 |= o2 & 1 ? 32 : (o2 & 2) < 1 ? 16 : 0;
                  n3 = parseMemberOrUpdateExpression(e3, t3, n3, s2, 0, p3, u3, h3);
                  if (e3.token !== 18 && e3.token !== 20) {
                    if (e3.token !== 1077936157)
                      d2 |= 16;
                    n3 = parseAssignmentExpression(e3, t3, s2, i2, p3, u3, h3, n3);
                  } else if (e3.token !== 1077936157) {
                    d2 |= e3.assignable & 2 ? 16 : 32;
                  }
                }
              } else if (c3 & 2097152) {
                n3 = e3.token === 2162700 ? parseObjectLiteralOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, p3, u3, h3) : parseArrayExpressionOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, p3, u3, h3);
                d2 |= e3.destructible;
                e3.assignable = e3.destructible & 16 ? 2 : 1;
                if (e3.token === 18 || e3.token === 20) {
                  if (e3.assignable & 2) {
                    d2 |= 16;
                  }
                } else if (e3.destructible & 8) {
                  report(e3, 68);
                } else {
                  n3 = parseMemberOrUpdateExpression(e3, t3, n3, s2, 0, p3, u3, h3);
                  d2 = e3.assignable & 2 ? 16 : 0;
                  if (e3.token !== 18 && e3.token !== 20) {
                    n3 = parseAssignmentExpression(e3, t3, s2, i2, p3, u3, h3, n3);
                  } else if (e3.token !== 1077936157) {
                    d2 |= e3.assignable & 2 ? 16 : 32;
                  }
                }
              } else if (c3 === 14) {
                n3 = parseSpreadOrRestElement(e3, t3, r3, 20, o2, a2, 0, s2, i2, p3, u3, h3);
                d2 |= e3.destructible;
                if (e3.token !== 18 && e3.token !== 20)
                  report(e3, 28, l[e3.token & 255]);
              } else {
                n3 = parseLeftHandSideExpression(e3, t3, 1, 0, 1, p3, u3, h3);
                if (e3.token !== 18 && e3.token !== 20) {
                  n3 = parseAssignmentExpression(e3, t3, s2, i2, p3, u3, h3, n3);
                  if ((o2 & (2 | 1)) < 1 && c3 === 67174411)
                    d2 |= 16;
                } else if (e3.assignable & 2) {
                  d2 |= 16;
                } else if (c3 === 67174411) {
                  d2 |= e3.assignable & 1 && o2 & (2 | 1) ? 32 : 16;
                }
              }
              f2.push(n3);
              if (consumeOpt(e3, t3 | 32768, 18)) {
                if (e3.token === 20)
                  break;
              } else
                break;
            }
          }
          consume(e3, t3, 20);
          const h2 = finishNode(e3, t3, c2, p2, u2, { type: i2 ? "ArrayPattern" : "ArrayExpression", elements: f2 });
          if (!n2 && e3.token & 4194304) {
            return parseArrayOrObjectAssignmentPattern(e3, t3, d2, s2, i2, c2, p2, u2, h2);
          }
          e3.destructible = d2;
          return h2;
        }
        function parseArrayOrObjectAssignmentPattern(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          if (e3.token !== 1077936157)
            report(e3, 24);
          nextToken(e3, t3 | 32768);
          if (r3 & 16)
            report(e3, 24);
          if (!s2)
            reinterpretToPattern(e3, l2);
          const { tokenPos: c2, linePos: p2, colPos: u2 } = e3;
          const f2 = parseExpression(e3, t3, 1, 1, n2, c2, p2, u2);
          e3.destructible = (r3 | 64 | 8) ^ (8 | 64) | (e3.destructible & 128 ? 128 : 0) | (e3.destructible & 256 ? 256 : 0);
          return finishNode(e3, t3, i2, o2, a2, s2 ? { type: "AssignmentPattern", left: l2, right: f2 } : { type: "AssignmentExpression", left: l2, operator: "=", right: f2 });
        }
        function parseSpreadOrRestElement(e3, t3, r3, n2, s2, i2, o2, a2, l2, c2, p2, u2) {
          nextToken(e3, t3 | 32768);
          let f2 = null;
          let d2 = 0;
          let { token: h2, tokenValue: m2, tokenPos: g, linePos: k, colPos: b } = e3;
          if (h2 & (4096 | 143360)) {
            e3.assignable = 1;
            f2 = parsePrimaryExpression(e3, t3, s2, 0, 1, 0, a2, 1, g, k, b);
            h2 = e3.token;
            f2 = parseMemberOrUpdateExpression(e3, t3, f2, a2, 0, g, k, b);
            if (e3.token !== 18 && e3.token !== n2) {
              if (e3.assignable & 2 && e3.token === 1077936157)
                report(e3, 68);
              d2 |= 16;
              f2 = parseAssignmentExpression(e3, t3, a2, l2, g, k, b, f2);
            }
            if (e3.assignable & 2) {
              d2 |= 16;
            } else if (h2 === n2 || h2 === 18) {
              if (r3)
                addVarOrBlock(e3, t3, r3, m2, s2, i2);
            } else {
              d2 |= 32;
            }
            d2 |= e3.destructible & 128 ? 128 : 0;
          } else if (h2 === n2) {
            report(e3, 39);
          } else if (h2 & 2097152) {
            f2 = e3.token === 2162700 ? parseObjectLiteralOrPattern(e3, t3, r3, 1, a2, l2, s2, i2, g, k, b) : parseArrayExpressionOrPattern(e3, t3, r3, 1, a2, l2, s2, i2, g, k, b);
            h2 = e3.token;
            if (h2 !== 1077936157 && h2 !== n2 && h2 !== 18) {
              if (e3.destructible & 8)
                report(e3, 68);
              f2 = parseMemberOrUpdateExpression(e3, t3, f2, a2, 0, g, k, b);
              d2 |= e3.assignable & 2 ? 16 : 0;
              if ((e3.token & 4194304) === 4194304) {
                if (e3.token !== 1077936157)
                  d2 |= 16;
                f2 = parseAssignmentExpression(e3, t3, a2, l2, g, k, b, f2);
              } else {
                if ((e3.token & 8454144) === 8454144) {
                  f2 = parseBinaryExpression(e3, t3, 1, g, k, b, 4, h2, f2);
                }
                if (consumeOpt(e3, t3 | 32768, 22)) {
                  f2 = parseConditionalExpression(e3, t3, f2, g, k, b);
                }
                d2 |= e3.assignable & 2 ? 16 : 32;
              }
            } else {
              d2 |= n2 === 1074790415 && h2 !== 1077936157 ? 16 : e3.destructible;
            }
          } else {
            d2 |= 32;
            f2 = parseLeftHandSideExpression(e3, t3, 1, a2, 1, e3.tokenPos, e3.linePos, e3.colPos);
            const { token: r4, tokenPos: s3, linePos: i3, colPos: o3 } = e3;
            if (r4 === 1077936157 && r4 !== n2 && r4 !== 18) {
              if (e3.assignable & 2)
                report(e3, 24);
              f2 = parseAssignmentExpression(e3, t3, a2, l2, s3, i3, o3, f2);
              d2 |= 16;
            } else {
              if (r4 === 18) {
                d2 |= 16;
              } else if (r4 !== n2) {
                f2 = parseAssignmentExpression(e3, t3, a2, l2, s3, i3, o3, f2);
              }
              d2 |= e3.assignable & 1 ? 32 : 16;
            }
            e3.destructible = d2;
            if (e3.token !== n2 && e3.token !== 18)
              report(e3, 155);
            return finishNode(e3, t3, c2, p2, u2, { type: l2 ? "RestElement" : "SpreadElement", argument: f2 });
          }
          if (e3.token !== n2) {
            if (s2 & 1)
              d2 |= o2 ? 16 : 32;
            if (consumeOpt(e3, t3 | 32768, 1077936157)) {
              if (d2 & 16)
                report(e3, 24);
              reinterpretToPattern(e3, f2);
              const r4 = parseExpression(e3, t3, 1, 1, a2, e3.tokenPos, e3.linePos, e3.colPos);
              f2 = finishNode(e3, t3, g, k, b, l2 ? { type: "AssignmentPattern", left: f2, right: r4 } : { type: "AssignmentExpression", left: f2, operator: "=", right: r4 });
              d2 = 16;
            } else {
              d2 |= 16;
            }
          }
          e3.destructible = d2;
          return finishNode(e3, t3, c2, p2, u2, { type: l2 ? "RestElement" : "SpreadElement", argument: f2 });
        }
        function parseMethodDefinition(e3, t3, r3, n2, s2, i2, o2) {
          const a2 = (r3 & 64) < 1 ? 31981568 : 14680064;
          t3 = (t3 | a2) ^ a2 | (r3 & 88) << 18 | 100925440;
          let l2 = t3 & 64 ? addChildScope(createScope(), 512) : void 0;
          const c2 = parseMethodFormals(e3, t3 | 8388608, l2, r3, 1, n2);
          if (l2)
            l2 = addChildScope(l2, 128);
          const p2 = parseFunctionBody(e3, t3 & ~(134221824 | 8192), l2, 0, void 0, void 0);
          return finishNode(e3, t3, s2, i2, o2, { type: "FunctionExpression", params: c2, body: p2, async: (r3 & 16) > 0, generator: (r3 & 8) > 0, id: null });
        }
        function parseObjectLiteral(e3, t3, r3, n2, s2, i2, o2) {
          const a2 = parseObjectLiteralOrPattern(e3, t3, void 0, r3, n2, 0, 2, 0, s2, i2, o2);
          if (t3 & 256 && e3.destructible & 64) {
            report(e3, 60);
          }
          if (e3.destructible & 8) {
            report(e3, 59);
          }
          return a2;
        }
        function parseObjectLiteralOrPattern(e3, t3, r3, n2, s2, i2, o2, a2, c2, p2, u2) {
          nextToken(e3, t3);
          const f2 = [];
          let d2 = 0;
          let h2 = 0;
          t3 = (t3 | 134217728) ^ 134217728;
          while (e3.token !== 1074790415) {
            const { token: n3, tokenValue: c3, linePos: p3, colPos: u3, tokenPos: m3 } = e3;
            if (n3 === 14) {
              f2.push(parseSpreadOrRestElement(e3, t3, r3, 1074790415, o2, a2, 0, s2, i2, m3, p3, u3));
            } else {
              let g = 0;
              let k = null;
              let b;
              const x = e3.token;
              if (e3.token & (143360 | 4096) || e3.token === 121) {
                k = parseIdentifier(e3, t3, 0);
                if (e3.token === 18 || e3.token === 1074790415 || e3.token === 1077936157) {
                  g |= 4;
                  if (t3 & 1024 && (n3 & 537079808) === 537079808) {
                    d2 |= 16;
                  } else {
                    validateBindingIdentifier(e3, t3, o2, n3, 0);
                  }
                  if (r3)
                    addVarOrBlock(e3, t3, r3, c3, o2, a2);
                  if (consumeOpt(e3, t3 | 32768, 1077936157)) {
                    d2 |= 8;
                    const r4 = parseExpression(e3, t3, 1, 1, s2, e3.tokenPos, e3.linePos, e3.colPos);
                    d2 |= e3.destructible & 256 ? 256 : 0 | e3.destructible & 128 ? 128 : 0;
                    b = finishNode(e3, t3, m3, p3, u3, { type: "AssignmentPattern", left: t3 & -2147483648 ? Object.assign({}, k) : k, right: r4 });
                  } else {
                    d2 |= (n3 === 209008 ? 128 : 0) | (n3 === 121 ? 16 : 0);
                    b = t3 & -2147483648 ? Object.assign({}, k) : k;
                  }
                } else if (consumeOpt(e3, t3 | 32768, 21)) {
                  const { tokenPos: l2, linePos: p4, colPos: u4 } = e3;
                  if (c3 === "__proto__")
                    h2++;
                  if (e3.token & 143360) {
                    const n4 = e3.token;
                    const c4 = e3.tokenValue;
                    d2 |= x === 121 ? 16 : 0;
                    b = parsePrimaryExpression(e3, t3, o2, 0, 1, 0, s2, 1, l2, p4, u4);
                    const { token: f3 } = e3;
                    b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, p4, u4);
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (f3 === 1077936157 || f3 === 1074790415 || f3 === 18) {
                        d2 |= e3.destructible & 128 ? 128 : 0;
                        if (e3.assignable & 2) {
                          d2 |= 16;
                        } else if (r3 && (n4 & 143360) === 143360) {
                          addVarOrBlock(e3, t3, r3, c4, o2, a2);
                        }
                      } else {
                        d2 |= e3.assignable & 1 ? 32 : 16;
                      }
                    } else if ((e3.token & 4194304) === 4194304) {
                      if (e3.assignable & 2) {
                        d2 |= 16;
                      } else if (f3 !== 1077936157) {
                        d2 |= 32;
                      } else if (r3) {
                        addVarOrBlock(e3, t3, r3, c4, o2, a2);
                      }
                      b = parseAssignmentExpression(e3, t3, s2, i2, l2, p4, u4, b);
                    } else {
                      d2 |= 16;
                      if ((e3.token & 8454144) === 8454144) {
                        b = parseBinaryExpression(e3, t3, 1, l2, p4, u4, 4, f3, b);
                      }
                      if (consumeOpt(e3, t3 | 32768, 22)) {
                        b = parseConditionalExpression(e3, t3, b, l2, p4, u4);
                      }
                    }
                  } else if ((e3.token & 2097152) === 2097152) {
                    b = e3.token === 69271571 ? parseArrayExpressionOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, l2, p4, u4) : parseObjectLiteralOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, l2, p4, u4);
                    d2 = e3.destructible;
                    e3.assignable = d2 & 16 ? 2 : 1;
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (e3.assignable & 2)
                        d2 |= 16;
                    } else if (e3.destructible & 8) {
                      report(e3, 68);
                    } else {
                      b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, p4, u4);
                      d2 = e3.assignable & 2 ? 16 : 0;
                      if ((e3.token & 4194304) === 4194304) {
                        b = parseAssignmentExpressionOrPattern(e3, t3, s2, i2, l2, p4, u4, b);
                      } else {
                        if ((e3.token & 8454144) === 8454144) {
                          b = parseBinaryExpression(e3, t3, 1, l2, p4, u4, 4, n3, b);
                        }
                        if (consumeOpt(e3, t3 | 32768, 22)) {
                          b = parseConditionalExpression(e3, t3, b, l2, p4, u4);
                        }
                        d2 |= e3.assignable & 2 ? 16 : 32;
                      }
                    }
                  } else {
                    b = parseLeftHandSideExpression(e3, t3, 1, s2, 1, l2, p4, u4);
                    d2 |= e3.assignable & 1 ? 32 : 16;
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (e3.assignable & 2)
                        d2 |= 16;
                    } else {
                      b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, p4, u4);
                      d2 = e3.assignable & 2 ? 16 : 0;
                      if (e3.token !== 18 && n3 !== 1074790415) {
                        if (e3.token !== 1077936157)
                          d2 |= 16;
                        b = parseAssignmentExpression(e3, t3, s2, i2, l2, p4, u4, b);
                      }
                    }
                  }
                } else if (e3.token === 69271571) {
                  d2 |= 16;
                  if (n3 === 209007)
                    g |= 16;
                  g |= (n3 === 12402 ? 256 : n3 === 12403 ? 512 : 1) | 2;
                  k = parseComputedPropertyName(e3, t3, s2);
                  d2 |= e3.assignable;
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                } else if (e3.token & (143360 | 4096)) {
                  d2 |= 16;
                  if (n3 === 121)
                    report(e3, 92);
                  if (n3 === 209007) {
                    if (e3.flags & 1)
                      report(e3, 128);
                    g |= 16;
                  }
                  k = parseIdentifier(e3, t3, 0);
                  g |= n3 === 12402 ? 256 : n3 === 12403 ? 512 : 1;
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                } else if (e3.token === 67174411) {
                  d2 |= 16;
                  g |= 1;
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                } else if (e3.token === 8457014) {
                  d2 |= 16;
                  if (n3 === 12402 || n3 === 12403) {
                    report(e3, 40);
                  } else if (n3 === 143483) {
                    report(e3, 92);
                  }
                  nextToken(e3, t3);
                  g |= 8 | 1 | (n3 === 209007 ? 16 : 0);
                  if (e3.token & 143360) {
                    k = parseIdentifier(e3, t3, 0);
                  } else if ((e3.token & 134217728) === 134217728) {
                    k = parseLiteral(e3, t3);
                  } else if (e3.token === 69271571) {
                    g |= 2;
                    k = parseComputedPropertyName(e3, t3, s2);
                    d2 |= e3.assignable;
                  } else {
                    report(e3, 28, l[e3.token & 255]);
                  }
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                } else if ((e3.token & 134217728) === 134217728) {
                  if (n3 === 209007)
                    g |= 16;
                  g |= n3 === 12402 ? 256 : n3 === 12403 ? 512 : 1;
                  d2 |= 16;
                  k = parseLiteral(e3, t3);
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                } else {
                  report(e3, 129);
                }
              } else if ((e3.token & 134217728) === 134217728) {
                k = parseLiteral(e3, t3);
                if (e3.token === 21) {
                  consume(e3, t3 | 32768, 21);
                  const { tokenPos: l2, linePos: p4, colPos: u4 } = e3;
                  if (c3 === "__proto__")
                    h2++;
                  if (e3.token & 143360) {
                    b = parsePrimaryExpression(e3, t3, o2, 0, 1, 0, s2, 1, l2, p4, u4);
                    const { token: n4, tokenValue: c4 } = e3;
                    b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, p4, u4);
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (n4 === 1077936157 || n4 === 1074790415 || n4 === 18) {
                        if (e3.assignable & 2) {
                          d2 |= 16;
                        } else if (r3) {
                          addVarOrBlock(e3, t3, r3, c4, o2, a2);
                        }
                      } else {
                        d2 |= e3.assignable & 1 ? 32 : 16;
                      }
                    } else if (e3.token === 1077936157) {
                      if (e3.assignable & 2)
                        d2 |= 16;
                      b = parseAssignmentExpression(e3, t3, s2, i2, l2, p4, u4, b);
                    } else {
                      d2 |= 16;
                      b = parseAssignmentExpression(e3, t3, s2, i2, l2, p4, u4, b);
                    }
                  } else if ((e3.token & 2097152) === 2097152) {
                    b = e3.token === 69271571 ? parseArrayExpressionOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, l2, p4, u4) : parseObjectLiteralOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, l2, p4, u4);
                    d2 = e3.destructible;
                    e3.assignable = d2 & 16 ? 2 : 1;
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (e3.assignable & 2) {
                        d2 |= 16;
                      }
                    } else if ((e3.destructible & 8) !== 8) {
                      b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, p4, u4);
                      d2 = e3.assignable & 2 ? 16 : 0;
                      if ((e3.token & 4194304) === 4194304) {
                        b = parseAssignmentExpressionOrPattern(e3, t3, s2, i2, l2, p4, u4, b);
                      } else {
                        if ((e3.token & 8454144) === 8454144) {
                          b = parseBinaryExpression(e3, t3, 1, l2, p4, u4, 4, n3, b);
                        }
                        if (consumeOpt(e3, t3 | 32768, 22)) {
                          b = parseConditionalExpression(e3, t3, b, l2, p4, u4);
                        }
                        d2 |= e3.assignable & 2 ? 16 : 32;
                      }
                    }
                  } else {
                    b = parseLeftHandSideExpression(e3, t3, 1, 0, 1, l2, p4, u4);
                    d2 |= e3.assignable & 1 ? 32 : 16;
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (e3.assignable & 2) {
                        d2 |= 16;
                      }
                    } else {
                      b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, p4, u4);
                      d2 = e3.assignable & 1 ? 0 : 16;
                      if (e3.token !== 18 && e3.token !== 1074790415) {
                        if (e3.token !== 1077936157)
                          d2 |= 16;
                        b = parseAssignmentExpression(e3, t3, s2, i2, l2, p4, u4, b);
                      }
                    }
                  }
                } else if (e3.token === 67174411) {
                  g |= 1;
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                  d2 = e3.assignable | 16;
                } else {
                  report(e3, 130);
                }
              } else if (e3.token === 69271571) {
                k = parseComputedPropertyName(e3, t3, s2);
                d2 |= e3.destructible & 256 ? 256 : 0;
                g |= 2;
                if (e3.token === 21) {
                  nextToken(e3, t3 | 32768);
                  const { tokenPos: l2, linePos: c4, colPos: p4, tokenValue: u4, token: f3 } = e3;
                  if (e3.token & 143360) {
                    b = parsePrimaryExpression(e3, t3, o2, 0, 1, 0, s2, 1, l2, c4, p4);
                    const { token: n4 } = e3;
                    b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, c4, p4);
                    if ((e3.token & 4194304) === 4194304) {
                      d2 |= e3.assignable & 2 ? 16 : n4 === 1077936157 ? 0 : 32;
                      b = parseAssignmentExpressionOrPattern(e3, t3, s2, i2, l2, c4, p4, b);
                    } else if (e3.token === 18 || e3.token === 1074790415) {
                      if (n4 === 1077936157 || n4 === 1074790415 || n4 === 18) {
                        if (e3.assignable & 2) {
                          d2 |= 16;
                        } else if (r3 && (f3 & 143360) === 143360) {
                          addVarOrBlock(e3, t3, r3, u4, o2, a2);
                        }
                      } else {
                        d2 |= e3.assignable & 1 ? 32 : 16;
                      }
                    } else {
                      d2 |= 16;
                      b = parseAssignmentExpression(e3, t3, s2, i2, l2, c4, p4, b);
                    }
                  } else if ((e3.token & 2097152) === 2097152) {
                    b = e3.token === 69271571 ? parseArrayExpressionOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, l2, c4, p4) : parseObjectLiteralOrPattern(e3, t3, r3, 0, s2, i2, o2, a2, l2, c4, p4);
                    d2 = e3.destructible;
                    e3.assignable = d2 & 16 ? 2 : 1;
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (e3.assignable & 2)
                        d2 |= 16;
                    } else if (d2 & 8) {
                      report(e3, 59);
                    } else {
                      b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, c4, p4);
                      d2 = e3.assignable & 2 ? d2 | 16 : 0;
                      if ((e3.token & 4194304) === 4194304) {
                        if (e3.token !== 1077936157)
                          d2 |= 16;
                        b = parseAssignmentExpressionOrPattern(e3, t3, s2, i2, l2, c4, p4, b);
                      } else {
                        if ((e3.token & 8454144) === 8454144) {
                          b = parseBinaryExpression(e3, t3, 1, l2, c4, p4, 4, n3, b);
                        }
                        if (consumeOpt(e3, t3 | 32768, 22)) {
                          b = parseConditionalExpression(e3, t3, b, l2, c4, p4);
                        }
                        d2 |= e3.assignable & 2 ? 16 : 32;
                      }
                    }
                  } else {
                    b = parseLeftHandSideExpression(e3, t3, 1, 0, 1, l2, c4, p4);
                    d2 |= e3.assignable & 1 ? 32 : 16;
                    if (e3.token === 18 || e3.token === 1074790415) {
                      if (e3.assignable & 2)
                        d2 |= 16;
                    } else {
                      b = parseMemberOrUpdateExpression(e3, t3, b, s2, 0, l2, c4, p4);
                      d2 = e3.assignable & 1 ? 0 : 16;
                      if (e3.token !== 18 && e3.token !== 1074790415) {
                        if (e3.token !== 1077936157)
                          d2 |= 16;
                        b = parseAssignmentExpression(e3, t3, s2, i2, l2, c4, p4, b);
                      }
                    }
                  }
                } else if (e3.token === 67174411) {
                  g |= 1;
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, p3, u3);
                  d2 = 16;
                } else {
                  report(e3, 41);
                }
              } else if (n3 === 8457014) {
                consume(e3, t3 | 32768, 8457014);
                g |= 8;
                if (e3.token & 143360) {
                  const { token: r4, line: n4, index: i3 } = e3;
                  k = parseIdentifier(e3, t3, 0);
                  g |= 1;
                  if (e3.token === 67174411) {
                    d2 |= 16;
                    b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                  } else {
                    reportMessageAt(i3, n4, i3, r4 === 209007 ? 43 : r4 === 12402 || e3.token === 12403 ? 42 : 44, l[r4 & 255]);
                  }
                } else if ((e3.token & 134217728) === 134217728) {
                  d2 |= 16;
                  k = parseLiteral(e3, t3);
                  g |= 1;
                  b = parseMethodDefinition(e3, t3, g, s2, m3, p3, u3);
                } else if (e3.token === 69271571) {
                  d2 |= 16;
                  g |= 2 | 1;
                  k = parseComputedPropertyName(e3, t3, s2);
                  b = parseMethodDefinition(e3, t3, g, s2, e3.tokenPos, e3.linePos, e3.colPos);
                } else {
                  report(e3, 122);
                }
              } else {
                report(e3, 28, l[n3 & 255]);
              }
              d2 |= e3.destructible & 128 ? 128 : 0;
              e3.destructible = d2;
              f2.push(finishNode(e3, t3, m3, p3, u3, { type: "Property", key: k, value: b, kind: !(g & 768) ? "init" : g & 512 ? "set" : "get", computed: (g & 2) > 0, method: (g & 1) > 0, shorthand: (g & 4) > 0 }));
            }
            d2 |= e3.destructible;
            if (e3.token !== 18)
              break;
            nextToken(e3, t3);
          }
          consume(e3, t3, 1074790415);
          if (h2 > 1)
            d2 |= 64;
          const m2 = finishNode(e3, t3, c2, p2, u2, { type: i2 ? "ObjectPattern" : "ObjectExpression", properties: f2 });
          if (!n2 && e3.token & 4194304) {
            return parseArrayOrObjectAssignmentPattern(e3, t3, d2, s2, i2, c2, p2, u2, m2);
          }
          e3.destructible = d2;
          return m2;
        }
        function parseMethodFormals(e3, t3, r3, n2, s2, i2) {
          consume(e3, t3, 67174411);
          const o2 = [];
          e3.flags = (e3.flags | 128) ^ 128;
          if (e3.token === 16) {
            if (n2 & 512) {
              report(e3, 35, "Setter", "one", "");
            }
            nextToken(e3, t3);
            return o2;
          }
          if (n2 & 256) {
            report(e3, 35, "Getter", "no", "s");
          }
          if (n2 & 512 && e3.token === 14) {
            report(e3, 36);
          }
          t3 = (t3 | 134217728) ^ 134217728;
          let a2 = 0;
          let l2 = 0;
          while (e3.token !== 18) {
            let c2 = null;
            const { tokenPos: p2, linePos: u2, colPos: f2 } = e3;
            if (e3.token & 143360) {
              if ((t3 & 1024) < 1) {
                if ((e3.token & 36864) === 36864) {
                  e3.flags |= 256;
                }
                if ((e3.token & 537079808) === 537079808) {
                  e3.flags |= 512;
                }
              }
              c2 = parseAndClassifyIdentifier(e3, t3, r3, n2 | 1, 0, p2, u2, f2);
            } else {
              if (e3.token === 2162700) {
                c2 = parseObjectLiteralOrPattern(e3, t3, r3, 1, i2, 1, s2, 0, p2, u2, f2);
              } else if (e3.token === 69271571) {
                c2 = parseArrayExpressionOrPattern(e3, t3, r3, 1, i2, 1, s2, 0, p2, u2, f2);
              } else if (e3.token === 14) {
                c2 = parseSpreadOrRestElement(e3, t3, r3, 16, s2, 0, 0, i2, 1, p2, u2, f2);
              }
              l2 = 1;
              if (e3.destructible & (32 | 16))
                report(e3, 47);
            }
            if (e3.token === 1077936157) {
              nextToken(e3, t3 | 32768);
              l2 = 1;
              const r4 = parseExpression(e3, t3, 1, 1, 0, e3.tokenPos, e3.linePos, e3.colPos);
              c2 = finishNode(e3, t3, p2, u2, f2, { type: "AssignmentPattern", left: c2, right: r4 });
            }
            a2++;
            o2.push(c2);
            if (!consumeOpt(e3, t3, 18))
              break;
            if (e3.token === 16) {
              break;
            }
          }
          if (n2 & 512 && a2 !== 1) {
            report(e3, 35, "Setter", "one", "");
          }
          if (r3 && r3.scopeError !== void 0)
            reportScopeError(r3.scopeError);
          if (l2)
            e3.flags |= 128;
          consume(e3, t3, 16);
          return o2;
        }
        function parseComputedPropertyName(e3, t3, r3) {
          nextToken(e3, t3 | 32768);
          const n2 = parseExpression(e3, (t3 | 134217728) ^ 134217728, 1, 0, r3, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3, 20);
          return n2;
        }
        function parseParenthesizedExpression(e3, t3, r3, n2, s2, i2, o2, a2) {
          e3.flags = (e3.flags | 128) ^ 128;
          const { tokenPos: l2, linePos: c2, colPos: p2 } = e3;
          nextToken(e3, t3 | 32768 | 1073741824);
          const u2 = t3 & 64 ? addChildScope(createScope(), 1024) : void 0;
          t3 = (t3 | 134217728) ^ 134217728;
          if (consumeOpt(e3, t3, 16)) {
            return parseParenthesizedArrow(e3, t3, u2, [], r3, 0, i2, o2, a2);
          }
          let f2 = 0;
          e3.destructible &= ~(256 | 128);
          let d2;
          let h2 = [];
          let m2 = 0;
          let g = 0;
          const { tokenPos: k, linePos: b, colPos: x } = e3;
          e3.assignable = 1;
          while (e3.token !== 16) {
            const { token: r4, tokenPos: i3, linePos: o3, colPos: a3 } = e3;
            if (r4 & (143360 | 4096)) {
              if (u2)
                addBlockName(e3, t3, u2, e3.tokenValue, 1, 0);
              d2 = parsePrimaryExpression(e3, t3, n2, 0, 1, 0, 1, 1, i3, o3, a3);
              if (e3.token === 16 || e3.token === 18) {
                if (e3.assignable & 2) {
                  f2 |= 16;
                  g = 1;
                } else if ((r4 & 537079808) === 537079808 || (r4 & 36864) === 36864) {
                  g = 1;
                }
              } else {
                if (e3.token === 1077936157) {
                  g = 1;
                } else {
                  f2 |= 16;
                }
                d2 = parseMemberOrUpdateExpression(e3, t3, d2, 1, 0, i3, o3, a3);
                if (e3.token !== 16 && e3.token !== 18) {
                  d2 = parseAssignmentExpression(e3, t3, 1, 0, i3, o3, a3, d2);
                }
              }
            } else if ((r4 & 2097152) === 2097152) {
              d2 = r4 === 2162700 ? parseObjectLiteralOrPattern(e3, t3 | 1073741824, u2, 0, 1, 0, n2, s2, i3, o3, a3) : parseArrayExpressionOrPattern(e3, t3 | 1073741824, u2, 0, 1, 0, n2, s2, i3, o3, a3);
              f2 |= e3.destructible;
              g = 1;
              e3.assignable = 2;
              if (e3.token !== 16 && e3.token !== 18) {
                if (f2 & 8)
                  report(e3, 118);
                d2 = parseMemberOrUpdateExpression(e3, t3, d2, 0, 0, i3, o3, a3);
                f2 |= 16;
                if (e3.token !== 16 && e3.token !== 18) {
                  d2 = parseAssignmentExpression(e3, t3, 0, 0, i3, o3, a3, d2);
                }
              }
            } else if (r4 === 14) {
              d2 = parseSpreadOrRestElement(e3, t3, u2, 16, n2, s2, 0, 1, 0, i3, o3, a3);
              if (e3.destructible & 16)
                report(e3, 71);
              g = 1;
              if (m2 && (e3.token === 16 || e3.token === 18)) {
                h2.push(d2);
              }
              f2 |= 8;
              break;
            } else {
              f2 |= 16;
              d2 = parseExpression(e3, t3, 1, 0, 1, i3, o3, a3);
              if (m2 && (e3.token === 16 || e3.token === 18)) {
                h2.push(d2);
              }
              if (e3.token === 18) {
                if (!m2) {
                  m2 = 1;
                  h2 = [d2];
                }
              }
              if (m2) {
                while (consumeOpt(e3, t3 | 32768, 18)) {
                  h2.push(parseExpression(e3, t3, 1, 0, 1, e3.tokenPos, e3.linePos, e3.colPos));
                }
                e3.assignable = 2;
                d2 = finishNode(e3, t3, k, b, x, { type: "SequenceExpression", expressions: h2 });
              }
              consume(e3, t3, 16);
              e3.destructible = f2;
              return d2;
            }
            if (m2 && (e3.token === 16 || e3.token === 18)) {
              h2.push(d2);
            }
            if (!consumeOpt(e3, t3 | 32768, 18))
              break;
            if (!m2) {
              m2 = 1;
              h2 = [d2];
            }
            if (e3.token === 16) {
              f2 |= 8;
              break;
            }
          }
          if (m2) {
            e3.assignable = 2;
            d2 = finishNode(e3, t3, k, b, x, { type: "SequenceExpression", expressions: h2 });
          }
          consume(e3, t3, 16);
          if (f2 & 16 && f2 & 8)
            report(e3, 145);
          f2 |= e3.destructible & 256 ? 256 : 0 | e3.destructible & 128 ? 128 : 0;
          if (e3.token === 10) {
            if (f2 & (32 | 16))
              report(e3, 46);
            if (t3 & (4194304 | 2048) && f2 & 128)
              report(e3, 29);
            if (t3 & (1024 | 2097152) && f2 & 256) {
              report(e3, 30);
            }
            if (g)
              e3.flags |= 128;
            return parseParenthesizedArrow(e3, t3, u2, m2 ? h2 : [d2], r3, 0, i2, o2, a2);
          } else if (f2 & 8) {
            report(e3, 139);
          }
          e3.destructible = (e3.destructible | 256) ^ 256 | f2;
          return t3 & 128 ? finishNode(e3, t3, l2, c2, p2, { type: "ParenthesizedExpression", expression: d2 }) : d2;
        }
        function parseIdentifierOrArrow(e3, t3, r3, n2, s2) {
          const { tokenValue: i2 } = e3;
          const o2 = parseIdentifier(e3, t3, 0);
          e3.assignable = 1;
          if (e3.token === 10) {
            let a2 = void 0;
            if (t3 & 64)
              a2 = createArrowHeadParsingScope(e3, t3, i2);
            e3.flags = (e3.flags | 128) ^ 128;
            return parseArrowFunctionExpression(e3, t3, a2, [o2], 0, r3, n2, s2);
          }
          return o2;
        }
        function parseArrowFromIdentifier(e3, t3, r3, n2, s2, i2, o2, a2, l2, c2) {
          if (!i2)
            report(e3, 54);
          if (s2)
            report(e3, 48);
          e3.flags &= ~128;
          const p2 = t3 & 64 ? createArrowHeadParsingScope(e3, t3, r3) : void 0;
          return parseArrowFunctionExpression(e3, t3, p2, [n2], o2, a2, l2, c2);
        }
        function parseParenthesizedArrow(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          if (!s2)
            report(e3, 54);
          for (let t4 = 0; t4 < n2.length; ++t4)
            reinterpretToPattern(e3, n2[t4]);
          return parseArrowFunctionExpression(e3, t3, r3, n2, i2, o2, a2, l2);
        }
        function parseArrowFunctionExpression(e3, t3, r3, n2, s2, i2, o2, a2) {
          if (e3.flags & 1)
            report(e3, 45);
          consume(e3, t3 | 32768, 10);
          t3 = (t3 | 15728640) ^ 15728640 | s2 << 22;
          const c2 = e3.token !== 2162700;
          let p2;
          if (r3 && r3.scopeError !== void 0) {
            reportScopeError(r3.scopeError);
          }
          if (c2) {
            p2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          } else {
            if (r3)
              r3 = addChildScope(r3, 128);
            p2 = parseFunctionBody(e3, (t3 | 134221824 | 8192 | 16384) ^ (134221824 | 8192 | 16384), r3, 16, void 0, void 0);
            switch (e3.token) {
              case 69271571:
                if ((e3.flags & 1) < 1) {
                  report(e3, 112);
                }
                break;
              case 67108877:
              case 67174409:
              case 22:
                report(e3, 113);
              case 67174411:
                if ((e3.flags & 1) < 1) {
                  report(e3, 112);
                }
                e3.flags |= 1024;
                break;
            }
            if ((e3.token & 8454144) === 8454144 && (e3.flags & 1) < 1)
              report(e3, 28, l[e3.token & 255]);
            if ((e3.token & 33619968) === 33619968)
              report(e3, 121);
          }
          e3.assignable = 2;
          return finishNode(e3, t3, i2, o2, a2, { type: "ArrowFunctionExpression", params: n2, body: p2, async: s2 === 1, expression: c2 });
        }
        function parseFormalParametersOrFormalList(e3, t3, r3, n2, s2) {
          consume(e3, t3, 67174411);
          e3.flags = (e3.flags | 128) ^ 128;
          const i2 = [];
          if (consumeOpt(e3, t3, 16))
            return i2;
          t3 = (t3 | 134217728) ^ 134217728;
          let o2 = 0;
          while (e3.token !== 18) {
            let a2;
            const { tokenPos: c2, linePos: p2, colPos: u2 } = e3;
            if (e3.token & 143360) {
              if ((t3 & 1024) < 1) {
                if ((e3.token & 36864) === 36864) {
                  e3.flags |= 256;
                }
                if ((e3.token & 537079808) === 537079808) {
                  e3.flags |= 512;
                }
              }
              a2 = parseAndClassifyIdentifier(e3, t3, r3, s2 | 1, 0, c2, p2, u2);
            } else {
              if (e3.token === 2162700) {
                a2 = parseObjectLiteralOrPattern(e3, t3, r3, 1, n2, 1, s2, 0, c2, p2, u2);
              } else if (e3.token === 69271571) {
                a2 = parseArrayExpressionOrPattern(e3, t3, r3, 1, n2, 1, s2, 0, c2, p2, u2);
              } else if (e3.token === 14) {
                a2 = parseSpreadOrRestElement(e3, t3, r3, 16, s2, 0, 0, n2, 1, c2, p2, u2);
              } else {
                report(e3, 28, l[e3.token & 255]);
              }
              o2 = 1;
              if (e3.destructible & (32 | 16)) {
                report(e3, 47);
              }
            }
            if (e3.token === 1077936157) {
              nextToken(e3, t3 | 32768);
              o2 = 1;
              const r4 = parseExpression(e3, t3, 1, 1, n2, e3.tokenPos, e3.linePos, e3.colPos);
              a2 = finishNode(e3, t3, c2, p2, u2, { type: "AssignmentPattern", left: a2, right: r4 });
            }
            i2.push(a2);
            if (!consumeOpt(e3, t3, 18))
              break;
            if (e3.token === 16) {
              break;
            }
          }
          if (o2)
            e3.flags |= 128;
          if (r3 && (o2 || t3 & 1024) && r3.scopeError !== void 0) {
            reportScopeError(r3.scopeError);
          }
          consume(e3, t3, 16);
          return i2;
        }
        function parseMembeExpressionNoCall(e3, t3, r3, n2, s2, i2, o2) {
          const { token: a2 } = e3;
          if (a2 & 67108864) {
            if (a2 === 67108877) {
              nextToken(e3, t3 | 1073741824);
              e3.assignable = 1;
              const n3 = parsePropertyOrPrivatePropertyName(e3, t3);
              return parseMembeExpressionNoCall(e3, t3, finishNode(e3, t3, s2, i2, o2, { type: "MemberExpression", object: r3, computed: false, property: n3 }), 0, s2, i2, o2);
            } else if (a2 === 69271571) {
              nextToken(e3, t3 | 32768);
              const { tokenPos: a3, linePos: l2, colPos: c2 } = e3;
              const p2 = parseExpressions(e3, t3, n2, 1, a3, l2, c2);
              consume(e3, t3, 20);
              e3.assignable = 1;
              return parseMembeExpressionNoCall(e3, t3, finishNode(e3, t3, s2, i2, o2, { type: "MemberExpression", object: r3, computed: true, property: p2 }), 0, s2, i2, o2);
            } else if (a2 === 67174408 || a2 === 67174409) {
              e3.assignable = 2;
              return parseMembeExpressionNoCall(e3, t3, finishNode(e3, t3, s2, i2, o2, { type: "TaggedTemplateExpression", tag: r3, quasi: e3.token === 67174408 ? parseTemplate(e3, t3 | 65536) : parseTemplateLiteral(e3, t3, e3.tokenPos, e3.linePos, e3.colPos) }), 0, s2, i2, o2);
            }
          }
          return r3;
        }
        function parseNewExpression(e3, t3, r3, n2, s2, i2) {
          const o2 = parseIdentifier(e3, t3 | 32768, 0);
          const { tokenPos: a2, linePos: c2, colPos: p2 } = e3;
          if (consumeOpt(e3, t3, 67108877)) {
            if (t3 & 67108864 && e3.token === 143494) {
              e3.assignable = 2;
              return parseMetaProperty(e3, t3, o2, n2, s2, i2);
            }
            report(e3, 91);
          }
          e3.assignable = 2;
          if ((e3.token & 16842752) === 16842752) {
            report(e3, 62, l[e3.token & 255]);
          }
          const u2 = parsePrimaryExpression(e3, t3, 2, 1, 0, 0, r3, 1, a2, c2, p2);
          t3 = (t3 | 134217728) ^ 134217728;
          if (e3.token === 67108991)
            report(e3, 162);
          const f2 = parseMembeExpressionNoCall(e3, t3, u2, r3, a2, c2, p2);
          e3.assignable = 2;
          return finishNode(e3, t3, n2, s2, i2, { type: "NewExpression", callee: f2, arguments: e3.token === 67174411 ? parseArguments(e3, t3, r3) : [] });
        }
        function parseMetaProperty(e3, t3, r3, n2, s2, i2) {
          const o2 = parseIdentifier(e3, t3, 0);
          return finishNode(e3, t3, n2, s2, i2, { type: "MetaProperty", meta: r3, property: o2 });
        }
        function parseAsyncArrowAfterIdent(e3, t3, r3, n2, s2, i2) {
          if (e3.token === 209008)
            report(e3, 29);
          if (t3 & (1024 | 2097152) && e3.token === 241773) {
            report(e3, 30);
          }
          if ((e3.token & 537079808) === 537079808) {
            e3.flags |= 512;
          }
          return parseArrowFromIdentifier(e3, t3, e3.tokenValue, parseIdentifier(e3, t3, 0), 0, r3, 1, n2, s2, i2);
        }
        function parseAsyncArrowOrCallExpression(e3, t3, r3, n2, s2, i2, o2, a2, l2, c2) {
          nextToken(e3, t3 | 32768);
          const p2 = t3 & 64 ? addChildScope(createScope(), 1024) : void 0;
          t3 = (t3 | 134217728) ^ 134217728;
          if (consumeOpt(e3, t3, 16)) {
            if (e3.token === 10) {
              if (o2 & 1)
                report(e3, 45);
              return parseParenthesizedArrow(e3, t3, p2, [], n2, 1, a2, l2, c2);
            }
            return finishNode(e3, t3, a2, l2, c2, { type: "CallExpression", callee: r3, arguments: [] });
          }
          let u2 = 0;
          let f2 = null;
          let d2 = 0;
          e3.destructible = (e3.destructible | 256 | 128) ^ (256 | 128);
          const h2 = [];
          while (e3.token !== 16) {
            const { token: n3, tokenPos: o3, linePos: m2, colPos: g } = e3;
            if (n3 & (143360 | 4096)) {
              if (p2)
                addBlockName(e3, t3, p2, e3.tokenValue, s2, 0);
              f2 = parsePrimaryExpression(e3, t3, s2, 0, 1, 0, 1, 1, o3, m2, g);
              if (e3.token === 16 || e3.token === 18) {
                if (e3.assignable & 2) {
                  u2 |= 16;
                  d2 = 1;
                } else if ((n3 & 537079808) === 537079808) {
                  e3.flags |= 512;
                } else if ((n3 & 36864) === 36864) {
                  e3.flags |= 256;
                }
              } else {
                if (e3.token === 1077936157) {
                  d2 = 1;
                } else {
                  u2 |= 16;
                }
                f2 = parseMemberOrUpdateExpression(e3, t3, f2, 1, 0, o3, m2, g);
                if (e3.token !== 16 && e3.token !== 18) {
                  f2 = parseAssignmentExpression(e3, t3, 1, 0, o3, m2, g, f2);
                }
              }
            } else if (n3 & 2097152) {
              f2 = n3 === 2162700 ? parseObjectLiteralOrPattern(e3, t3, p2, 0, 1, 0, s2, i2, o3, m2, g) : parseArrayExpressionOrPattern(e3, t3, p2, 0, 1, 0, s2, i2, o3, m2, g);
              u2 |= e3.destructible;
              d2 = 1;
              if (e3.token !== 16 && e3.token !== 18) {
                if (u2 & 8)
                  report(e3, 118);
                f2 = parseMemberOrUpdateExpression(e3, t3, f2, 0, 0, o3, m2, g);
                u2 |= 16;
                if ((e3.token & 8454144) === 8454144) {
                  f2 = parseBinaryExpression(e3, t3, 1, a2, l2, c2, 4, n3, f2);
                }
                if (consumeOpt(e3, t3 | 32768, 22)) {
                  f2 = parseConditionalExpression(e3, t3, f2, a2, l2, c2);
                }
              }
            } else if (n3 === 14) {
              f2 = parseSpreadOrRestElement(e3, t3, p2, 16, s2, i2, 1, 1, 0, o3, m2, g);
              u2 |= (e3.token === 16 ? 0 : 16) | e3.destructible;
              d2 = 1;
            } else {
              f2 = parseExpression(e3, t3, 1, 0, 0, o3, m2, g);
              u2 = e3.assignable;
              h2.push(f2);
              while (consumeOpt(e3, t3 | 32768, 18)) {
                h2.push(parseExpression(e3, t3, 1, 0, 0, o3, m2, g));
              }
              u2 |= e3.assignable;
              consume(e3, t3, 16);
              e3.destructible = u2 | 16;
              e3.assignable = 2;
              return finishNode(e3, t3, a2, l2, c2, { type: "CallExpression", callee: r3, arguments: h2 });
            }
            h2.push(f2);
            if (!consumeOpt(e3, t3 | 32768, 18))
              break;
          }
          consume(e3, t3, 16);
          u2 |= e3.destructible & 256 ? 256 : 0 | e3.destructible & 128 ? 128 : 0;
          if (e3.token === 10) {
            if (u2 & (32 | 16))
              report(e3, 25);
            if (e3.flags & 1 || o2 & 1)
              report(e3, 45);
            if (u2 & 128)
              report(e3, 29);
            if (t3 & (1024 | 2097152) && u2 & 256)
              report(e3, 30);
            if (d2)
              e3.flags |= 128;
            return parseParenthesizedArrow(e3, t3, p2, h2, n2, 1, a2, l2, c2);
          } else if (u2 & 8) {
            report(e3, 59);
          }
          e3.assignable = 2;
          return finishNode(e3, t3, a2, l2, c2, { type: "CallExpression", callee: r3, arguments: h2 });
        }
        function parseRegExpLiteral(e3, t3, r3, n2, s2) {
          const { tokenRaw: i2, tokenRegExp: o2, tokenValue: a2 } = e3;
          nextToken(e3, t3);
          e3.assignable = 2;
          return t3 & 512 ? finishNode(e3, t3, r3, n2, s2, { type: "Literal", value: a2, regex: o2, raw: i2 }) : finishNode(e3, t3, r3, n2, s2, { type: "Literal", value: a2, regex: o2 });
        }
        function parseClassDeclaration(e3, t3, r3, n2, s2, i2, o2) {
          t3 = (t3 | 16777216 | 1024) ^ 16777216;
          let a2 = parseDecorators(e3, t3);
          if (a2.length) {
            s2 = e3.tokenPos;
            i2 = e3.linePos;
            o2 = e3.colPos;
          }
          if (e3.leadingDecorators.length) {
            e3.leadingDecorators.push(...a2);
            a2 = e3.leadingDecorators;
            e3.leadingDecorators = [];
          }
          nextToken(e3, t3);
          let l2 = null;
          let c2 = null;
          const { tokenValue: p2 } = e3;
          if (e3.token & 4096 && e3.token !== 20567) {
            if (isStrictReservedWord(e3, t3, e3.token)) {
              report(e3, 114);
            }
            if ((e3.token & 537079808) === 537079808) {
              report(e3, 115);
            }
            if (r3) {
              addBlockName(e3, t3, r3, p2, 32, 0);
              if (n2) {
                if (n2 & 2) {
                  declareUnboundVariable(e3, p2);
                }
              }
            }
            l2 = parseIdentifier(e3, t3, 0);
          } else {
            if ((n2 & 1) < 1)
              report(e3, 37, "Class");
          }
          let u2 = t3;
          if (consumeOpt(e3, t3 | 32768, 20567)) {
            c2 = parseLeftHandSideExpression(e3, t3, 0, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
            u2 |= 524288;
          } else {
            u2 = (u2 | 524288) ^ 524288;
          }
          const f2 = parseClassBody(e3, u2, t3, r3, 2, 8, 0);
          return finishNode(e3, t3, s2, i2, o2, t3 & 1 ? { type: "ClassDeclaration", id: l2, superClass: c2, decorators: a2, body: f2 } : { type: "ClassDeclaration", id: l2, superClass: c2, body: f2 });
        }
        function parseClassExpression(e3, t3, r3, n2, s2, i2) {
          let o2 = null;
          let a2 = null;
          t3 = (t3 | 1024 | 16777216) ^ 16777216;
          const l2 = parseDecorators(e3, t3);
          if (l2.length) {
            n2 = e3.tokenPos;
            s2 = e3.linePos;
            i2 = e3.colPos;
          }
          nextToken(e3, t3);
          if (e3.token & 4096 && e3.token !== 20567) {
            if (isStrictReservedWord(e3, t3, e3.token))
              report(e3, 114);
            if ((e3.token & 537079808) === 537079808) {
              report(e3, 115);
            }
            o2 = parseIdentifier(e3, t3, 0);
          }
          let c2 = t3;
          if (consumeOpt(e3, t3 | 32768, 20567)) {
            a2 = parseLeftHandSideExpression(e3, t3, 0, r3, 0, e3.tokenPos, e3.linePos, e3.colPos);
            c2 |= 524288;
          } else {
            c2 = (c2 | 524288) ^ 524288;
          }
          const p2 = parseClassBody(e3, c2, t3, void 0, 2, 0, r3);
          e3.assignable = 2;
          return finishNode(e3, t3, n2, s2, i2, t3 & 1 ? { type: "ClassExpression", id: o2, superClass: a2, decorators: l2, body: p2 } : { type: "ClassExpression", id: o2, superClass: a2, body: p2 });
        }
        function parseDecorators(e3, t3) {
          const r3 = [];
          if (t3 & 1) {
            while (e3.token === 133) {
              r3.push(parseDecoratorList(e3, t3, e3.tokenPos, e3.linePos, e3.colPos));
            }
          }
          return r3;
        }
        function parseDecoratorList(e3, t3, r3, n2, s2) {
          nextToken(e3, t3 | 32768);
          let i2 = parsePrimaryExpression(e3, t3, 2, 0, 1, 0, 0, 1, r3, n2, s2);
          i2 = parseMemberOrUpdateExpression(e3, t3, i2, 0, 0, r3, n2, s2);
          return finishNode(e3, t3, r3, n2, s2, { type: "Decorator", expression: i2 });
        }
        function parseClassBody(e3, t3, r3, n2, s2, i2, o2) {
          const { tokenPos: a2, linePos: l2, colPos: c2 } = e3;
          consume(e3, t3 | 32768, 2162700);
          t3 = (t3 | 134217728) ^ 134217728;
          e3.flags = (e3.flags | 32) ^ 32;
          const p2 = [];
          let u2;
          while (e3.token !== 1074790415) {
            let i3 = 0;
            u2 = parseDecorators(e3, t3);
            i3 = u2.length;
            if (i3 > 0 && e3.tokenValue === "constructor") {
              report(e3, 106);
            }
            if (e3.token === 1074790415)
              report(e3, 105);
            if (consumeOpt(e3, t3, 1074790417)) {
              if (i3 > 0)
                report(e3, 116);
              continue;
            }
            p2.push(parseClassElementList(e3, t3, n2, r3, s2, u2, 0, o2, e3.tokenPos, e3.linePos, e3.colPos));
          }
          consume(e3, i2 & 8 ? t3 | 32768 : t3, 1074790415);
          return finishNode(e3, t3, a2, l2, c2, { type: "ClassBody", body: p2 });
        }
        function parseClassElementList(e3, t3, r3, n2, s2, i2, o2, a2, c2, p2, u2) {
          let f2 = o2 ? 32 : 0;
          let d2 = null;
          const { token: h2, tokenPos: m2, linePos: g, colPos: k } = e3;
          if (h2 & (143360 | 36864)) {
            d2 = parseIdentifier(e3, t3, 0);
            switch (h2) {
              case 36972:
                if (!o2 && e3.token !== 67174411) {
                  return parseClassElementList(e3, t3, r3, n2, s2, i2, 1, a2, c2, p2, u2);
                }
                break;
              case 209007:
                if (e3.token !== 67174411 && (e3.flags & 1) < 1) {
                  if (t3 & 1 && (e3.token & 1073741824) === 1073741824) {
                    return parsePropertyDefinition(e3, t3, d2, f2, i2, m2, g, k);
                  }
                  f2 |= 16 | (optionalBit(e3, t3, 8457014) ? 8 : 0);
                }
                break;
              case 12402:
                if (e3.token !== 67174411) {
                  if (t3 & 1 && (e3.token & 1073741824) === 1073741824) {
                    return parsePropertyDefinition(e3, t3, d2, f2, i2, m2, g, k);
                  }
                  f2 |= 256;
                }
                break;
              case 12403:
                if (e3.token !== 67174411) {
                  if (t3 & 1 && (e3.token & 1073741824) === 1073741824) {
                    return parsePropertyDefinition(e3, t3, d2, f2, i2, m2, g, k);
                  }
                  f2 |= 512;
                }
                break;
            }
          } else if (h2 === 69271571) {
            f2 |= 2;
            d2 = parseComputedPropertyName(e3, n2, a2);
          } else if ((h2 & 134217728) === 134217728) {
            d2 = parseLiteral(e3, t3);
          } else if (h2 === 8457014) {
            f2 |= 8;
            nextToken(e3, t3);
          } else if (t3 & 1 && e3.token === 131) {
            f2 |= 4096;
            d2 = parsePrivateIdentifier(e3, t3 | 16384, m2, g, k);
          } else if (t3 & 1 && (e3.token & 1073741824) === 1073741824) {
            f2 |= 128;
          } else if (h2 === 122) {
            d2 = parseIdentifier(e3, t3, 0);
            if (e3.token !== 67174411)
              report(e3, 28, l[e3.token & 255]);
          } else {
            report(e3, 28, l[e3.token & 255]);
          }
          if (f2 & (8 | 16 | 768)) {
            if (e3.token & 143360) {
              d2 = parseIdentifier(e3, t3, 0);
            } else if ((e3.token & 134217728) === 134217728) {
              d2 = parseLiteral(e3, t3);
            } else if (e3.token === 69271571) {
              f2 |= 2;
              d2 = parseComputedPropertyName(e3, t3, 0);
            } else if (e3.token === 122) {
              d2 = parseIdentifier(e3, t3, 0);
            } else if (t3 & 1 && e3.token === 131) {
              f2 |= 4096;
              d2 = parsePrivateIdentifier(e3, t3, m2, g, k);
            } else
              report(e3, 131);
          }
          if ((f2 & 2) < 1) {
            if (e3.tokenValue === "constructor") {
              if ((e3.token & 1073741824) === 1073741824) {
                report(e3, 125);
              } else if ((f2 & 32) < 1 && e3.token === 67174411) {
                if (f2 & (768 | 16 | 128 | 8)) {
                  report(e3, 50, "accessor");
                } else if ((t3 & 524288) < 1) {
                  if (e3.flags & 32)
                    report(e3, 51);
                  else
                    e3.flags |= 32;
                }
              }
              f2 |= 64;
            } else if ((f2 & 4096) < 1 && f2 & (32 | 768 | 8 | 16) && e3.tokenValue === "prototype") {
              report(e3, 49);
            }
          }
          if (t3 & 1 && e3.token !== 67174411) {
            return parsePropertyDefinition(e3, t3, d2, f2, i2, m2, g, k);
          }
          const b = parseMethodDefinition(e3, t3, f2, a2, e3.tokenPos, e3.linePos, e3.colPos);
          return finishNode(e3, t3, c2, p2, u2, t3 & 1 ? { type: "MethodDefinition", kind: (f2 & 32) < 1 && f2 & 64 ? "constructor" : f2 & 256 ? "get" : f2 & 512 ? "set" : "method", static: (f2 & 32) > 0, computed: (f2 & 2) > 0, key: d2, decorators: i2, value: b } : { type: "MethodDefinition", kind: (f2 & 32) < 1 && f2 & 64 ? "constructor" : f2 & 256 ? "get" : f2 & 512 ? "set" : "method", static: (f2 & 32) > 0, computed: (f2 & 2) > 0, key: d2, value: b });
        }
        function parsePrivateIdentifier(e3, t3, r3, n2, s2) {
          nextToken(e3, t3);
          const { tokenValue: i2 } = e3;
          if (i2 === "constructor")
            report(e3, 124);
          nextToken(e3, t3);
          return finishNode(e3, t3, r3, n2, s2, { type: "PrivateIdentifier", name: i2 });
        }
        function parsePropertyDefinition(e3, t3, r3, n2, s2, i2, o2, a2) {
          let l2 = null;
          if (n2 & 8)
            report(e3, 0);
          if (e3.token === 1077936157) {
            nextToken(e3, t3 | 32768);
            const { tokenPos: r4, linePos: n3, colPos: s3 } = e3;
            if (e3.token === 537079928)
              report(e3, 115);
            l2 = parsePrimaryExpression(e3, t3 | 16384, 2, 0, 1, 0, 0, 1, r4, n3, s3);
            if ((e3.token & 1073741824) !== 1073741824) {
              l2 = parseMemberOrUpdateExpression(e3, t3 | 16384, l2, 0, 0, r4, n3, s3);
              l2 = parseAssignmentExpression(e3, t3 | 16384, 0, 0, r4, n3, s3, l2);
              if (e3.token === 18) {
                l2 = parseSequenceExpression(e3, t3, 0, i2, o2, a2, l2);
              }
            }
          }
          return finishNode(e3, t3, i2, o2, a2, { type: "PropertyDefinition", key: r3, value: l2, static: (n2 & 32) > 0, computed: (n2 & 2) > 0, decorators: s2 });
        }
        function parseBindingPattern(e3, t3, r3, n2, s2, i2, o2, a2) {
          if (e3.token & 143360)
            return parseAndClassifyIdentifier(e3, t3, r3, n2, s2, i2, o2, a2);
          if ((e3.token & 2097152) !== 2097152)
            report(e3, 28, l[e3.token & 255]);
          const c2 = e3.token === 69271571 ? parseArrayExpressionOrPattern(e3, t3, r3, 1, 0, 1, n2, s2, i2, o2, a2) : parseObjectLiteralOrPattern(e3, t3, r3, 1, 0, 1, n2, s2, i2, o2, a2);
          if (e3.destructible & 16)
            report(e3, 47);
          if (e3.destructible & 32)
            report(e3, 47);
          return c2;
        }
        function parseAndClassifyIdentifier(e3, t3, r3, n2, s2, i2, o2, a2) {
          const { tokenValue: l2, token: c2 } = e3;
          if (t3 & 1024) {
            if ((c2 & 537079808) === 537079808) {
              report(e3, 115);
            } else if ((c2 & 36864) === 36864) {
              report(e3, 114);
            }
          }
          if ((c2 & 20480) === 20480) {
            report(e3, 99);
          }
          if (t3 & (2048 | 2097152) && c2 === 241773) {
            report(e3, 30);
          }
          if (c2 === 241739) {
            if (n2 & (8 | 16))
              report(e3, 97);
          }
          if (t3 & (4194304 | 2048) && c2 === 209008) {
            report(e3, 95);
          }
          nextToken(e3, t3);
          if (r3)
            addVarOrBlock(e3, t3, r3, l2, n2, s2);
          return finishNode(e3, t3, i2, o2, a2, { type: "Identifier", name: l2 });
        }
        function parseJSXRootElementOrFragment(e3, t3, r3, n2, s2, i2) {
          nextToken(e3, t3);
          if (e3.token === 8456259) {
            return finishNode(e3, t3, n2, s2, i2, { type: "JSXFragment", openingFragment: parseOpeningFragment(e3, t3, n2, s2, i2), children: parseJSXChildren(e3, t3), closingFragment: parseJSXClosingFragment(e3, t3, r3, e3.tokenPos, e3.linePos, e3.colPos) });
          }
          let o2 = null;
          let a2 = [];
          const l2 = parseJSXOpeningFragmentOrSelfCloseElement(e3, t3, r3, n2, s2, i2);
          if (!l2.selfClosing) {
            a2 = parseJSXChildren(e3, t3);
            o2 = parseJSXClosingElement(e3, t3, r3, e3.tokenPos, e3.linePos, e3.colPos);
            const n3 = isEqualTagName(o2.name);
            if (isEqualTagName(l2.name) !== n3)
              report(e3, 149, n3);
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "JSXElement", children: a2, openingElement: l2, closingElement: o2 });
        }
        function parseOpeningFragment(e3, t3, r3, n2, s2) {
          scanJSXToken(e3, t3);
          return finishNode(e3, t3, r3, n2, s2, { type: "JSXOpeningFragment" });
        }
        function parseJSXClosingElement(e3, t3, r3, n2, s2, i2) {
          consume(e3, t3, 25);
          const o2 = parseJSXElementName(e3, t3, e3.tokenPos, e3.linePos, e3.colPos);
          if (r3) {
            consume(e3, t3, 8456259);
          } else {
            e3.token = scanJSXToken(e3, t3);
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "JSXClosingElement", name: o2 });
        }
        function parseJSXClosingFragment(e3, t3, r3, n2, s2, i2) {
          consume(e3, t3, 25);
          if (r3) {
            consume(e3, t3, 8456259);
          } else {
            consume(e3, t3, 8456259);
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "JSXClosingFragment" });
        }
        function parseJSXChildren(e3, t3) {
          const r3 = [];
          while (e3.token !== 25) {
            e3.index = e3.tokenPos = e3.startPos;
            e3.column = e3.colPos = e3.startColumn;
            e3.line = e3.linePos = e3.startLine;
            scanJSXToken(e3, t3);
            r3.push(parseJSXChild(e3, t3, e3.tokenPos, e3.linePos, e3.colPos));
          }
          return r3;
        }
        function parseJSXChild(e3, t3, r3, n2, s2) {
          if (e3.token === 138)
            return parseJSXText(e3, t3, r3, n2, s2);
          if (e3.token === 2162700)
            return parseJSXExpressionContainer(e3, t3, 0, 0, r3, n2, s2);
          if (e3.token === 8456258)
            return parseJSXRootElementOrFragment(e3, t3, 0, r3, n2, s2);
          report(e3, 0);
        }
        function parseJSXText(e3, t3, r3, n2, s2) {
          scanJSXToken(e3, t3);
          const i2 = { type: "JSXText", value: e3.tokenValue };
          if (t3 & 512) {
            i2.raw = e3.tokenRaw;
          }
          return finishNode(e3, t3, r3, n2, s2, i2);
        }
        function parseJSXOpeningFragmentOrSelfCloseElement(e3, t3, r3, n2, s2, i2) {
          if ((e3.token & 143360) !== 143360 && (e3.token & 4096) !== 4096)
            report(e3, 0);
          const o2 = parseJSXElementName(e3, t3, e3.tokenPos, e3.linePos, e3.colPos);
          const a2 = parseJSXAttributes(e3, t3);
          const l2 = e3.token === 8457016;
          if (e3.token === 8456259) {
            scanJSXToken(e3, t3);
          } else {
            consume(e3, t3, 8457016);
            if (r3) {
              consume(e3, t3, 8456259);
            } else {
              scanJSXToken(e3, t3);
            }
          }
          return finishNode(e3, t3, n2, s2, i2, { type: "JSXOpeningElement", name: o2, attributes: a2, selfClosing: l2 });
        }
        function parseJSXElementName(e3, t3, r3, n2, s2) {
          scanJSXIdentifier(e3);
          let i2 = parseJSXIdentifier(e3, t3, r3, n2, s2);
          if (e3.token === 21)
            return parseJSXNamespacedName(e3, t3, i2, r3, n2, s2);
          while (consumeOpt(e3, t3, 67108877)) {
            scanJSXIdentifier(e3);
            i2 = parseJSXMemberExpression(e3, t3, i2, r3, n2, s2);
          }
          return i2;
        }
        function parseJSXMemberExpression(e3, t3, r3, n2, s2, i2) {
          const o2 = parseJSXIdentifier(e3, t3, e3.tokenPos, e3.linePos, e3.colPos);
          return finishNode(e3, t3, n2, s2, i2, { type: "JSXMemberExpression", object: r3, property: o2 });
        }
        function parseJSXAttributes(e3, t3) {
          const r3 = [];
          while (e3.token !== 8457016 && e3.token !== 8456259 && e3.token !== 1048576) {
            r3.push(parseJsxAttribute(e3, t3, e3.tokenPos, e3.linePos, e3.colPos));
          }
          return r3;
        }
        function parseJSXSpreadAttribute(e3, t3, r3, n2, s2) {
          nextToken(e3, t3);
          consume(e3, t3, 14);
          const i2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3, 1074790415);
          return finishNode(e3, t3, r3, n2, s2, { type: "JSXSpreadAttribute", argument: i2 });
        }
        function parseJsxAttribute(e3, t3, r3, n2, s2) {
          if (e3.token === 2162700)
            return parseJSXSpreadAttribute(e3, t3, r3, n2, s2);
          scanJSXIdentifier(e3);
          let i2 = null;
          let o2 = parseJSXIdentifier(e3, t3, r3, n2, s2);
          if (e3.token === 21) {
            o2 = parseJSXNamespacedName(e3, t3, o2, r3, n2, s2);
          }
          if (e3.token === 1077936157) {
            const r4 = scanJSXAttributeValue(e3, t3);
            const { tokenPos: n3, linePos: s3, colPos: o3 } = e3;
            switch (r4) {
              case 134283267:
                i2 = parseLiteral(e3, t3);
                break;
              case 8456258:
                i2 = parseJSXRootElementOrFragment(e3, t3, 1, n3, s3, o3);
                break;
              case 2162700:
                i2 = parseJSXExpressionContainer(e3, t3, 1, 1, n3, s3, o3);
                break;
              default:
                report(e3, 148);
            }
          }
          return finishNode(e3, t3, r3, n2, s2, { type: "JSXAttribute", value: i2, name: o2 });
        }
        function parseJSXNamespacedName(e3, t3, r3, n2, s2, i2) {
          consume(e3, t3, 21);
          const o2 = parseJSXIdentifier(e3, t3, e3.tokenPos, e3.linePos, e3.colPos);
          return finishNode(e3, t3, n2, s2, i2, { type: "JSXNamespacedName", namespace: r3, name: o2 });
        }
        function parseJSXExpressionContainer(e3, t3, r3, n2, s2, i2, o2) {
          nextToken(e3, t3 | 32768);
          const { tokenPos: a2, linePos: l2, colPos: c2 } = e3;
          if (e3.token === 14)
            return parseJSXSpreadChild(e3, t3, a2, l2, c2);
          let p2 = null;
          if (e3.token === 1074790415) {
            if (n2)
              report(e3, 151);
            p2 = parseJSXEmptyExpression(e3, t3, e3.startPos, e3.startLine, e3.startColumn);
          } else {
            p2 = parseExpression(e3, t3, 1, 0, 0, a2, l2, c2);
          }
          if (r3) {
            consume(e3, t3, 1074790415);
          } else {
            scanJSXToken(e3, t3);
          }
          return finishNode(e3, t3, s2, i2, o2, { type: "JSXExpressionContainer", expression: p2 });
        }
        function parseJSXSpreadChild(e3, t3, r3, n2, s2) {
          consume(e3, t3, 14);
          const i2 = parseExpression(e3, t3, 1, 0, 0, e3.tokenPos, e3.linePos, e3.colPos);
          consume(e3, t3, 1074790415);
          return finishNode(e3, t3, r3, n2, s2, { type: "JSXSpreadChild", expression: i2 });
        }
        function parseJSXEmptyExpression(e3, t3, r3, n2, s2) {
          e3.startPos = e3.tokenPos;
          e3.startLine = e3.linePos;
          e3.startColumn = e3.colPos;
          return finishNode(e3, t3, r3, n2, s2, { type: "JSXEmptyExpression" });
        }
        function parseJSXIdentifier(e3, t3, r3, n2, s2) {
          const { tokenValue: i2 } = e3;
          nextToken(e3, t3);
          return finishNode(e3, t3, r3, n2, s2, { type: "JSXIdentifier", name: i2 });
        }
        var d = Object.freeze({ __proto__: null });
        var h = "4.2.1";
        const m = h;
        function parseScript(e3, t3) {
          return parseSource(e3, t3, 0);
        }
        function parseModule(e3, t3) {
          return parseSource(e3, t3, 1024 | 2048);
        }
        function parse2(e3, t3) {
          return parseSource(e3, t3, 0);
        }
        t2.ESTree = d;
        t2.parse = parse2;
        t2.parseModule = parseModule;
        t2.parseScript = parseScript;
        t2.version = m;
      }, 389: (e2) => {
        "use strict";
        e2.exports = { version: "4.3.0" };
      } };
      var t = {};
      function __nccwpck_require__(r2) {
        var n = t[r2];
        if (n !== void 0) {
          return n.exports;
        }
        var s = t[r2] = { exports: {} };
        var i = true;
        try {
          e[r2].call(s.exports, s, s.exports, __nccwpck_require__);
          i = false;
        } finally {
          if (i)
            delete t[r2];
        }
        return s.exports;
      }
      if (typeof __nccwpck_require__ !== "undefined")
        __nccwpck_require__.ab = __dirname + "/";
      var r = __nccwpck_require__(144);
      module2.exports = r;
    })();
  }
});

// node_modules/ts-md5/dist/cjs/md5.js
var require_md5 = __commonJS({
  "node_modules/ts-md5/dist/cjs/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Md5 = void 0;
    var Md53 = (
      /** @class */
      function() {
        function Md54() {
          this._dataLength = 0;
          this._bufferLength = 0;
          this._state = new Int32Array(4);
          this._buffer = new ArrayBuffer(68);
          this._buffer8 = new Uint8Array(this._buffer, 0, 68);
          this._buffer32 = new Uint32Array(this._buffer, 0, 17);
          this.start();
        }
        Md54.hashStr = function(str, raw) {
          if (raw === void 0) {
            raw = false;
          }
          return this.onePassHasher.start().appendStr(str).end(raw);
        };
        Md54.hashAsciiStr = function(str, raw) {
          if (raw === void 0) {
            raw = false;
          }
          return this.onePassHasher.start().appendAsciiStr(str).end(raw);
        };
        Md54._hex = function(x) {
          var hc = Md54.hexChars;
          var ho = Md54.hexOut;
          var n;
          var offset;
          var j;
          var i;
          for (i = 0; i < 4; i += 1) {
            offset = i * 8;
            n = x[i];
            for (j = 0; j < 8; j += 2) {
              ho[offset + 1 + j] = hc.charAt(n & 15);
              n >>>= 4;
              ho[offset + 0 + j] = hc.charAt(n & 15);
              n >>>= 4;
            }
          }
          return ho.join("");
        };
        Md54._md5cycle = function(x, k) {
          var a = x[0];
          var b = x[1];
          var c = x[2];
          var d = x[3];
          a += (b & c | ~b & d) + k[0] - 680876936 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[1] - 389564586 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[2] + 606105819 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[4] - 176418897 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[7] - 45705983 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[10] - 42063 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
          a = (a << 7 | a >>> 25) + b | 0;
          d += (a & b | ~a & c) + k[13] - 40341101 | 0;
          d = (d << 12 | d >>> 20) + a | 0;
          c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
          c = (c << 17 | c >>> 15) + d | 0;
          b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
          b = (b << 22 | b >>> 10) + c | 0;
          a += (b & d | c & ~d) + k[1] - 165796510 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[11] + 643717713 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[0] - 373897302 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[5] - 701558691 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[10] + 38016083 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[15] - 660478335 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[4] - 405537848 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[9] + 568446438 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[3] - 187363961 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
          a = (a << 5 | a >>> 27) + b | 0;
          d += (a & c | b & ~c) + k[2] - 51403784 | 0;
          d = (d << 9 | d >>> 23) + a | 0;
          c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
          c = (c << 14 | c >>> 18) + d | 0;
          b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
          b = (b << 20 | b >>> 12) + c | 0;
          a += (b ^ c ^ d) + k[5] - 378558 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[14] - 35309556 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[7] - 155497632 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[13] + 681279174 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[0] - 358537222 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[3] - 722521979 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[6] + 76029189 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (b ^ c ^ d) + k[9] - 640364487 | 0;
          a = (a << 4 | a >>> 28) + b | 0;
          d += (a ^ b ^ c) + k[12] - 421815835 | 0;
          d = (d << 11 | d >>> 21) + a | 0;
          c += (d ^ a ^ b) + k[15] + 530742520 | 0;
          c = (c << 16 | c >>> 16) + d | 0;
          b += (c ^ d ^ a) + k[2] - 995338651 | 0;
          b = (b << 23 | b >>> 9) + c | 0;
          a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
          a = (a << 6 | a >>> 26) + b | 0;
          d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
          d = (d << 10 | d >>> 22) + a | 0;
          c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
          c = (c << 15 | c >>> 17) + d | 0;
          b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
          b = (b << 21 | b >>> 11) + c | 0;
          x[0] = a + x[0] | 0;
          x[1] = b + x[1] | 0;
          x[2] = c + x[2] | 0;
          x[3] = d + x[3] | 0;
        };
        Md54.prototype.start = function() {
          this._dataLength = 0;
          this._bufferLength = 0;
          this._state.set(Md54.stateIdentity);
          return this;
        };
        Md54.prototype.appendStr = function(str) {
          var buf8 = this._buffer8;
          var buf32 = this._buffer32;
          var bufLen = this._bufferLength;
          var code;
          var i;
          for (i = 0; i < str.length; i += 1) {
            code = str.charCodeAt(i);
            if (code < 128) {
              buf8[bufLen++] = code;
            } else if (code < 2048) {
              buf8[bufLen++] = (code >>> 6) + 192;
              buf8[bufLen++] = code & 63 | 128;
            } else if (code < 55296 || code > 56319) {
              buf8[bufLen++] = (code >>> 12) + 224;
              buf8[bufLen++] = code >>> 6 & 63 | 128;
              buf8[bufLen++] = code & 63 | 128;
            } else {
              code = (code - 55296) * 1024 + (str.charCodeAt(++i) - 56320) + 65536;
              if (code > 1114111) {
                throw new Error("Unicode standard supports code points up to U+10FFFF");
              }
              buf8[bufLen++] = (code >>> 18) + 240;
              buf8[bufLen++] = code >>> 12 & 63 | 128;
              buf8[bufLen++] = code >>> 6 & 63 | 128;
              buf8[bufLen++] = code & 63 | 128;
            }
            if (bufLen >= 64) {
              this._dataLength += 64;
              Md54._md5cycle(this._state, buf32);
              bufLen -= 64;
              buf32[0] = buf32[16];
            }
          }
          this._bufferLength = bufLen;
          return this;
        };
        Md54.prototype.appendAsciiStr = function(str) {
          var buf8 = this._buffer8;
          var buf32 = this._buffer32;
          var bufLen = this._bufferLength;
          var i;
          var j = 0;
          for (; ; ) {
            i = Math.min(str.length - j, 64 - bufLen);
            while (i--) {
              buf8[bufLen++] = str.charCodeAt(j++);
            }
            if (bufLen < 64) {
              break;
            }
            this._dataLength += 64;
            Md54._md5cycle(this._state, buf32);
            bufLen = 0;
          }
          this._bufferLength = bufLen;
          return this;
        };
        Md54.prototype.appendByteArray = function(input) {
          var buf8 = this._buffer8;
          var buf32 = this._buffer32;
          var bufLen = this._bufferLength;
          var i;
          var j = 0;
          for (; ; ) {
            i = Math.min(input.length - j, 64 - bufLen);
            while (i--) {
              buf8[bufLen++] = input[j++];
            }
            if (bufLen < 64) {
              break;
            }
            this._dataLength += 64;
            Md54._md5cycle(this._state, buf32);
            bufLen = 0;
          }
          this._bufferLength = bufLen;
          return this;
        };
        Md54.prototype.getState = function() {
          var s = this._state;
          return {
            buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
            buflen: this._bufferLength,
            length: this._dataLength,
            state: [s[0], s[1], s[2], s[3]]
          };
        };
        Md54.prototype.setState = function(state) {
          var buf = state.buffer;
          var x = state.state;
          var s = this._state;
          var i;
          this._dataLength = state.length;
          this._bufferLength = state.buflen;
          s[0] = x[0];
          s[1] = x[1];
          s[2] = x[2];
          s[3] = x[3];
          for (i = 0; i < buf.length; i += 1) {
            this._buffer8[i] = buf.charCodeAt(i);
          }
        };
        Md54.prototype.end = function(raw) {
          if (raw === void 0) {
            raw = false;
          }
          var bufLen = this._bufferLength;
          var buf8 = this._buffer8;
          var buf32 = this._buffer32;
          var i = (bufLen >> 2) + 1;
          this._dataLength += bufLen;
          var dataBitsLen = this._dataLength * 8;
          buf8[bufLen] = 128;
          buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
          buf32.set(Md54.buffer32Identity.subarray(i), i);
          if (bufLen > 55) {
            Md54._md5cycle(this._state, buf32);
            buf32.set(Md54.buffer32Identity);
          }
          if (dataBitsLen <= 4294967295) {
            buf32[14] = dataBitsLen;
          } else {
            var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
            if (matches === null) {
              return;
            }
            var lo = parseInt(matches[2], 16);
            var hi = parseInt(matches[1], 16) || 0;
            buf32[14] = lo;
            buf32[15] = hi;
          }
          Md54._md5cycle(this._state, buf32);
          return raw ? this._state : Md54._hex(this._state);
        };
        Md54.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
        Md54.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        Md54.hexChars = "0123456789abcdef";
        Md54.hexOut = [];
        Md54.onePassHasher = new Md54();
        return Md54;
      }()
    );
    exports.Md5 = Md53;
    if (Md53.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
      throw new Error("Md5 self test failed.");
    }
  }
});

// node_modules/ts-md5/dist/cjs/md5_file_hasher.js
var require_md5_file_hasher = __commonJS({
  "node_modules/ts-md5/dist/cjs/md5_file_hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Md5FileHasher = void 0;
    var md5_1 = require_md5();
    var Md5FileHasher = (
      /** @class */
      function() {
        function Md5FileHasher2(_callback, _async, _partSize) {
          if (_async === void 0) {
            _async = true;
          }
          if (_partSize === void 0) {
            _partSize = 1048576;
          }
          this._callback = _callback;
          this._async = _async;
          this._partSize = _partSize;
          this._configureReader();
        }
        Md5FileHasher2.prototype.hash = function(blob) {
          var self2 = this;
          self2._blob = blob;
          self2._part = 0;
          self2._md5 = new md5_1.Md5();
          self2._processPart();
        };
        Md5FileHasher2.prototype._fail = function() {
          this._callback({
            success: false,
            result: "data read failed"
          });
        };
        Md5FileHasher2.prototype._hashData = function(e) {
          var self2 = this;
          self2._md5.appendByteArray(new Uint8Array(e.target.result));
          if (self2._part * self2._partSize >= self2._blob.size) {
            self2._callback({
              success: true,
              result: self2._md5.end()
            });
          } else {
            self2._processPart();
          }
        };
        Md5FileHasher2.prototype._processPart = function() {
          var self2 = this;
          var endbyte = 0;
          var current_part;
          self2._part += 1;
          if (self2._blob.size > self2._partSize) {
            endbyte = self2._part * self2._partSize;
            if (endbyte > self2._blob.size) {
              endbyte = self2._blob.size;
            }
            current_part = self2._blob.slice((self2._part - 1) * self2._partSize, endbyte);
          } else {
            current_part = self2._blob;
          }
          if (self2._async) {
            self2._reader.readAsArrayBuffer(current_part);
          } else {
            setTimeout(function() {
              try {
                self2._hashData({
                  target: {
                    result: self2._reader.readAsArrayBuffer(current_part)
                  }
                });
              } catch (e) {
                self2._fail();
              }
            }, 0);
          }
        };
        Md5FileHasher2.prototype._configureReader = function() {
          var self2 = this;
          if (self2._async) {
            self2._reader = new FileReader();
            self2._reader.onload = self2._hashData.bind(self2);
            self2._reader.onerror = self2._fail.bind(self2);
            self2._reader.onabort = self2._fail.bind(self2);
          } else {
            self2._reader = new FileReaderSync();
          }
        };
        return Md5FileHasher2;
      }()
    );
    exports.Md5FileHasher = Md5FileHasher;
  }
});

// node_modules/ts-md5/dist/cjs/parallel_hasher.js
var require_parallel_hasher = __commonJS({
  "node_modules/ts-md5/dist/cjs/parallel_hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParallelHasher = void 0;
    var ParallelHasher = (
      /** @class */
      function() {
        function ParallelHasher2(workerUri, workerOptions) {
          this._queue = [];
          this._ready = true;
          var self2 = this;
          if (Worker) {
            self2._hashWorker = new Worker(workerUri, workerOptions);
            self2._hashWorker.onmessage = self2._recievedMessage.bind(self2);
            self2._hashWorker.onerror = function(err) {
              self2._ready = false;
              console.error("Hash worker failure", err);
            };
          } else {
            self2._ready = false;
            console.error("Web Workers are not supported in this browser");
          }
        }
        ParallelHasher2.prototype.hash = function(blob) {
          var self2 = this;
          var promise;
          promise = new Promise(function(resolve, reject2) {
            self2._queue.push({
              blob,
              resolve,
              reject: reject2
            });
            self2._processNext();
          });
          return promise;
        };
        ParallelHasher2.prototype.terminate = function() {
          this._ready = false;
          this._hashWorker.terminate();
        };
        ParallelHasher2.prototype._processNext = function() {
          if (this._ready && !this._processing && this._queue.length > 0) {
            this._processing = this._queue.pop();
            this._hashWorker.postMessage(this._processing.blob);
          }
        };
        ParallelHasher2.prototype._recievedMessage = function(evt) {
          var _a3, _b2;
          var data = evt.data;
          if (data.success) {
            (_a3 = this._processing) === null || _a3 === void 0 ? void 0 : _a3.resolve(data.result);
          } else {
            (_b2 = this._processing) === null || _b2 === void 0 ? void 0 : _b2.reject(data.result);
          }
          this._processing = void 0;
          this._processNext();
        };
        return ParallelHasher2;
      }()
    );
    exports.ParallelHasher = ParallelHasher;
  }
});

// node_modules/ts-md5/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/ts-md5/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParallelHasher = exports.Md5FileHasher = exports.Md5 = void 0;
    var md5_1 = require_md5();
    Object.defineProperty(exports, "Md5", { enumerable: true, get: function() {
      return md5_1.Md5;
    } });
    var md5_file_hasher_1 = require_md5_file_hasher();
    Object.defineProperty(exports, "Md5FileHasher", { enumerable: true, get: function() {
      return md5_file_hasher_1.Md5FileHasher;
    } });
    var parallel_hasher_1 = require_parallel_hasher();
    Object.defineProperty(exports, "ParallelHasher", { enumerable: true, get: function() {
      return parallel_hasher_1.ParallelHasher;
    } });
  }
});

// node_modules/markdown-it/node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/markdown-it/node_modules/entities/lib/maps/entities.json"(exports, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module2) {
    "use strict";
    module2.exports = require_entities();
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module2) {
    module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module2) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      var i, l, code, nextCode, cache, result2 = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);
        if (keepEscaped && code === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result2 += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code < 128) {
          result2 += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result2 += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result2 += "%EF%BF%BD";
          continue;
        }
        result2 += encodeURIComponent(string[i]);
      }
      return result2;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    module2.exports = encode;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module2) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l, b1, b2, b3, b4, chr, result2 = "";
        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result2 += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result2 += "\uFFFD\uFFFD";
              } else {
                result2 += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result2 += "\uFFFD\uFFFD\uFFFD";
              } else {
                result2 += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result2 += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result2 += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result2 += "\uFFFD";
        }
        return result2;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module2.exports = decode;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module2) {
    "use strict";
    module2.exports = function format(url) {
      var result2 = "";
      result2 += url.protocol || "";
      result2 += url.slashes ? "//" : "";
      result2 += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result2 += "[" + url.hostname + "]";
      } else {
        result2 += url.hostname || "";
      }
      result2 += url.port ? ":" + url.port : "";
      result2 += url.pathname || "";
      result2 += url.search || "";
      result2 += url.hash || "";
      return result2;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module2) {
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes, rest2 = url;
      rest2 = rest2.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest2);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest2);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest2 = rest2.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest2.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest2 = rest2.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest2.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest2.lastIndexOf("@");
        } else {
          atSign = rest2.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest2.slice(0, atSign);
          rest2 = rest2.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest2.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest2.length;
        }
        if (rest2[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest2.slice(0, hostEnd);
        rest2 = rest2.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest2 = notHost.join(".") + rest2;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest2.indexOf("#");
      if (hash !== -1) {
        this.hash = rest2.substr(hash);
        rest2 = rest2.slice(0, hash);
      }
      var qm = rest2.indexOf("?");
      if (qm !== -1) {
        this.search = rest2.substr(qm);
        rest2 = rest2.slice(0, qm);
      }
      if (rest2) {
        this.pathname = rest2;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module2.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module2) {
    "use strict";
    module2.exports.encode = require_encode();
    module2.exports.decode = require_decode();
    module2.exports.format = require_format();
    module2.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module2) {
    module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module2) {
    module2.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module2) {
    module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module2) {
    module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has3(object2, key) {
      return _hasOwnProperty.call(object2, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
    var entities = require_entities2();
    function replaceEntityPattern(match2, name) {
      var code;
      if (has3(entities, name)) {
        return entities[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match2;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match2, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(/ẞ/g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign;
    exports.isString = isString;
    exports.has = has3;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module2) {
    "use strict";
    module2.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max2) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkDestination(str, start, max2) {
      var code, level, pos = start, result2 = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max2) {
          code = str.charCodeAt(pos);
          if (code === 10) {
            return result2;
          }
          if (code === 60) {
            return result2;
          }
          if (code === 62) {
            result2.pos = pos + 1;
            result2.str = unescapeAll(str.slice(start + 1, pos));
            result2.ok = true;
            return result2;
          }
          if (code === 92 && pos + 1 < max2) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result2;
      }
      level = 0;
      while (pos < max2) {
        code = str.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max2) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
          if (level > 32) {
            return result2;
          }
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result2;
      }
      if (level !== 0) {
        return result2;
      }
      result2.str = unescapeAll(str.slice(start, pos));
      result2.pos = pos;
      result2.ok = true;
      return result2;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module2) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module2.exports = function parseLinkTitle(str, start, max2) {
      var code, marker, lines = 0, pos = start, result2 = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max2) {
        return result2;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result2;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max2) {
        code = str.charCodeAt(pos);
        if (code === marker) {
          result2.pos = pos + 1;
          result2.lines = lines;
          result2.str = unescapeAll(str.slice(start + 1, pos));
          result2.ok = true;
          return result2;
        } else if (code === 40 && marker === 41) {
          return result2;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max2) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result2;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module2) {
    "use strict";
    var assign = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result2;
      if (!token.attrs) {
        return "";
      }
      result2 = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result2 += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result2;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result2 = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result2 += "\n";
      }
      result2 += (token.nesting === -1 ? "</" : "<") + token.tag;
      result2 += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result2 += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result2 += needLf ? ">\n" : ">";
      return result2;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type, result2 = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result2 += rules[type](tokens, i, options, env, this);
        } else {
          result2 += this.renderToken(tokens, i, options);
        }
      }
      return result2;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result2 = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result2 += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result2 += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result2 += "\n";
        }
      }
      return result2;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i, len, type, result2 = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (type === "inline") {
          result2 += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result2 += rules[type](tokens, i, options, env, this);
        } else {
          result2 += this.renderToken(tokens, i, options, env);
        }
      }
      return result2;
    };
    module2.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module2) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain2) {
        self2.__cache__[chain2] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain2 && rule.alt.indexOf(chain2) < 0) {
            return;
          }
          self2.__cache__[chain2].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result2 = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result2.push(name);
      }, this);
      this.__cache__ = null;
      return result2;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result2 = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result2.push(name);
      }, this);
      this.__cache__ = null;
      return result2;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module2.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module2) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module2.exports = function normalize3(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module2) {
    "use strict";
    module2.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module2) {
    "use strict";
    module2.exports = function inline(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module2) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module2.exports = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module2) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match2, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module2.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module2) {
    "use strict";
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text, t, pos, max2, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max2 = text.length;
        OUTER:
          while (pos < max2) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text.charCodeAt(t.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max2) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max2 = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    module2.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/markdown-it/lib/rules_core/text_join.js"(exports, module2) {
    "use strict";
    module2.exports = function text_join(state) {
      var j, l, tokens, curr, max2, last2, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max2 = tokens.length;
        for (curr = 0; curr < max2; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last2 = 0; curr < max2; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last2) {
              tokens[last2] = tokens[curr];
            }
            last2++;
          }
        }
        if (curr !== last2) {
          tokens.length = last2;
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module2) {
    "use strict";
    function Token2(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token2.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token2.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token2.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token2.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token2.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module2.exports = Token2;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module2) {
    "use strict";
    var Token2 = require_token();
    function StateCore(src, md2, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md2;
    }
    StateCore.prototype.Token = Token2;
    module2.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", require_text_join()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module2.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max2 = state.eMarks[line];
      return state.src.slice(pos, max2);
    }
    function escapedSplit(str) {
      var result2 = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max2) {
        if (ch === 124) {
          if (!isEscaped) {
            result2.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result2.push(current + str.substring(lastPos));
      return result2;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module2) {
    "use strict";
    module2.exports = function code(state, startLine, endLine) {
      var nextLine, last2, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last2 = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last2 = nextLine;
          continue;
        }
        break;
      }
      state.line = last2;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module2) {
    "use strict";
    module2.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max2) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max2);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max2) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial2, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldBMarks = [];
      oldBSCount = [];
      oldSCount = [];
      oldTShift = [];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos >= max2) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial2 = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial2++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + initial2) % 4 === 3) {
              pos++;
              initial2++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          offset = initial2;
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max2;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial2;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max2, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max2 = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max2 = state.eMarks[startLine];
      if (pos + 1 >= max2) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max2) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module2.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial2, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max2, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, nextLine = startLine, isTerminatingParagraph = false, tight = true;
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[nextLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
          return false;
      }
      if (silent) {
        return true;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [nextLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max2 = state.eMarks[nextLine];
        initial2 = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
        while (pos < max2) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max2) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial2;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial2 + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [nextLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[nextLine];
        oldSCount = state.sCount[nextLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
        state.sCount[nextLine] = offset;
        if (contentStart >= max2 && state.isEmpty(nextLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, nextLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[nextLine] = oldTShift;
        state.sCount[nextLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = state.line;
        itemLines[1] = nextLine;
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max2) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max2) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max2 = str.length;
      for (pos = 1; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max2 && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max2);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max2);
      if (pos < max2 && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max2) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max2) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module2) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module2.exports.HTML_TAG_RE = HTML_TAG_RE;
    module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module2) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module2.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max2);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max2);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max2) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max2 && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max2 && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max2 = state.skipSpacesBack(max2, pos);
      tmp = state.skipCharsBack(max2, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max2 = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max2).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module2) {
    "use strict";
    module2.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max2, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          if (pos < max2) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max2) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module2) {
    "use strict";
    module2.exports = function paragraph(state, startLine, endLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module2) {
    "use strict";
    var Token2 = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md2, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md2;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token2(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty2(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max2 = this.lineMax; from < max2; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max2 = this.src.length; pos < max2; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min2) {
      if (pos <= min2) {
        return pos;
      }
      while (pos > min2) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max2 = this.src.length; pos < max2; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min2) {
      if (pos <= min2) {
        return pos;
      }
      while (pos > min2) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first2, last2, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first2 = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last2 = this.eMarks[line] + 1;
        } else {
          last2 = this.eMarks[line];
        }
        while (first2 < last2 && lineIndent < indent) {
          ch = this.src.charCodeAt(first2);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first2 - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first2++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last2);
        } else {
          queue[i] = this.src.slice(first2, last2);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token2;
    module2.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, prevLine, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        prevLine = state.line;
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            if (prevLine >= state.line) {
              throw new Error("block rule didn't increment state.line");
            }
            break;
          }
        }
        if (!ok)
          throw new Error("none of the block rules matched");
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md2, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md2, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module2.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module2) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module2.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/linkify.js"(exports, module2) {
    "use strict";
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module2.exports = function linkify(state, silent) {
      var pos, max2, match2, proto, link, url, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max2 = state.posMax;
      if (pos + 3 > max2)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match2 = state.pending.match(SCHEME_RE);
      if (!match2)
        return false;
      proto = match2[1];
      link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link)
        return false;
      url = link.url;
      if (url.length <= proto.length)
        return false;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module2.exports = function newline(state, silent) {
      var pmax, max2, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max2 = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module2) {
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module2.exports = function escape2(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max2)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max2) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max2) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module2) {
    "use strict";
    module2.exports = function backtick(state, silent) {
      var start, max2, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max2 = state.posMax;
      while (pos < max2 && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max2 = delimiters.length;
      for (i = 0; i < max2; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module2.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module2) {
    "use strict";
    module2.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max2 = delimiters.length;
      for (i = max2 - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module2.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max2 = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max2; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max2; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max2 && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max2; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module2) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module2.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max2; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max2; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max2 && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max2; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module2) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module2.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start, max2, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max2 = state.posMax;
      for (; ; ) {
        if (++pos >= max2)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module2) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module2.exports = function html_inline(state, silent) {
      var ch, match2, max2, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match2 = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match2) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = match2[0];
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match2[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module2) {
    "use strict";
    var entities = require_entities2();
    var has3 = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module2.exports = function entity(state, silent) {
      var ch, code, match2, token, pos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max2)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match2 = state.src.slice(pos).match(DIGITAL_RE);
        if (match2) {
          if (!silent) {
            code = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            token.markup = match2[0];
            token.info = "entity";
          }
          state.pos += match2[0].length;
          return true;
        }
      } else {
        match2 = state.src.slice(pos).match(NAMED_RE);
        if (match2) {
          if (has3(entities, match2[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities[match2[1]];
              token.markup = match2[0];
              token.info = "entity";
            }
            state.pos += match2[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module2) {
    "use strict";
    function processDelimiters(delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;
      if (!max2)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max2; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module2.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      processDelimiters(state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports, module2) {
    "use strict";
    module2.exports = function fragments_join(state) {
      var curr, last2, level = 0, tokens = state.tokens, max2 = state.tokens.length;
      for (curr = last2 = 0; curr < max2; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last2) {
            tokens[last2] = tokens[curr];
          }
          last2++;
        }
      }
      if (curr !== last2) {
        tokens.length = last2;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module2) {
    "use strict";
    var Token2 = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md2, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md2;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token2("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token2(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max2 && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token2;
    module2.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["linkify", require_linkify2()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            if (pos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, prevPos, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        prevPos = state.pos;
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              if (prevPos >= state.pos) {
                throw new Error("inline rule didn't increment state.pos");
              }
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md2, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md2, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module2.exports = ParserInline;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module2) {
    "use strict";
    module2.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module2) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match2, self2) {
        self2.normalize(match2);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match2 = new Match(self2, shift);
      self2.__compiled__[match2.schema].normalize(match2, self2);
      return match2;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match2(text) {
      var shift = 0, result2 = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result2.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result2.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result2.length) {
        return result2;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      var m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      var len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize3(match2) {
      if (!match2.schema) {
        match2.url = "http://" + match2.url;
      }
      if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
        match2.url = "mailto:" + match2.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require("punycode");
    var config = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt2(presetName, options) {
      if (!(this instanceof MarkdownIt2)) {
        return new MarkdownIt2(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt2.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt2.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt2.prototype.enable = function(list, ignoreInvalid) {
      var result2 = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain2) {
        result2 = result2.concat(this[chain2].ruler.enable(list, true));
      }, this);
      result2 = result2.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name) {
        return result2.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt2.prototype.disable = function(list, ignoreInvalid) {
      var result2 = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain2) {
        result2 = result2.concat(this[chain2].ruler.disable(list, true));
      }, this);
      result2 = result2.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name) {
        return result2.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt2.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt2.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt2.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt2.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt2.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module2.exports = MarkdownIt2;
  }
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib();
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const { type, value } = formatted[i];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined2(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s2) {
        return this.isValidZone(s2);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f) {
      const ms = [];
      for (let i = 1; i <= 12; i++) {
        const dt = DateTime.utc(2016, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays(f) {
      const ms = [];
      for (let i = 1; i <= 7; i++) {
        const dt = DateTime.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      const mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        let z = void 0;
        if (dt.zone.isUniversal) {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false, defaultOK = true) {
        return listStuff(this, length, defaultOK, months, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false, defaultOK = true) {
        return listStuff(this, length, defaultOK, weekdays, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems(defaultOK = true) {
        return listStuff(
          this,
          void 0,
          defaultOK,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length, defaultOK = true) {
        return listStuff(this, length, defaultOK, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s2) {
        if (s2) {
          const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone(signedOffset(r[1], r[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined2(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n2) {
        now = n2;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t) {
        throwOnInvalid = t;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined2(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys2) {
      return keys2.reduce((a, k) => {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart(input, n2 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n2, "0");
      } else {
        padded = ("" + input).padStart(n2, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined2(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      return +d;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last2 = weekYear - 1, p2 = (last2 + Math.floor(last2 / 4) - Math.floor(last2 / 100) + Math.floor(last2 / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u in obj) {
        if (hasOwnProperty2(obj, u)) {
          const v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s2 = "";
      for (const token of splits) {
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class {
      static create(locale, opts = {}) {
        return new Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i = 0; i < fmt.length; i++) {
          const c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed, val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: false, val: currentFull });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      formatDateTime(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      formatDateTimeParts(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.formatToParts();
      }
      formatInterval(interval, opts = {}) {
        const df = this.loc.dtFormatter(interval.start, { ...this.opts, ...opts });
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts = {}) {
        const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.resolvedOptions();
      }
      num(n2, p = 0) {
        if (this.opts.forceSimple) {
          return padStart(n2, p);
        }
        const opts = { ...this.opts };
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n2);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f, r) => f + r.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse2(s2, ...patterns) {
      if (s2 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys2) {
      return (match3, cursor) => {
        const ret = {};
        let i;
        for (i = 0; i < keys2.length; i++) {
          ret[keys2[i]] = parseInteger(match3[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int(match3, pos, fallback) {
      const m = match3[pos];
      return isUndefined2(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match3, cursor) {
      const item = {
        year: int(match3, cursor),
        month: int(match3, cursor + 1, 1),
        day: int(match3, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match3, cursor) {
      const item = {
        hours: int(match3, cursor, 0),
        minutes: int(match3, cursor + 1, 0),
        seconds: int(match3, cursor + 2, 0),
        milliseconds: parseMillis(match3[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match3, cursor) {
      const local = !match3[cursor] && !match3[cursor + 1], fullOffset = signedOffset(match3[cursor + 1], match3[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match3, cursor) {
      const zone = match3[cursor] ? IANAZone.create(match3[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match3) {
      const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match3;
      const hasNegativePrefix = s2[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result2 = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result2.second = parseInteger(secondStr);
      if (weekdayStr) {
        result2.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result2;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match3) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match3, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result2, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match3) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match3, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result2, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match3) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match3, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result2, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s2) {
      return parse2(
        s2,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s2) {
      return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse2(
        s2,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s2) {
      return parse2(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s2) {
      return parse2(
        s2,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function antiTrunc(n2) {
      return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
    }
    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix, vals) {
      reverseUnits.reduce((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config.matrix) {
          matrix = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        const l2 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined2(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n2) => n2);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s2 = "P";
        if (this.years !== 0)
          s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s2 += this.weeks + "W";
        if (this.days !== 0)
          s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s2 += "T";
        if (this.hours !== 0)
          s2 += this.hours + "H";
        if (this.minutes !== 0)
          s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P")
          s2 += "T0S";
        return s2;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts
        };
        const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        let str = value.toFormat(fmt);
        if (opts.includePrefix) {
          str = "T" + str;
        }
        return str;
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        return this.as("milliseconds");
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result2 = {};
        for (const k of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
            result2[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$1(this, { values: result2 }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result2 = {};
        for (const k of Object.keys(this.values)) {
          result2[k] = asNumber(fn(this.values[k], k));
        }
        return clone$1(this, { values: result2 }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values2) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject(values2, Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u) => Duration.normalizeUnit(u));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k of orderedUnits$1) {
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            const i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
            for (const down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            }
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone$1(this, { values: built }, true).normalize();
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k of Object.keys(this.values)) {
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq2(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u of orderedUnits$1) {
          if (!eq2(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s2, e] = (text || "").split("/", 2);
        if (s2 && e) {
          let start, startIsValid;
          try {
            start = DateTime.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s2, opts);
            if (dur.isValid) {
              return Interval.before(end, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
        let { s: s2 } = this, i = 0;
        while (s2 < this.e) {
          const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s2 } = this, idx = 1, next;
        const results = [];
        while (s2 < this.e) {
          const added = this.start.plus(dur.mapUnits((x) => x * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return Interval.fromDateTimes(s2, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s2, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i) => [
          { time: i.s, type: "s" },
          { time: i.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
        for (const i of arr) {
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a, b) => b.year - a.year],
        ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
        ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
        [
          "weeks",
          (a, b) => {
            const days = dayDiff(a, b);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min2, max2] = numberingSystemsUTF16[key];
              if (code >= min2 && code <= max2) {
                value += code - min2;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i) => i) {
      return { regex, deser: ([s2]) => post(parseDigits(s2)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s2]) => s2 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts) {
      const { type, value } = part;
      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      const style = formatOpts[type];
      let val = partTypeStyleToTokenVal[type];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
      return [`^${re}$`, units];
    }
    function match2(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i in handlers) {
          if (hasOwnProperty2(handlers, i)) {
            const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined2(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined2(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined2(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined2(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined2(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r, k) => {
        const f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
    }
    function explainFromTokens(locale, input, format) {
      const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match2(input, regex, handlers), [result2, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result: result2, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format) {
      const { result: result2, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
      return [result2, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const parts = formatter.formatDateTimeParts(getDummyDateTime());
      return parts.map((p) => tokenForPart(p, formatOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      const js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(weekData) };
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return { year, ordinal, ...timeObject(gregData) };
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(ordinalData) };
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime({ ...current, ...alts, old: current });
    }
    function fixOffset(localTS, o, tz) {
      let utcGuess = localTS - o * 60 * 1e3;
      const o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      let [ts, o] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return { ts, o };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0) {
        const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(
          new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat(dt, format, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate(o, extended) {
      const longFormat = o.c.year > 9999 || o.c.year < 0;
      let c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart(o.c.month);
        c += "-";
        c += padStart(o.c.day);
      } else {
        c += padStart(o.c.month);
        c += padStart(o.c.day);
      }
      return c;
    }
    function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c = padStart(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart(o.c.minute);
        if (o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart(o.c.minute);
      }
      if (o.c.second !== 0 || !suppressSeconds) {
        c += padStart(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart(Math.trunc(o.o / 60));
          c += ":";
          c += padStart(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o;
      if (!isUndefined2(obj.year)) {
        for (const u of orderedUnits) {
          if (isUndefined2(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime({ ts, zone, loc, o });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined2(opts.round) ? true : opts.round, format = (c, unit) => {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime = class {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings.defaultZone;
        let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined2(config.ts) ? Settings.now() : config.ts;
        let c = null, o = null;
        if (!invalid) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c, o] = [config.old.c, config.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime.invalid("Timestamp out of range");
        } else {
          return new DateTime({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u of units) {
          const v = normalized[u];
          if (!isUndefined2(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined2(text) || isUndefined2(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
        if (invalid) {
          return DateTime.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t) => t.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values2) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values2, normalizeUnit), settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
        } else if (!isUndefined2(normalized.ordinal)) {
          mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined2(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o] = objToTS(mixed, this.o, this.zone);
        return clone2(this, { ts, o });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext2 = format === "extended";
        let c = toISODate(this, ext2);
        c += "T";
        c += toISOTime(this, ext2, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c = includePrefix ? "T" : "";
        return c + toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        this.value = value;
        this.successful = true;
      }
      map(f) {
        return new Success(f(this.value));
      }
      flatMap(f) {
        return f(this.value);
      }
      mapErr(f) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error2) {
        this.error = error2;
        this.successful = false;
      }
      map(_f2) {
        return this;
      }
      flatMap(_f2) {
        return this;
      }
      mapErr(f) {
        return new Failure(f(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error2) {
        return new Failure(error2);
      }
      Result2.failure = failure;
      function flatMap2(first2, second, f) {
        if (first2.successful) {
          if (second.successful)
            return f(first2.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first2.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first2, second, f) {
        return flatMap2(first2, second, (a, b) => success(f(a, b)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    (function(module3, exports2) {
      !function(n2, t) {
        module3.exports = t();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n2) {
          var t = {};
          function r(e) {
            if (t[e])
              return t[e].exports;
            var u = t[e] = { i: e, l: false, exports: {} };
            return n2[e].call(u.exports, u, u.exports, r), u.l = true, u.exports;
          }
          return r.m = n2, r.c = t, r.d = function(n3, t2, e) {
            r.o(n3, t2) || Object.defineProperty(n3, t2, { configurable: false, enumerable: true, get: e });
          }, r.r = function(n3) {
            Object.defineProperty(n3, "__esModule", { value: true });
          }, r.n = function(n3) {
            var t2 = n3 && n3.__esModule ? function() {
              return n3.default;
            } : function() {
              return n3;
            };
            return r.d(t2, "a", t2), t2;
          }, r.o = function(n3, t2) {
            return Object.prototype.hasOwnProperty.call(n3, t2);
          }, r.p = "", r(r.s = 0);
        }([function(n2, t, r) {
          function e(n3) {
            if (!(this instanceof e))
              return new e(n3);
            this._ = n3;
          }
          var u = e.prototype;
          function o(n3, t2) {
            for (var r2 = 0; r2 < n3; r2++)
              t2(r2);
          }
          function i(n3, t2, r2) {
            return function(n4, t3) {
              o(t3.length, function(r3) {
                n4(t3[r3], r3, t3);
              });
            }(function(r3, e2, u2) {
              t2 = n3(t2, r3, e2, u2);
            }, r2), t2;
          }
          function a(n3, t2) {
            return i(function(t3, r2, e2, u2) {
              return t3.concat([n3(r2, e2, u2)]);
            }, [], t2);
          }
          function f(n3, t2) {
            var r2 = { v: 0, buf: t2 };
            return o(n3, function() {
              var n4;
              r2 = { v: r2.v << 1 | (n4 = r2.buf, n4[0] >> 7), buf: function(n5) {
                var t3 = i(function(n6, t4, r3, e2) {
                  return n6.concat(r3 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r3));
                }, [], n5);
                return Buffer.from(a(function(n6) {
                  return (n6 << 1 & 65535) >> 8;
                }, t3));
              }(r2.buf) };
            }), r2;
          }
          function c() {
            return "undefined" != typeof Buffer;
          }
          function s2() {
            if (!c())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l2(n3) {
            s2();
            var t2 = i(function(n4, t3) {
              return n4 + t3;
            }, 0, n3);
            if (t2 % 8 != 0)
              throw new Error("The bits [" + n3.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
            var r2, u2 = t2 / 8, o2 = (r2 = function(n4) {
              return n4 > 48;
            }, i(function(n4, t3) {
              return n4 || (r2(t3) ? t3 : n4);
            }, null, n3));
            if (o2)
              throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t3, r3) {
              var e2 = u2 + r3;
              return e2 > t3.length ? x(r3, u2.toString() + " bytes") : b(e2, i(function(n4, t4) {
                var r4 = f(t4, n4.buf);
                return { coll: n4.coll.concat(r4.v), buf: r4.buf };
              }, { coll: [], buf: t3.slice(r3, e2) }, n3).coll);
            });
          }
          function h(n3, t2) {
            return new e(function(r2, e2) {
              return s2(), e2 + t2 > r2.length ? x(e2, t2 + " bytes for " + n3) : b(e2 + t2, r2.slice(e2, e2 + t2));
            });
          }
          function p(n3, t2) {
            if ("number" != typeof (r2 = t2) || Math.floor(r2) !== r2 || t2 < 0 || t2 > 6)
              throw new Error(n3 + " requires integer length in range [0, 6].");
            var r2;
          }
          function d(n3) {
            return p("uintBE", n3), h("uintBE(" + n3 + ")", n3).map(function(t2) {
              return t2.readUIntBE(0, n3);
            });
          }
          function v(n3) {
            return p("uintLE", n3), h("uintLE(" + n3 + ")", n3).map(function(t2) {
              return t2.readUIntLE(0, n3);
            });
          }
          function g(n3) {
            return p("intBE", n3), h("intBE(" + n3 + ")", n3).map(function(t2) {
              return t2.readIntBE(0, n3);
            });
          }
          function m(n3) {
            return p("intLE", n3), h("intLE(" + n3 + ")", n3).map(function(t2) {
              return t2.readIntLE(0, n3);
            });
          }
          function y(n3) {
            return n3 instanceof e;
          }
          function E(n3) {
            return "[object Array]" === {}.toString.call(n3);
          }
          function w(n3) {
            return c() && Buffer.isBuffer(n3);
          }
          function b(n3, t2) {
            return { status: true, index: n3, value: t2, furthest: -1, expected: [] };
          }
          function x(n3, t2) {
            return E(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n3, expected: t2 };
          }
          function B(n3, t2) {
            if (!t2)
              return n3;
            if (n3.furthest > t2.furthest)
              return n3;
            var r2 = n3.furthest === t2.furthest ? function(n4, t3) {
              if (function() {
                if (void 0 !== e._supportsSet)
                  return e._supportsSet;
                var n5 = "undefined" != typeof Set;
                return e._supportsSet = n5, n5;
              }() && Array.from) {
                for (var r3 = new Set(n4), u2 = 0; u2 < t3.length; u2++)
                  r3.add(t3[u2]);
                var o2 = Array.from(r3);
                return o2.sort(), o2;
              }
              for (var i2 = {}, a2 = 0; a2 < n4.length; a2++)
                i2[n4[a2]] = true;
              for (var f2 = 0; f2 < t3.length; f2++)
                i2[t3[f2]] = true;
              var c2 = [];
              for (var s3 in i2)
                ({}).hasOwnProperty.call(i2, s3) && c2.push(s3);
              return c2.sort(), c2;
            }(n3.expected, t2.expected) : t2.expected;
            return { status: n3.status, index: n3.index, value: n3.value, furthest: t2.furthest, expected: r2 };
          }
          var j = {};
          function S(n3, t2) {
            if (w(n3))
              return { offset: t2, line: -1, column: -1 };
            n3 in j || (j[n3] = {});
            for (var r2 = j[n3], e2 = 0, u2 = 0, o2 = 0, i2 = t2; i2 >= 0; ) {
              if (i2 in r2) {
                e2 = r2[i2].line, 0 === o2 && (o2 = r2[i2].lineStart);
                break;
              }
              ("\n" === n3.charAt(i2) || "\r" === n3.charAt(i2) && "\n" !== n3.charAt(i2 + 1)) && (u2++, 0 === o2 && (o2 = i2 + 1)), i2--;
            }
            var a2 = e2 + u2, f2 = t2 - o2;
            return r2[t2] = { line: a2, lineStart: o2 }, { offset: t2, line: a2 + 1, column: f2 + 1 };
          }
          function _3(n3) {
            if (!y(n3))
              throw new Error("not a parser: " + n3);
          }
          function L(n3, t2) {
            return "string" == typeof n3 ? n3.charAt(t2) : n3[t2];
          }
          function O(n3) {
            if ("number" != typeof n3)
              throw new Error("not a number: " + n3);
          }
          function k(n3) {
            if ("function" != typeof n3)
              throw new Error("not a function: " + n3);
          }
          function P(n3) {
            if ("string" != typeof n3)
              throw new Error("not a string: " + n3);
          }
          var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z = "  ";
          function R(n3, t2) {
            return new Array(t2 + 1).join(n3);
          }
          function U(n3, t2, r2) {
            var e2 = t2 - n3.length;
            return e2 <= 0 ? n3 : R(r2, e2) + n3;
          }
          function W(n3, t2, r2, e2) {
            return { from: n3 - t2 > 0 ? n3 - t2 : 0, to: n3 + r2 > e2 ? e2 : n3 + r2 };
          }
          function D(n3, t2) {
            var r2, e2, u2, o2, f2, c2 = t2.index, s3 = c2.offset, l3 = 1;
            if (s3 === n3.length)
              return "Got the end of the input";
            if (w(n3)) {
              var h2 = s3 - s3 % I, p2 = s3 - h2, d2 = W(h2, F, M + I, n3.length), v2 = a(function(n4) {
                return a(function(n5) {
                  return U(n5.toString(16), 2, "0");
                }, n4);
              }, function(n4, t3) {
                var r3 = n4.length, e3 = [], u3 = 0;
                if (r3 <= t3)
                  return [n4.slice()];
                for (var o3 = 0; o3 < r3; o3++)
                  e3[u3] || e3.push([]), e3[u3].push(n4[o3]), (o3 + 1) % t3 == 0 && u3++;
                return e3;
              }(n3.slice(d2.from, d2.to).toJSON().data, I));
              o2 = function(n4) {
                return 0 === n4.from && 1 === n4.to ? { from: n4.from, to: n4.to } : { from: n4.from / I, to: Math.floor(n4.to / I) };
              }(d2), e2 = h2 / I, r2 = 3 * p2, p2 >= 4 && (r2 += 1), l3 = 2, u2 = a(function(n4) {
                return n4.length <= 4 ? n4.join(" ") : n4.slice(0, 4).join(" ") + "  " + n4.slice(4).join(" ");
              }, v2), (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2);
            } else {
              var g2 = n3.split(/\r\n|[\n\r\u2028\u2029]/);
              r2 = c2.column - 1, e2 = c2.line - 1, o2 = W(e2, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f2 = o2.to.toString().length;
            }
            var m2 = e2 - o2.from;
            return w(n3) && (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2), i(function(t3, e3, u3) {
              var i2, a2 = u3 === m2, c3 = a2 ? "> " : z;
              return i2 = w(n3) ? U((8 * (o2.from + u3)).toString(16), f2, "0") : U((o2.from + u3 + 1).toString(), f2, " "), [].concat(t3, [c3 + i2 + " | " + e3], a2 ? [z + R(" ", f2) + " | " + U("", r2, " ") + R("^", l3)] : []);
            }, [], u2).join("\n");
          }
          function N(n3, t2) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n3, t2), "\n\n", (r2 = t2.expected, 1 === r2.length ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
            var r2;
          }
          function G(n3) {
            return void 0 !== n3.flags ? n3.flags : [n3.global ? "g" : "", n3.ignoreCase ? "i" : "", n3.multiline ? "m" : "", n3.unicode ? "u" : "", n3.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n3 = [].slice.call(arguments), t2 = n3.length, r2 = 0; r2 < t2; r2 += 1)
              _3(n3[r2]);
            return e(function(r3, e2) {
              for (var u2, o2 = new Array(t2), i2 = 0; i2 < t2; i2 += 1) {
                if (!(u2 = B(n3[i2]._(r3, e2), u2)).status)
                  return u2;
                o2[i2] = u2.value, e2 = u2.index;
              }
              return B(b(e2, o2), u2);
            });
          }
          function J() {
            var n3 = [].slice.call(arguments);
            if (0 === n3.length)
              throw new Error("seqMap needs at least one argument");
            var t2 = n3.pop();
            return k(t2), C.apply(null, n3).map(function(n4) {
              return t2.apply(null, n4);
            });
          }
          function T() {
            var n3 = [].slice.call(arguments), t2 = n3.length;
            if (0 === t2)
              return Y("zero alternates");
            for (var r2 = 0; r2 < t2; r2 += 1)
              _3(n3[r2]);
            return e(function(t3, r3) {
              for (var e2, u2 = 0; u2 < n3.length; u2 += 1)
                if ((e2 = B(n3[u2]._(t3, r3), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n3, t2) {
            return H(n3, t2).or(X([]));
          }
          function H(n3, t2) {
            return _3(n3), _3(t2), J(n3, t2.then(n3).many(), function(n4, t3) {
              return [n4].concat(t3);
            });
          }
          function K(n3) {
            P(n3);
            var t2 = "'" + n3 + "'";
            return e(function(r2, e2) {
              var u2 = e2 + n3.length, o2 = r2.slice(e2, u2);
              return o2 === n3 ? b(u2, o2) : x(e2, t2);
            });
          }
          function Q(n3, t2) {
            !function(n4) {
              if (!(n4 instanceof RegExp))
                throw new Error("not a regexp: " + n4);
              for (var t3 = G(n4), r3 = 0; r3 < t3.length; r3++) {
                var e2 = t3.charAt(r3);
                if ("i" !== e2 && "m" !== e2 && "u" !== e2 && "s" !== e2)
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n4);
              }
            }(n3), arguments.length >= 2 ? O(t2) : t2 = 0;
            var r2 = function(n4) {
              return RegExp("^(?:" + n4.source + ")", G(n4));
            }(n3), u2 = "" + n3;
            return e(function(n4, e2) {
              var o2 = r2.exec(n4.slice(e2));
              if (o2) {
                if (0 <= t2 && t2 <= o2.length) {
                  var i2 = o2[0], a2 = o2[t2];
                  return b(e2 + i2.length, a2);
                }
                return x(e2, "valid match group (0 to " + o2.length + ") in " + u2);
              }
              return x(e2, u2);
            });
          }
          function X(n3) {
            return e(function(t2, r2) {
              return b(r2, n3);
            });
          }
          function Y(n3) {
            return e(function(t2, r2) {
              return x(r2, n3);
            });
          }
          function Z(n3) {
            if (y(n3))
              return e(function(t2, r2) {
                var e2 = n3._(t2, r2);
                return e2.index = r2, e2.value = "", e2;
              });
            if ("string" == typeof n3)
              return Z(K(n3));
            if (n3 instanceof RegExp)
              return Z(Q(n3));
            throw new Error("not a string, regexp, or parser: " + n3);
          }
          function $(n3) {
            return _3(n3), e(function(t2, r2) {
              var e2 = n3._(t2, r2), u2 = t2.slice(r2, e2.index);
              return e2.status ? x(r2, 'not "' + u2 + '"') : b(r2, null);
            });
          }
          function nn(n3) {
            return k(n3), e(function(t2, r2) {
              var e2 = L(t2, r2);
              return r2 < t2.length && n3(e2) ? b(r2 + 1, e2) : x(r2, "a character/byte matching " + n3);
            });
          }
          function tn(n3, t2) {
            arguments.length < 2 && (t2 = n3, n3 = void 0);
            var r2 = e(function(n4, e2) {
              return r2._ = t2()._, r2._(n4, e2);
            });
            return n3 ? r2.desc(n3) : r2;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u.parse = function(n3) {
            if ("string" != typeof n3 && !w(n3))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t2, r2 = this.skip(an)._(n3, 0);
            return t2 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n3, r2.furthest), expected: r2.expected }, delete j[n3], t2;
          }, u.tryParse = function(n3) {
            var t2 = this.parse(n3);
            if (t2.status)
              return t2.value;
            var r2 = N(n3, t2), e2 = new Error(r2);
            throw e2.type = "ParsimmonError", e2.result = t2, e2;
          }, u.assert = function(n3, t2) {
            return this.chain(function(r2) {
              return n3(r2) ? X(r2) : Y(t2);
            });
          }, u.or = function(n3) {
            return T(this, n3);
          }, u.trim = function(n3) {
            return this.wrap(n3, n3);
          }, u.wrap = function(n3, t2) {
            return J(n3, this, t2, function(n4, t3) {
              return t3;
            });
          }, u.thru = function(n3) {
            return n3(this);
          }, u.then = function(n3) {
            return _3(n3), C(this, n3).map(function(n4) {
              return n4[1];
            });
          }, u.many = function() {
            var n3 = this;
            return e(function(t2, r2) {
              for (var e2 = [], u2 = void 0; ; ) {
                if (!(u2 = B(n3._(t2, r2), u2)).status)
                  return B(b(r2, e2), u2);
                if (r2 === u2.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r2 = u2.index, e2.push(u2.value);
              }
            });
          }, u.tieWith = function(n3) {
            return P(n3), this.map(function(t2) {
              if (function(n4) {
                if (!E(n4))
                  throw new Error("not an array: " + n4);
              }(t2), t2.length) {
                P(t2[0]);
                for (var r2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                  P(t2[e2]), r2 += n3 + t2[e2];
                return r2;
              }
              return "";
            });
          }, u.tie = function() {
            return this.tieWith("");
          }, u.times = function(n3, t2) {
            var r2 = this;
            return arguments.length < 2 && (t2 = n3), O(n3), O(t2), e(function(e2, u2) {
              for (var o2 = [], i2 = void 0, a2 = void 0, f2 = 0; f2 < n3; f2 += 1) {
                if (a2 = B(i2 = r2._(e2, u2), a2), !i2.status)
                  return a2;
                u2 = i2.index, o2.push(i2.value);
              }
              for (; f2 < t2 && (a2 = B(i2 = r2._(e2, u2), a2), i2.status); f2 += 1)
                u2 = i2.index, o2.push(i2.value);
              return B(b(u2, o2), a2);
            });
          }, u.result = function(n3) {
            return this.map(function() {
              return n3;
            });
          }, u.atMost = function(n3) {
            return this.times(0, n3);
          }, u.atLeast = function(n3) {
            return J(this.times(n3), this.many(), function(n4, t2) {
              return n4.concat(t2);
            });
          }, u.map = function(n3) {
            k(n3);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(b(u2.index, n3(u2.value)), u2) : u2;
            });
          }, u.contramap = function(n3) {
            k(n3);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2.parse(n3(r2.slice(e2)));
              return u2.status ? b(e2 + r2.length, u2.value) : u2;
            });
          }, u.promap = function(n3, t2) {
            return k(n3), k(t2), this.contramap(n3).map(t2);
          }, u.skip = function(n3) {
            return C(this, n3).map(function(n4) {
              return n4[0];
            });
          }, u.mark = function() {
            return J(en, this, en, function(n3, t2, r2) {
              return { start: n3, value: t2, end: r2 };
            });
          }, u.node = function(n3) {
            return J(en, this, en, function(t2, r2, e2) {
              return { name: n3, value: r2, start: t2, end: e2 };
            });
          }, u.sepBy = function(n3) {
            return V(this, n3);
          }, u.sepBy1 = function(n3) {
            return H(this, n3);
          }, u.lookahead = function(n3) {
            return this.skip(Z(n3));
          }, u.notFollowedBy = function(n3) {
            return this.skip($(n3));
          }, u.desc = function(n3) {
            E(n3) || (n3 = [n3]);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status || (u2.expected = n3), u2;
            });
          }, u.fallback = function(n3) {
            return this.or(X(n3));
          }, u.ap = function(n3) {
            return J(n3, this, function(n4, t2) {
              return n4(t2);
            });
          }, u.chain = function(n3) {
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(n3(u2.value)._(r2, u2.index), u2) : u2;
            });
          }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
          var en = e(function(n3, t2) {
            return b(t2, S(n3, t2));
          }), un = e(function(n3, t2) {
            return t2 >= n3.length ? x(t2, "any character/byte") : b(t2 + 1, L(n3, t2));
          }), on = e(function(n3, t2) {
            return b(n3.length, n3.slice(t2));
          }), an = e(function(n3, t2) {
            return t2 < n3.length ? x(t2, "EOF") : b(t2, null);
          }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T(gn, vn, dn).desc("newline"), yn = T(mn, an);
          e.all = on, e.alt = T, e.any = un, e.cr = dn, e.createLanguage = function(n3) {
            var t2 = {};
            for (var r2 in n3)
              ({}).hasOwnProperty.call(n3, r2) && function(r3) {
                t2[r3] = tn(function() {
                  return n3[r3](t2);
                });
              }(r2);
            return t2;
          }, e.crlf = gn, e.custom = function(n3) {
            return e(n3(b, x));
          }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x, e.makeSuccess = b, e.newline = mn, e.noneOf = function(n3) {
            return nn(function(t2) {
              return n3.indexOf(t2) < 0;
            }).desc("none of '" + n3 + "'");
          }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n3) {
            for (var t2 = n3.split(""), r2 = 0; r2 < t2.length; r2++)
              t2[r2] = "'" + t2[r2] + "'";
            return nn(function(t3) {
              return n3.indexOf(t3) >= 0;
            }).desc(t2);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n3, t2) {
            return nn(function(r2) {
              return n3 <= r2 && r2 <= t2;
            }).desc(n3 + "-" + t2);
          }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n3, t2 = {}, r2 = 0, u2 = (n3 = arguments, Array.prototype.slice.call(n3)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
              var a2 = u2[i2];
              if (!y(a2)) {
                if (E(a2) && 2 === a2.length && "string" == typeof a2[0] && y(a2[1])) {
                  var f2 = a2[0];
                  if (Object.prototype.hasOwnProperty.call(t2, f2))
                    throw new Error("seqObj: duplicate key " + f2);
                  t2[f2] = true, r2++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r2)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n4, t3) {
              for (var r3, e2 = {}, i3 = 0; i3 < o2; i3 += 1) {
                var a3, f3;
                if (E(u2[i3]) ? (a3 = u2[i3][0], f3 = u2[i3][1]) : (a3 = null, f3 = u2[i3]), !(r3 = B(f3._(n4, t3), r3)).status)
                  return r3;
                a3 && (e2[a3] = r3.value), t3 = r3.index;
              }
              return B(b(t3, e2), r3);
            });
          }, e.string = K, e.succeed = X, e.takeWhile = function(n3) {
            return k(n3), e(function(t2, r2) {
              for (var e2 = r2; e2 < t2.length && n3(L(t2, e2)); )
                e2++;
              return b(e2, t2.slice(r2, e2));
            });
          }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l2, bitSeqObj: function(n3) {
            s2();
            var t2 = {}, r2 = 0, e2 = a(function(n4) {
              if (E(n4)) {
                var e3 = n4;
                if (2 !== e3.length)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P(e3[0]), O(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t2[e3[0]] = true, r2++, e3;
              }
              return O(n4), [null, n4];
            }, n3);
            if (r2 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n3.join(", ") + "]");
            var u2 = a(function(n4) {
              return n4[0];
            }, e2);
            return l2(a(function(n4) {
              return n4[1];
            }, e2)).map(function(n4) {
              return i(function(n5, t3) {
                return null !== t3[0] && (n5[t3[0]] = t3[1]), n5;
              }, {}, a(function(t3, r3) {
                return [t3, n4[r3]];
              }, u2));
            });
          }, byte: function(n3) {
            if (s2(), O(n3), n3 > 255)
              throw new Error("Value specified to byte constructor (" + n3 + "=0x" + n3.toString(16) + ") is larger in value than a single byte.");
            var t2 = (n3 > 15 ? "0x" : "0x0") + n3.toString(16);
            return e(function(r2, e2) {
              var u2 = L(r2, e2);
              return u2 === n3 ? b(e2 + 1, u2) : x(e2, t2);
            });
          }, buffer: function(n3) {
            return h("buffer", n3).map(function(n4) {
              return Buffer.from(n4);
            });
          }, encodedString: function(n3, t2) {
            return h("string", t2).map(function(t3) {
              return t3.toString(n3);
            });
          }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v, uint8LE: v(1), uint16LE: v(2), uint32LE: v(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n3) {
            return n3.readFloatBE(0);
          }), floatLE: h("floatLE", 4).map(function(n3) {
            return n3.readFloatLE(0);
          }), doubleBE: h("doubleBE", 8).map(function(n3) {
            return n3.readDoubleBE(0);
          }), doubleLE: h("doubleLE", 8).map(function(n3) {
            return n3.readDoubleLE(0);
          }) }, n2.exports = e;
        }]);
      });
    })(parsimmon_umd_min);
    var emojiRegex = () => {
      return /(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDD-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF6](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC2\uDED0-\uDED9\uDEE0-\uDEE7]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path3) {
      if (path3.includes("/"))
        path3 = path3.substring(path3.lastIndexOf("/") + 1);
      if (path3.endsWith(".md"))
        path3 = path3.substring(0, path3.length - 3);
      return path3;
    }
    parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_min.exports.whitespace.map((_3) => "-"), parsimmon_umd_min.exports.any.map((_3) => "")).many().map((result2) => result2.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_min.exports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_min.exports.whitespace.map((_3) => " "), parsimmon_umd_min.exports.any.map((_3) => " ")).many().map((result2) => {
      return result2.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity > 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString2(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result2 = "";
            if (recursive)
              result2 += "[";
            result2 += wrapped.value.map((f) => toString2(f, setting, true)).join(", ");
            if (recursive)
              result2 += "]";
            return result2;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString2(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString2;
      function wrapValue(val) {
        if (isNull2(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean2(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate2(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction2(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result2 = {};
          for (let [key, value] of Object.entries(val))
            result2[key] = mapLeaves(value, func);
          return result2;
        } else if (isArray(val)) {
          let result2 = [];
          for (let value of val)
            result2.push(mapLeaves(value, func));
          return result2;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a3, _b2;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize3 = linkNormalizer !== null && linkNormalizer !== void 0 ? linkNormalizer : (x) => x;
            let pathCompare = normalize3(link1.path).localeCompare(normalize3(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a3 = link1.subpath) !== null && _a3 !== void 0 ? _a3 : "").localeCompare((_b2 = link2.subpath) !== null && _b2 !== void 0 ? _b2 : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
              let comp = compareValue(f1[index], f2[index]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a3;
        return (_a3 = wrapValue(val)) === null || _a3 === void 0 ? void 0 : _a3.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v) => deepCopy(v)));
        } else if (Values2.isObject(field)) {
          let result2 = {};
          for (let [key, value] of Object.entries(field))
            result2[key] = deepCopy(value);
          return result2;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate2(val) {
        return val instanceof DateTime;
      }
      Values2.isDate = isDate2;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull2(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull2;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean2(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean2;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate2(val) && !isLink(val) && val !== void 0 && !isNull2(val);
      }
      Values2.isObject = isObject2;
      function isFunction2(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction2;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result2 = 0;
          for (let subgroup of elements)
            result2 += count(subgroup.rows);
          return result2;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path3, embed = false, display) {
        return new Link({
          path: path3,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return Link.header(split[0], split[1], embed, display);
        } else
          return Link.file(linkpath, embed, display);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path3, header, embed, display) {
        return new Link({
          path: path3,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path3, blockId, embed, display) {
        return new Link({
          path: path3,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object2) {
        return new Link(object2);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path3) {
        return new Link(Object.assign({}, this, { path: path3 }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display) {
        return new Link(Object.assign({}, this, { display }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result2 = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result2 += "|" + this.display;
        } else {
          result2 += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result2 += " > " + this.subpath;
        }
        result2 += "]]";
        return result2;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a3, _b2;
        const escaped = this.path.replace("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a3 = this.subpath) === null || _a3 === void 0 ? void 0 : _a3.replace("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b2 = this.subpath) === null || _b2 === void 0 ? void 0 : _b2.replace("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a3;
        return `[${(_a3 = this.display) !== null && _a3 !== void 0 ? _a3 : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index(obj, index2) {
        return { type: "index", object: obj, index: index2 };
      }
      Fields2.index = index;
      function indexVariable(name) {
        let parts = name.split(".");
        let result2 = Fields2.variable(parts[0]);
        for (let index2 = 1; index2 < parts.length; index2++) {
          result2 = Fields2.index(result2, Fields2.literal(parts[index2]));
        }
        return result2;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values2) {
        return { type: "list", values: values2 };
      }
      Fields2.list = list;
      function object2(values2) {
        return { type: "object", values: values2 };
      }
      Fields2.object = object2;
      function negate2(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate2;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path3) {
        return { type: "csv", path: path3 };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate2(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate2;
      function empty() {
        return { type: "empty" };
      }
      Sources2.empty = empty;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime.local(),
      today: () => DateTime.local().startOf("day"),
      yesterday: () => DateTime.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime.local().startOf("week"),
      "start-of-week": () => DateTime.local().startOf("week"),
      eow: () => DateTime.local().endOf("week"),
      "end-of-week": () => DateTime.local().endOf("week"),
      soy: () => DateTime.local().startOf("year"),
      "start-of-year": () => DateTime.local().startOf("year"),
      eoy: () => DateTime.local().endOf("year"),
      "end-of-year": () => DateTime.local().endOf("year"),
      som: () => DateTime.local().startOf("month"),
      "start-of-month": () => DateTime.local().startOf("month"),
      eom: () => DateTime.local().endOf("month"),
      "end-of-month": () => DateTime.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep2, combine) {
      return parsimmon_umd_min.exports.seqMap(child, parsimmon_umd_min.exports.seq(parsimmon_umd_min.exports.optWhitespace, sep2, parsimmon_umd_min.exports.optWhitespace, child).many(), (first2, rest2) => {
        if (rest2.length == 0)
          return first2;
        let node = combine(first2, rest2[0][1], rest2[0][3]);
        for (let index = 1; index < rest2.length; index++) {
          node = combine(node, rest2[index][1], rest2[index][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i) => {
          let result2 = base._(input, i);
          if (!result2.status)
            return result2;
          for (let func of funcs) {
            let next = func(result2.value)._(input, result2.index);
            if (!next.status)
              return result2;
            result2 = next;
          }
          return result2;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_min.exports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q) => parsimmon_umd_min.exports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q) => parsimmon_umd_min.exports.string('"').then(parsimmon_umd_min.exports.alt(q.escapeCharacter, parsimmon_umd_min.exports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_min.exports.string('"')).desc("string"),
      escapeCharacter: (_3) => parsimmon_umd_min.exports.string("\\").then(parsimmon_umd_min.exports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_3) => parsimmon_umd_min.exports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_3) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("#"), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest2) => start + rest2.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_3) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/\p{Letter}/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_min.exports.regexp(EMOJI_REGEX).desc("text")).many(), (first2, rest2) => first2 + rest2.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_3) => parsimmon_umd_min.exports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!").atMost(1), q.link, (p, l2) => {
        if (p.length > 0)
          l2.embed = true;
        return l2;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_3) => parsimmon_umd_min.exports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_3) => parsimmon_umd_min.exports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_3) => parsimmon_umd_min.exports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_3) => parsimmon_umd_min.exports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_3) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/\d{4}/), parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (year, _4, month) => {
        return DateTime.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_3) => parsimmon_umd_min.exports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_min.exports.string)),
      date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_3, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("T"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_3, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_3, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string(":"), parsimmon_umd_min.exports.regexp(/\d{2}/), (_3, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), parsimmon_umd_min.exports.regexp(/\d{3}/), (_3, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_min.exports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("+").or(parsimmon_umd_min.exports.string("-")), parsimmon_umd_min.exports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_min.exports.string("]"), (_a3, zone, _b2) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q) => parsimmon_umd_min.exports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_3) => parsimmon_umd_min.exports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_min.exports.string)),
      duration: (q) => parsimmon_umd_min.exports.seqMap(q.number, parsimmon_umd_min.exports.optWhitespace, q.durationType, (count, _3, t) => DURATION_TYPES[t].mapUnits((x) => x * count)).sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).or(parsimmon_umd_min.exports.optWhitespace)).map((durations) => durations.reduce((p, c) => p.plus(c))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_3) => parsimmon_umd_min.exports.string("null"),
      // Source parsing.
      tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("csv(").skip(parsimmon_umd_min.exports.optWhitespace), q.string, parsimmon_umd_min.exports.string(")"), (_1, path3, _22) => Sources.csv(path3)),
      linkIncomingSource: (q) => q.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("outgoing(").skip(parsimmon_umd_min.exports.optWhitespace), q.link, parsimmon_umd_min.exports.string(")"), (_1, link, _22) => Sources.link(link.path, false)),
      folderSource: (q) => q.string.map((str) => Sources.folder(str)),
      parensSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.source, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _22, field, _3, _4) => field),
      negateSource: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.string("-"), parsimmon_umd_min.exports.string("!")), q.atomSource, (_3, source) => Sources.negate(source)),
      atomSource: (q) => parsimmon_umd_min.exports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
      binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s2) => s2), Sources.binaryOp),
      source: (q) => q.binaryOpSource,
      // Field parsing.
      variableField: (q) => q.identifier.chain((r) => {
        if (KEYWORDS.includes(r.toUpperCase())) {
          return parsimmon_umd_min.exports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_min.exports.succeed(Fields.variable(r));
        }
      }).desc("variable"),
      numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("date("), parsimmon_umd_min.exports.optWhitespace, q.datePlus, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, date, _22, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("dur("), parsimmon_umd_min.exports.optWhitespace, q.duration, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (prefix, _1, dur, _22, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q) => q.rawNull.map((_3) => Fields.NULL),
      linkField: (q) => q.link.map((f) => Fields.literal(f)),
      listField: (q) => q.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("[").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("]"))).map((l2) => Fields.list(l2)).desc("list ('[1, 2, 3]')"),
      objectField: (q) => parsimmon_umd_min.exports.seqMap(q.identifier.or(q.string), parsimmon_umd_min.exports.string(":").trim(parsimmon_umd_min.exports.optWhitespace), q.field, (name, _sep2, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("{").skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.optWhitespace.then(parsimmon_umd_min.exports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q) => parsimmon_umd_min.exports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
      inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace).lookahead(q.atomInlineField)),
      inlineField: (q) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.seqMap(q.atomInlineField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace), q.inlineFieldList, (f, _s2, l2) => [f].concat(l2)), q.atomInlineField),
      atomField: (q) => parsimmon_umd_min.exports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q.embedLink.map((l2) => Fields.literal(l2)),
        q.negatedField,
        q.linkField,
        q.listField,
        q.objectField,
        q.lambdaField,
        q.parensField,
        q.boolField,
        q.numberField,
        q.stringField,
        q.dateField,
        q.durationField,
        q.nullField,
        q.variableField
      ),
      indexField: (q) => parsimmon_umd_min.exports.seqMap(q.atomField, parsimmon_umd_min.exports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
        let result2 = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result2 = Fields.index(result2, Fields.literal(post.field));
              break;
            case "index":
              result2 = Fields.index(result2, post.field);
              break;
            case "function":
              result2 = Fields.func(result2, post.fields);
              break;
          }
        }
        return result2;
      }),
      negatedField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("!"), q.indexField, (_3, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_1, _22, field, _3, _4) => field),
      lambdaField: (q) => parsimmon_umd_min.exports.seqMap(q.identifier.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)).wrap(parsimmon_umd_min.exports.string("(").trim(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.string(")").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.string("=>").trim(parsimmon_umd_min.exports.optWhitespace), q.field, (ident, _ignore2, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("."), q.identifier, (_3, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("["), parsimmon_umd_min.exports.optWhitespace, q.field, parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string("]"), (_3, _22, field, _32, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.string("("), parsimmon_umd_min.exports.optWhitespace, q.field.sepBy(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), parsimmon_umd_min.exports.optWhitespace, parsimmon_umd_min.exports.string(")"), (_3, _1, fields, _22, _32) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q) => q.binaryBooleanField,
      field: (q) => q.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error2) {
        return Result.failure("" + error2);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy2(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy2;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_min.exports.custom((success, failure) => {
        return (input, i) => {
          let result2 = base._(input, i);
          if (!result2.status)
            return result2;
          return Object.assign({}, result2, { value: [result2.value, input.substring(i, result2.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t) => t.trim()).join("");
    }
    var QUERY_LANGUAGE = parsimmon_umd_min.exports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q) => parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.whitespace), parsimmon_umd_min.exports.regexp(/AS/i).skip(parsimmon_umd_min.exports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      namedField: (q) => parsimmon_umd_min.exports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q) => parsimmon_umd_min.exports.seqMap(EXPRESSION.field.skip(parsimmon_umd_min.exports.optWhitespace), parsimmon_umd_min.exports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q) => q.queryType.skip(parsimmon_umd_min.exports.whitespace).chain((qtype) => {
        switch (qtype) {
          case "table":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), parsimmon_umd_min.exports.sepBy(q.namedField, parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (withoutId, fields) => {
              return { type: "table", fields, showId: withoutId.length == 0 };
            });
          case "list":
            return parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_min.exports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type: "list",
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            });
          case "task":
            return parsimmon_umd_min.exports.succeed({ type: "task" });
          case "calendar":
            return parsimmon_umd_min.exports.seqMap(q.namedField, (field) => {
              return {
                type: "calendar",
                showId: true,
                field
              };
            });
          default:
            return parsimmon_umd_min.exports.fail(`Unrecognized query type '${qtype}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FROM/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.source, (_1, _22, source) => source),
      whereClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/WHERE/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (where2, _3, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/SORT/i), parsimmon_umd_min.exports.whitespace, q.sortField.sepBy1(parsimmon_umd_min.exports.string(",").trim(parsimmon_umd_min.exports.optWhitespace)), (sort, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/LIMIT/i), parsimmon_umd_min.exports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/FLATTEN/i).skip(parsimmon_umd_min.exports.whitespace), q.namedField, (_3, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q) => parsimmon_umd_min.exports.seqMap(parsimmon_umd_min.exports.regexp(/GROUP BY/i).skip(parsimmon_umd_min.exports.whitespace), q.namedField, (_3, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q) => parsimmon_umd_min.exports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
      query: (q) => parsimmon_umd_min.exports.seqMap(q.headerClause.trim(parsimmon_umd_min.exports.optWhitespace), q.fromClause.trim(parsimmon_umd_min.exports.optWhitespace).atMost(1), q.clause.trim(parsimmon_umd_min.exports.optWhitespace).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var getAPI2 = (app) => {
      var _a3;
      if (app)
        return (_a3 = app.plugins.plugins.dataview) === null || _a3 === void 0 ? void 0 : _a3.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range2(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range2;
    function range2(a, b, str) {
      var begs, beg, left, right, result2;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result2) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result2 = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result2 = [left, right];
        }
      }
      return result2;
    }
  }
});

// node_modules/glob/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/glob/node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BulkExporterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/view.ts
var import_obsidian8 = require("obsidian");

// src/utils/log.ts
var target;
var COLORS = {
  LOG: "",
  WARN: "#838009",
  ERROR: "red"
};
function log(...args) {
  return toView(COLORS.LOG, ...args);
}
function error(...args) {
  return toView(COLORS.ERROR, ...args);
}
function toView(color, ...args) {
  if (!target) {
    console.error("too early", args);
    throw new Error("hmm.");
  }
  return logEntry(target, color, ...args);
}
function logEntry(target2, color, ...args) {
  const h = String(new Date().getHours()).padStart(2, "0");
  const m = String(new Date().getMinutes()).padStart(2, "0");
  const s = String(new Date().getSeconds()).padStart(2, "0");
  const timeStamp = `[${h}:${m}:${s}] `;
  const spn = createSpan({ attr: { style: `color: ${color}`, class: "log-entry" } });
  spn.append(timeStamp);
  args.forEach((element) => {
    spn.append(element);
  });
  spn.append(createEl("br"));
  target2.append(spn);
  return spn;
}
function setLogOutput(targetElement) {
  target = targetElement;
  targetElement.addClass("log");
  log("Logging started.");
}

// src/ui/render-export.ts
var import_obsidian7 = require("obsidian");

// src/obsidian-api-helpers/file-explorer.ts
function revealInFolder(plugin, path3) {
  const fileExplorer = plugin.app.internalPlugins.getPluginById("file-explorer").instance;
  if (fileExplorer) {
    const fileObject = plugin.app.vault.getAbstractFileByPath(path3);
    fileExplorer.revealInFolder(fileObject);
  }
}

// src/obsidian-api-helpers/get-icon.ts
var import_obsidian = require("obsidian");
function getIcon(iconId) {
  const icon = (0, import_obsidian.getIcon)(iconId);
  if (!icon) {
    throw new Error(`Icon does not exists: ${iconId}`);
  }
  return icon;
}

// src/ui/url.ts
function isHttpUrl(str) {
  if (typeof str === "string") {
    return str.startsWith("http://") || str.startsWith("https://");
  }
  return false;
}
function createLink(leaf, url, name, title) {
  return leaf.createEl("a", {
    attr: { href: url, title: title || null },
    text: name || url
  });
}

// src/obsidian-api-helpers/file-by-path.ts
var import_obsidian2 = require("obsidian");
function openFileByPath(plugin, filePath) {
  const file = plugin.app.metadataCache.getFirstLinkpathDest(filePath, "");
  if (!file) {
    new import_obsidian2.Notice("Could not open " + filePath);
    return;
  }
  const leaf = plugin.app.workspace.getUnpinnedLeaf();
  leaf.openFile(file, { active: true });
}

// src/ui/render-export.ts
var import_url4 = require("url");

// src/export/exporter.ts
var import_fs5 = require("fs");
var import_obsidian3 = require("obsidian");

// src/utils/normalize-query.ts
function normalizeQuery(userQuery) {
  let query = "";
  const lowerCaseQuery = userQuery.toLocaleLowerCase().trim();
  if (lowerCaseQuery.startsWith("from") || lowerCaseQuery.startsWith("where") || lowerCaseQuery.startsWith("group by") || lowerCaseQuery.startsWith("limit") || lowerCaseQuery.startsWith("flatten")) {
    query = "table file " + userQuery;
  } else {
    query = "table file where " + userQuery;
  }
  return query;
}

// src/utils/indexing/create-path-map.ts
var import_path = __toESM(require("path"));

// src/utils/normalize-file-name.ts
function normalizeFileName(fileName) {
  return String(fileName || "").toLowerCase().replace(/_|\s|\.|,|\(|\)|\[|\]/g, "-").replace(/[^A-Za-z0-9\-_]/g, "");
}

// src/utils/indexing/create-path-map.ts
var import_scoped_eval = __toESM(require_dist());
function createPathMap(queryResults, settings) {
  const foundFileMap = {};
  const targetRoot = settings.outputFolder || "";
  queryResults.map(([link, fileDescriptor]) => {
    try {
      const { targetPath } = getTargetPaths(fileDescriptor, settings);
      const newFileName = (0, import_path.basename)(targetPath);
      const extension = fileDescriptor.path.substring(fileDescriptor.path.lastIndexOf("."));
      const newExportPropertyItem = {
        file: fileDescriptor,
        frontMatter: fileDescriptor.frontmatter,
        from: fileDescriptor.path,
        newFileName,
        toAbsoluteFs: (0, import_path.join)(targetRoot, targetPath + extension),
        toRelative: targetPath + extension,
        md5: "",
        content: "",
        outputContent: "",
        toRelativeToExportDirRoot: import_path.default.parse(targetPath).dir,
        lastExportDate: 0
      };
      foundFileMap[fileDescriptor.path] = newExportPropertyItem;
    } catch (e) {
      console.error(e);
      error("File Export Error: ", fileDescriptor.path);
    }
  });
  return foundFileMap;
}
function getTargetPaths(fileDescriptor, settings) {
  const fileMetaData = {};
  Object.assign(fileMetaData, fileDescriptor.frontmatter);
  Object.assign(fileMetaData, {
    // @ts-ignore
    created: getDateKeys(fileDescriptor.ctime.ts),
    // @ts-ignore
    modified: getDateKeys(fileDescriptor.mtime.ts),
    fileName: import_path.default.parse(fileDescriptor.path).name,
    // Use it like this: ${norm(someMetaData)} - will replace every separator
    // character with a dash (-).
    norm: normalizeFileName,
    baseName: (0, import_path.basename)(fileDescriptor.path),
    slug: fileMetaData.slug || normalizeFileName(fileMetaData.title) || normalizeFileName(import_path.default.parse(fileDescriptor.path).name)
  });
  Object.assign(fileMetaData, { d: getDateKeys });
  try {
    const scopedEval = new import_scoped_eval.default();
    return {
      targetPath: scopedEval.eval("`" + settings.outputFormat + "`", fileMetaData)
      // relativeRoot: scopedEval.eval("`" + settings.relativeFileRoot + "`", fileMetaData)
    };
  } catch (e) {
    console.error(e);
    error(e);
    throw e;
  }
}
function getDateKeys(randomDateFormat) {
  const ret = {};
  const date = new Date(randomDateFormat);
  ret.YYYY = String(date.getFullYear());
  ret.YY = ret.YYYY.substring(2);
  ret.M = String(date.getMonth() + 1);
  ret.MM = ret.M.padStart(2, "0");
  ret.D = String(date.getDate());
  ret.DD = String(date.getDate()).padStart(2, "0");
  ret.h = String(date.getHours());
  ret.hh = String(date.getHours()).padStart(2, "0");
  ret.m = String(date.getMinutes());
  ret.mm = String(date.getMinutes()).padStart(2, "0");
  ret.s = String(date.getSeconds());
  ret.ss = String(date.getSeconds()).padStart(2, "0");
  ret.date = `${ret.YYYY}-${ret.MM}-${ret.DD}`;
  ret.time = `${ret.hh}-${ret.mm}`;
  return ret;
}

// src/export/exporter.ts
var import_ts_md52 = __toESM(require_cjs());

// src/ui/file-list-export-indicator.ts
var FileListItemWrapper = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Cleans up after itself.
   */
  clean() {
    const fileExplorers = this.plugin.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      const fileExplorerFileItems = fileExplorer.view.fileItems;
      Object.entries(fileExplorerFileItems).forEach(
        ([path3, fileItem]) => {
          var _a3;
          const fileItemElement = fileItem.selfEl;
          (_a3 = fileItemElement.querySelector(".export-plugin-icon")) == null ? void 0 : _a3.remove();
        }
      );
    });
  }
  /**
   * Adds an icon before the name element in file-explorer view
   */
  async applyStatusIcons(fileMap, settings) {
    const lastExport = settings.lastExport || {};
    const fileExplorers = this.plugin.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      const fileExplorerFileItems = fileExplorer.view.fileItems;
      Object.entries(fileExplorerFileItems).forEach(
        ([path3, fileItem]) => {
          const fileItemElement = fileItem.selfEl;
          if (fileMap[path3] && fileMap[path3].file) {
            this.applyStatusIconToFile(
              fileItemElement,
              path3,
              lastExport[path3],
              fileMap[path3].frontMatter,
              settings
            );
          }
        }
      );
    });
  }
  updateElementStatus(exportProperties, settings) {
    const lastExport = settings.lastExport || {};
    const fileExplorers = this.plugin.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((fileExplorer) => {
      const fileExplorerFileItems = fileExplorer.view.fileItems;
      const fileExplorerFileItem = fileExplorerFileItems[exportProperties.from];
      if (!fileExplorerFileItem) {
        console.warn(
          "[Exporter] [File List Indicator] Could not find",
          exportProperties.from
        );
        return;
      }
      const fileItemElement = fileExplorerFileItem.selfEl;
      if (!exportProperties.file) {
        return;
      }
      this.applyStatusIconToFile(
        fileItemElement,
        exportProperties.from,
        lastExport[exportProperties.from],
        exportProperties.frontMatter,
        settings
      );
    });
  }
  applyStatusIconToFile(element, path3, alreadyExported, frontMatter, settings) {
    let iconSpanAddedAlready = element.querySelector(".export-plugin-icon");
    if (!iconSpanAddedAlready) {
      iconSpanAddedAlready = createSpan({
        cls: "export-plugin-icon",
        text: ""
      });
      element.prepend(iconSpanAddedAlready);
    }
    this.removeClasses(iconSpanAddedAlready, "green orange lime");
    iconSpanAddedAlready.innerHTML = "";
    if (settings.isPublishedField && frontMatter && (!settings.isPublishedField || !frontMatter[settings.isPublishedField])) {
      iconSpanAddedAlready.classList.add("grey");
      iconSpanAddedAlready.append(getIcon("file-plus"));
      iconSpanAddedAlready.title = "Draft - " + settings.name;
      return;
    }
    if (!alreadyExported) {
      iconSpanAddedAlready.classList.add("lime");
      iconSpanAddedAlready.append(getIcon("file-plus"));
      iconSpanAddedAlready.title = "New - Added After Last Export - " + settings.name;
    } else {
      const file = this.plugin.app.metadataCache.getFirstLinkpathDest(
        path3,
        ""
      );
      const lastModifyDateOfFile = new Date(file == null ? void 0 : file.stat.mtime).getTime();
      const lastExportedDate = new Date(
        alreadyExported.lastExportDate
      ).getTime();
      if (lastModifyDateOfFile === lastExportedDate) {
        iconSpanAddedAlready.classList.add("green");
        iconSpanAddedAlready.append(getIcon("check-circle"));
        iconSpanAddedAlready.title = "Up to date - " + settings.name;
      } else {
        iconSpanAddedAlready.classList.add("orange");
        iconSpanAddedAlready.append(getIcon("file-plus"));
        iconSpanAddedAlready.title = "Modified Since Last Export - " + settings.name;
      }
    }
  }
  removeClasses(element, str) {
    str.split(" ").forEach((cls) => {
      element.classList.remove(cls);
    });
  }
};

// src/export/get-links-and-attachments.ts
var import_markdown_it = __toESM(require_markdown_it());

// src/utils/replace-all.ts
function replaceAll(hay, stack, replaceTo) {
  return stack.replace(new RegExp(escapeRegExp(hay), "g"), replaceTo);
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/export/get-links-and-attachments.ts
var DOUBLE_BRACKET_LINK_MATCHER = /\[\[([^\]]+)\]\]/g;
var IMAGE_MATCHER = /(([^\s]*).(png|jpe?g|gif|webp|svg|pdf|doc|docx|xls|xlsx|txt))/;
var md = new import_markdown_it.default();
function getLinksAndAttachments(markdown) {
  markdown = replaceDoubleBracketLinks(markdown);
  const parsedMarkdown = md.parse(markdown, {});
  const links = extractLinks(parsedMarkdown);
  const attachments = extractAttachments(parsedMarkdown);
  const headerAttachments = extractHeaderAttachments(markdown);
  return {
    markdownReplacedWikiStyleLinks: markdown,
    parsedMarkdown,
    links,
    attachments,
    externalLinks: links.filter((l) => l.linkType === 1 /* external */),
    internalLinks: links.filter((l) => l.linkType === 0 /* internal */),
    externalAttachments: attachments.filter((l) => l.linkType === 1 /* external */),
    internalAttachments: attachments.filter((l) => l.linkType === 0 /* internal */),
    internalHeaderAttachments: headerAttachments.filter((l) => l.linkType === 0 /* internal */),
    externalHeaderAttachments: headerAttachments.filter((l) => l.linkType === 1 /* external */)
  };
}
function replaceDoubleBracketLinks(markdown) {
  const results = markdown.match(DOUBLE_BRACKET_LINK_MATCHER);
  if (results) {
    results.forEach((link) => {
      let linkTarget = link.substring(2, link.length - 2);
      let text = linkTarget;
      const linkParts = linkTarget.split("|");
      if (linkParts.length > 1 && linkParts[0].trim()) {
        linkTarget = linkParts.shift() || "";
        text = linkParts.join("|");
      }
      const standardLinkStyle = `[${text}](${encodeURIComponent(linkTarget)})`;
      markdown = replaceAll(link, markdown, standardLinkStyle);
    });
  }
  return markdown;
}
function extractHeaderAttachments(content) {
  const contentSplitByHrDashes = content.split("\n---\n");
  const frontMatterPart = contentSplitByHrDashes.shift() || "";
  const keyValuePairs = {};
  frontMatterPart.split("\n").forEach((line) => {
    if (line.indexOf(":") > 0) {
      if (!line) {
        throw new Error("Empty line?");
      }
      const keyValueSplitArray = line.split(":");
      const key = keyValueSplitArray.shift();
      if (!key) {
        throw new Error("Invalid YAML: no key value in line");
      }
      const value = keyValueSplitArray.join(":");
      keyValuePairs[key] = {
        key,
        value
      };
    }
  });
  const ret = [];
  Object.keys(keyValuePairs).forEach((key) => {
    const valueAndToken = keyValuePairs[key];
    const imageValue = valueAndToken.value.trim().toLocaleLowerCase().match(IMAGE_MATCHER);
    if (imageValue) {
      ret.push({
        originalPath: imageValue[0],
        normalizedOriginalPath: normalizeUrl(imageValue[0]),
        linkType: getTypeofUrl(normalizeUrl(imageValue[0])),
        source: "frontMatter",
        text: key
      });
    }
  });
  return ret;
}
function extractAttachments(tokens, attachments = []) {
  for (const token of tokens) {
    if (token.children && token.children.length > 0) {
      extractAttachments(token.children, attachments);
    }
    if (token.type === "image") {
      const url = token.attrGet("src") || "";
      attachments.push({
        text: token.attrGet("alt") || "",
        originalPath: url,
        normalizedOriginalPath: normalizeUrl(url),
        linkType: getTypeofUrl(normalizeUrl(url)),
        source: "body",
        token
      });
    }
  }
  return attachments;
}
function extractLinks(tokens, links = []) {
  for (const token of tokens) {
    if (token.children && token.children.length > 0) {
      extractLinks(token.children, links);
    }
    if (token.type === "link_open") {
      const linkTextToken = tokens[tokens.indexOf(token) + 1];
      if ((linkTextToken == null ? void 0 : linkTextToken.type) === "text" && (linkTextToken == null ? void 0 : linkTextToken.content)) {
        const url = token.attrGet("href") || "";
        links.push({
          text: linkTextToken.content,
          originalPath: url,
          normalizedOriginalPath: normalizeUrl(url),
          linkType: getTypeofUrl(normalizeUrl(url)),
          source: "body",
          token
        });
      }
    }
  }
  return links;
}
function normalizeUrl(url) {
  if (url.startsWith("obsidian://")) {
    const fileLink = decodeURIComponent(
      url.substring(url.indexOf("&file=") + 6)
    );
    url = fileLink;
  }
  return url;
}
function getTypeofUrl(url) {
  if (url.startsWith("http")) {
    return 1 /* external */;
  } else {
    return 0 /* internal */;
  }
}

// src/export/export-log.ts
function exportedLogEntry(outputPathMap, plugin) {
  let errorCount = 0;
  const root2 = createDiv({ text: "Export Structure", cls: "pull-in" });
  Object.keys(outputPathMap).sort().forEach((pathKey) => {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    const arrayOfFiles = outputPathMap[pathKey];
    const pathContainer = root2.createDiv();
    const pathToggler = pathContainer.createDiv({ cls: "clickable", text: `${pathKey} (${arrayOfFiles.length})` });
    pathToggler.addEventListener("click", () => pathFileListElement.classList.toggle("export-stats-open"));
    const pathFileListElement = pathContainer.createDiv({ cls: "export-stats" });
    for (let i = 0; i < arrayOfFiles.length; i++) {
      const fileExportProperties = outputPathMap[pathKey][i];
      if (!fileExportProperties)
        return;
      const linkToFileElement = createDiv({ cls: "clickable", text: fileExportProperties.toRelative });
      const imageCount = (((_a3 = fileExportProperties.imageInBody) == null ? void 0 : _a3.length) || 0) + (((_b2 = fileExportProperties.imageInMeta) == null ? void 0 : _b2.length) || 0);
      const exportStats = createDiv({
        text: `${((_c2 = fileExportProperties.linkStats) == null ? void 0 : _c2.length) || 0} Local links, ${imageCount} images.`,
        cls: "export-stats"
      });
      exportStats.classList.add("pull-in");
      const linkButton = exportStats.createEl("a");
      const newLink = getIcon("external-link");
      linkButton.append(newLink);
      linkButton.addEventListener("click", () => openFileByPath(plugin, fileExportProperties.from));
      linkToFileElement.addEventListener("click", () => exportStats.classList.toggle("export-stats-open"));
      const linkStatContainer = exportStats.createDiv({ text: `Links found: ${((_d2 = fileExportProperties.linkStats) == null ? void 0 : _d2.length) || 0}` });
      (_e2 = fileExportProperties.linkStats) == null ? void 0 : _e2.forEach((linkStat) => {
        const link = linkStatContainer.createDiv({
          cls: "pull-in clickable",
          text: `${linkStat.linkType} `
        });
        const linkText = link.createEl("a", { text: linkStat.text || linkStat.originalPath || linkStat.newPath, title: linkStat.originalPath + " -> " + linkStat.newPath });
        linkText.append(getIcon("external-link"));
        linkText.addEventListener("click", (evt) => {
          evt.stopPropagation();
          if (linkStat.linkType === 1 /* external */) {
            window.open(linkStat.originalPath);
          } else {
            openFileByPath(plugin, linkStat.originalPath);
          }
        });
      });
      const assetStatContainer = exportStats.createDiv({ text: `Image From Body Copied: ${((_f2 = fileExportProperties.imageInBody) == null ? void 0 : _f2.length) || 0}` });
      (_g2 = fileExportProperties.imageInBody) == null ? void 0 : _g2.forEach((asset) => {
        const fileAssetElement = fileAssetElementCreator(asset, errorCount, plugin);
        errorCount = fileAssetElement.errorCount;
        if (errorCount > 0) {
          console.error(asset);
        }
        assetStatContainer.append(fileAssetElement.assetElement);
      });
      (_h2 = fileExportProperties.imageInMeta) == null ? void 0 : _h2.forEach((asset) => {
        const fileAssetElement = fileAssetElementCreator(asset, errorCount, plugin);
        errorCount = fileAssetElement.errorCount;
        if (errorCount > 0) {
          console.error(asset);
        }
        assetStatContainer.append(fileAssetElement.assetElement);
      });
      if (fileExportProperties.copyGlob && Object.keys(fileExportProperties.copyGlob).length) {
        const globContainer = assetStatContainer.createDiv({ text: "copy globs" });
        Object.keys(fileExportProperties.copyGlob || {}).forEach((globKey) => {
          if (!globKey || !fileExportProperties.copyGlob)
            return;
          const arrayOfAssets = fileExportProperties.copyGlob[globKey];
          const globGroupContainer = globContainer.createDiv({
            cls: "pull-in",
            text: `${globKey} (${arrayOfAssets.length})`
          });
          arrayOfAssets.forEach((asset) => {
            const fileAssetElement = fileAssetElementCreator(asset, errorCount, plugin);
            errorCount = fileAssetElement.errorCount;
            if (errorCount > 0) {
              console.error(asset);
            }
            if (asset.source === "folder") {
              globGroupContainer.append(createSpan("[Folder] "));
            }
            globGroupContainer.append(fileAssetElement.assetElement);
          });
        });
      }
      const container = createSpan({ "text": "" });
      container.append(linkToFileElement, exportStats);
      if (errorCount) {
        container.classList.add("error");
        container.append(createSpan({ text: ` ${errorCount} errors` }));
      }
      pathFileListElement.append(container);
    }
  });
  log(root2);
}
function fileAssetElementCreator(asset, errorCount, plugin) {
  const assetElement = createEl("a", {
    cls: "clickable-link",
    title: asset.newPath,
    text: `${asset.originalPath || asset.newPath}`
  });
  if (asset.count && asset.count > 1) {
    assetElement.innerText += ` (${asset.count})`;
  }
  assetElement.classList.add("pull-in");
  if (asset.status === "assetNotFound") {
    errorCount++;
    assetElement.classList.add("error");
  } else {
    assetElement.addEventListener("click", (evt) => {
      evt.stopPropagation();
      openFileByPath(plugin, asset.originalPath);
    });
  }
  return {
    assetElement,
    errorCount
  };
}

// src/export/exporter.ts
var import_path7 = require("path");

// src/utils/shell-runner.ts
var import_child_process = require("child_process");
function runShellCommand(commandWithArgs) {
  const list = commandWithArgs.split(" ");
  const command = list[0];
  const args = list.splice(1);
  return runShellCommandWithArgs(command, args);
}
function runShellCommandWithArgs(command, args = []) {
  return new Promise((resolve, reject2) => {
    log("starting: ", command);
    log("args: ", args);
    const outputContainer = createDiv({ cls: "pull-in" });
    const errorsHeader = outputContainer.createDiv();
    const errorsContainer = outputContainer.createDiv({ cls: "pull-in" });
    const allOutputHeader = outputContainer.createDiv();
    const allOutputContainer = outputContainer.createDiv({ cls: "closed pull-in" });
    const toggler = createSpan({ cls: "clickable", text: "output" });
    const status = toggler.createSpan({ text: "(" });
    const statusLogLineCounter = createSpan({ text: "0" });
    const statusErrorCounter = createSpan({ text: "0" });
    status.append(statusLogLineCounter);
    status.append(", errors: ");
    status.append(statusErrorCounter);
    status.append(")");
    let logLines = 0;
    let errors = 0;
    const errorsTogglerChevron = createSpan({ cls: "clickable", text: "Errors" });
    errorsTogglerChevron.append(getIcon("chevron-down"));
    errorsHeader.append(errorsTogglerChevron);
    const allTogglerChevron = createSpan({ cls: "clickable", text: "All Output" });
    allTogglerChevron.append(getIcon("chevron-down"));
    allOutputHeader.append(allTogglerChevron);
    allTogglerChevron.addEventListener("click", () => {
      allOutputContainer.classList.toggle("closed");
      allTogglerChevron.classList.toggle("rotate-180");
    });
    errorsTogglerChevron.addEventListener("click", () => {
      errorsContainer.classList.toggle("closed");
      errorsTogglerChevron.classList.toggle("rotate-180");
    });
    log(toggler, outputContainer);
    const scriptProcess = (0, import_child_process.spawn)(command, args, {
      shell: true,
      env: process.env
    });
    scriptProcess.stdout.on("data", (data) => {
      const lines = data.toString().trim().split("\n");
      lines.forEach((line) => {
        logEntry(allOutputContainer, COLORS.LOG, line);
        logLines++;
        statusLogLineCounter.innerText = logLines.toString();
      });
    });
    scriptProcess.stderr.on("data", (data) => {
      logEntry(errorsContainer, COLORS.ERROR, data.toString());
      logEntry(allOutputContainer, COLORS.ERROR, data.toString());
      errors++;
      statusErrorCounter.innerText = errors.toString();
      statusErrorCounter.style.color = COLORS.ERROR;
    });
    scriptProcess.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        error(`Command exited with code ${code}`);
        reject2();
      }
    });
  });
}

// src/utils/data-view-api.ts
var import_obsidian_dataview = __toESM(require_lib2());
function getDataViewApi() {
  const dataViewApi = (0, import_obsidian_dataview.getAPI)();
  if (!dataViewApi) {
    error("DataView is not loaded yet!");
    throw new Error("Dataview is not loaded yet!");
  }
  return dataViewApi;
}

// src/export/get-markdown-attachments.ts
var import_fs = require("fs");
var import_path3 = require("path");
var import_ts_md5 = __toESM(require_cjs());

// src/utils/indexing/asset-and-link-paths.ts
var import_path2 = require("path");
function getAssetPaths(exportProperties, settings) {
  const assetFolderName = settings.assetPath || "assets";
  let toDir = (0, import_path2.join)((0, import_path2.dirname)(exportProperties.toAbsoluteFs), assetFolderName);
  let toDirRelative = assetFolderName;
  if (settings.absoluteAssets) {
    toDirRelative = "/" + assetFolderName;
    toDir = (0, import_path2.join)(settings.outputFolder, assetFolderName);
  }
  return {
    toDir,
    toDirRelative
  };
}

// src/export/get-markdown-attachments.ts
var META_KEY_IGNORE_LIST = ["copy"];
function collectAndReplaceHeaderAttachments(plugin, settings, exportProperties, attachments) {
  attachments.forEach((attachment) => {
    if (attachment.source === "frontMatter" && META_KEY_IGNORE_LIST.indexOf(attachment.text) > -1) {
      return;
    }
    saveAttachmentToLocation(plugin, settings, attachment, exportProperties);
    if (attachment.newPath) {
      const contentSplitByHrDashes = exportProperties.outputContent.split("\n---\n");
      let frontMatterPart = contentSplitByHrDashes.shift() || "";
      frontMatterPart = replaceAll(attachment.originalPath, frontMatterPart, attachment.newPath);
      contentSplitByHrDashes.unshift(frontMatterPart);
      exportProperties.outputContent = contentSplitByHrDashes.join("\n---\n");
    }
  });
}
function collectAndReplaceInlineAttachments(plugin, settings, exportProperties, attachments) {
  attachments.forEach((attachment) => {
    saveAttachmentToLocation(plugin, settings, attachment, exportProperties);
    exportProperties.outputContent = replaceAll(`](${attachment.originalPath})`, exportProperties.outputContent, `](${attachment.newPath})`);
  });
}
async function saveAttachmentToLocation(plugin, settings, attachment, exportProperties) {
  const imageLink = decodeURIComponent(attachment.originalPath);
  const imageName = (0, import_path3.basename)(imageLink);
  const imageNameWithoutExtension = imageName.substring(0, imageName.lastIndexOf("."));
  const imageExtension = imageName.substring(imageName.lastIndexOf("."));
  const asset = plugin.app.metadataCache.getFirstLinkpathDest(imageLink, exportProperties.from);
  if (!asset) {
    attachment.error = "Asset not found!";
    attachment.status = "assetNotFound";
    return;
  }
  const { toDir, toDirRelative } = getAssetPaths(exportProperties, settings);
  const imageLinkMd5 = import_ts_md5.Md5.hashStr(asset.path);
  const imageTargetFileName = imageNameWithoutExtension + "-" + imageLinkMd5 + imageExtension;
  const documentLink = (0, import_path3.join)(toDirRelative, imageTargetFileName);
  attachment.newPath = documentLink;
  const assetAbsoluteTarget = (0, import_path3.join)(toDir, imageTargetFileName);
  const absoluteTargetDir = (0, import_path3.dirname)(assetAbsoluteTarget);
  if (!(0, import_fs.existsSync)(absoluteTargetDir)) {
    (0, import_fs.mkdirSync)(absoluteTargetDir, { recursive: true });
  }
  if ((0, import_fs.existsSync)(assetAbsoluteTarget)) {
    return;
  }
  const basePath = plugin.app.vault.adapter.basePath;
  if (basePath) {
    const fullAssetPath = (0, import_path3.join)(
      basePath,
      asset.path
    );
    (0, import_fs.copyFileSync)(fullAssetPath, assetAbsoluteTarget);
  } else {
    const assetContent = await plugin.app.vault.readBinary(asset);
    (0, import_fs.writeFileSync)(assetAbsoluteTarget, Buffer.from(assetContent));
  }
}

// node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});

// node_modules/underscore/modules/_setup.js
var VERSION = "1.13.6";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push;
var slice = ArrayProto.slice;
var toString = ObjProto.toString;
var hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
var supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray;
var nativeKeys = Object.keys;
var nativeCreate = Object.create;
var nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN;
var _isFinite = isFinite;
var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
var nonEnumerableProps = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

// node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}

// node_modules/underscore/modules/isObject.js
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}

// node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}

// node_modules/underscore/modules/isUndefined.js
function isUndefined(obj) {
  return obj === void 0;
}

// node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}

// node_modules/underscore/modules/isElement.js
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

// node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}

// node_modules/underscore/modules/isString.js
var isString_default = tagTester("String");

// node_modules/underscore/modules/isNumber.js
var isNumber_default = tagTester("Number");

// node_modules/underscore/modules/isDate.js
var isDate_default = tagTester("Date");

// node_modules/underscore/modules/isRegExp.js
var isRegExp_default = tagTester("RegExp");

// node_modules/underscore/modules/isError.js
var isError_default = tagTester("Error");

// node_modules/underscore/modules/isSymbol.js
var isSymbol_default = tagTester("Symbol");

// node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default = tagTester("ArrayBuffer");

// node_modules/underscore/modules/isFunction.js
var isFunction = tagTester("Function");
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
  isFunction = function(obj) {
    return typeof obj == "function" || false;
  };
}
var isFunction_default = isFunction;

// node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default = tagTester("Object");

// node_modules/underscore/modules/_stringTagBug.js
var hasStringTagBug = supportsDataView && hasObjectTag_default(new DataView(new ArrayBuffer(8)));
var isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());

// node_modules/underscore/modules/isDataView.js
var isDataView = tagTester("DataView");
function ie10IsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView_default = hasStringTagBug ? ie10IsDataView : isDataView;

// node_modules/underscore/modules/isArray.js
var isArray_default = nativeIsArray || tagTester("Array");

// node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}

// node_modules/underscore/modules/isArguments.js
var isArguments = tagTester("Arguments");
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has(obj, "callee");
    };
  }
})();
var isArguments_default = isArguments;

// node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}

// node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}

// node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}

// node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}

// node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}

// node_modules/underscore/modules/_getByteLength.js
var getByteLength_default = shallowProperty("byteLength");

// node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default = createSizePropertyCheck(getByteLength_default);

// node_modules/underscore/modules/isTypedArray.js
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);

// node_modules/underscore/modules/_getLength.js
var getLength_default = shallowProperty("length");

// node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l = keys2.length, i = 0; i < l; ++i)
    hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}

// node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject(obj))
    return [];
  if (nativeKeys)
    return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj)
    if (has(obj, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}

// node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null)
    return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj)))
    return length === 0;
  return getLength_default(keys(obj)) === 0;
}

// node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj))
      return false;
  }
  return true;
}

// node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _)
    return obj;
  if (!(this instanceof _))
    return new _(obj);
  this._wrapped = obj;
}
_.VERSION = VERSION;
_.prototype.value = function() {
  return this._wrapped;
};
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
_.prototype.toString = function() {
  return String(this._wrapped);
};

// node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}

// node_modules/underscore/modules/isEqual.js
var tagDataView = "[object DataView]";
function eq(a, b, aStack, bStack) {
  if (a === b)
    return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null)
    return false;
  if (a !== a)
    return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object")
    return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _)
    a = a._wrapped;
  if (b instanceof _)
    b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b))
    return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView_default(a)) {
    if (!isDataView_default(b))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a)
        return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a)) {
    var byteLength = getByteLength_default(a);
    if (byteLength !== getByteLength_default(b))
      return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object")
      return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a)
      return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length)
      return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}

// node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject(obj))
    return [];
  var keys2 = [];
  for (var key in obj)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}

// node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null)
      return false;
    var keys2 = allKeys(obj);
    if (getLength_default(keys2))
      return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction_default(obj[methods[i]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName = "forEach";
var hasName = "has";
var commonInit = ["clear", "delete"];
var mapTail = ["get", hasName, "set"];
var mapMethods = commonInit.concat(forEachName, mapTail);
var weakMapMethods = commonInit.concat(mapTail);
var setMethods = ["add"].concat(commonInit, forEachName, hasName);

// node_modules/underscore/modules/isMap.js
var isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");

// node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");

// node_modules/underscore/modules/isSet.js
var isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");

// node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default = tagTester("WeakSet");

// node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj[_keys[i]];
  }
  return values2;
}

// node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs2;
}

// node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj[_keys[i]]] = _keys[i];
  }
  return result2;
}

// node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key]))
      names.push(key);
  }
  return names.sort();
}

// node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults2) {
  return function(obj) {
    var length = arguments.length;
    if (defaults2)
      obj = Object(obj);
    if (length < 2 || obj == null)
      return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
      for (var i = 0; i < l; i++) {
        var key = keys2[i];
        if (!defaults2 || obj[key] === void 0)
          obj[key] = source[key];
      }
    }
    return obj;
  };
}

// node_modules/underscore/modules/extend.js
var extend_default = createAssigner(allKeys);

// node_modules/underscore/modules/extendOwn.js
var extendOwn_default = createAssigner(keys);

// node_modules/underscore/modules/defaults.js
var defaults_default = createAssigner(allKeys, true);

// node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}

// node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn_default(result2, props);
  return result2;
}

// node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject(obj))
    return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}

// node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

// node_modules/underscore/modules/toPath.js
function toPath(path3) {
  return isArray_default(path3) ? path3 : [path3];
}
_.toPath = toPath;

// node_modules/underscore/modules/_toPath.js
function toPath2(path3) {
  return _.toPath(path3);
}

// node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path3) {
  var length = path3.length;
  for (var i = 0; i < length; i++) {
    if (obj == null)
      return void 0;
    obj = obj[path3[i]];
  }
  return length ? obj : void 0;
}

// node_modules/underscore/modules/get.js
function get(object2, path3, defaultValue) {
  var value = deepGet(object2, toPath2(path3));
  return isUndefined(value) ? defaultValue : value;
}

// node_modules/underscore/modules/has.js
function has2(obj, path3) {
  path3 = toPath2(path3);
  var length = path3.length;
  for (var i = 0; i < length; i++) {
    var key = path3[i];
    if (!has(obj, key))
      return false;
    obj = obj[key];
  }
  return !!length;
}

// node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}

// node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}

// node_modules/underscore/modules/property.js
function property(path3) {
  path3 = toPath2(path3);
  return function(obj) {
    return deepGet(obj, path3);
  };
}

// node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0)
    return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}

// node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction_default(value))
    return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray_default(value))
    return matcher(value);
  return property(value);
}

// node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_.iteratee = iteratee;

// node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee)
    return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

// node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}

// node_modules/underscore/modules/noop.js
function noop() {
}

// node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null)
    return noop;
  return function(path3) {
    return get(obj, path3);
  };
}

// node_modules/underscore/modules/times.js
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++)
    accum[i] = iteratee2(i);
  return accum;
}

// node_modules/underscore/modules/random.js
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}

// node_modules/underscore/modules/now.js
var now_default = Date.now || function() {
  return new Date().getTime();
};

// node_modules/underscore/modules/_createEscaper.js
function createEscaper(map2) {
  var escaper = function(match2) {
    return map2[match2];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

// node_modules/underscore/modules/_escapeMap.js
var escapeMap_default = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

// node_modules/underscore/modules/escape.js
var escape_default = createEscaper(escapeMap_default);

// node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default = invert(escapeMap_default);

// node_modules/underscore/modules/unescape.js
var unescape_default = createEscaper(unescapeMap_default);

// node_modules/underscore/modules/templateSettings.js
var templateSettings_default = _.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};

// node_modules/underscore/modules/template.js
var noMatch = /(.)^/;
var escapes = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
var escapeRegExp2 = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match2) {
  return "\\" + escapes[match2];
}
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match2, escape2, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp2, escapeChar);
    index = offset + match2.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match2;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}

// node_modules/underscore/modules/result.js
function result(obj, path3, fallback) {
  path3 = toPath2(path3);
  var length = path3.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path3[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

// node_modules/underscore/modules/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}

// node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}

// node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2))
    return result2;
  return self2;
}

// node_modules/underscore/modules/partial.js
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length)
      args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _;
var partial_default = partial;

// node_modules/underscore/modules/bind.js
var bind_default = restArguments(function(func, context, args) {
  if (!isFunction_default(func))
    throw new TypeError("Bind must be called on a function");
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
});

// node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default = createSizePropertyCheck(getLength_default);

// node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength_default(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len)
          output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

// node_modules/underscore/modules/bindAll.js
var bindAll_default = restArguments(function(obj, keys2) {
  keys2 = flatten(keys2, false, false);
  var index = keys2.length;
  if (index < 1)
    throw new Error("bindAll must be passed function names");
  while (index--) {
    var key = keys2[index];
    obj[key] = bind_default(obj[key], obj);
  }
  return obj;
});

// node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address))
      cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}

// node_modules/underscore/modules/delay.js
var delay_default = restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
});

// node_modules/underscore/modules/defer.js
var defer_default = partial_default(delay_default, _, 1);

// node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}

// node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate)
        result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}

// node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}

// node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

// node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--)
      result2 = args[i].call(this, result2);
    return result2;
  };
}

// node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}

// node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1)
      func = null;
    return memo;
  };
}

// node_modules/underscore/modules/once.js
var once_default = partial_default(before, 2);

// node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj))
      return key;
  }
}

// node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array))
        return index;
    }
    return -1;
  };
}

// node_modules/underscore/modules/findIndex.js
var findIndex_default = createPredicateIndexFinder(1);

// node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default = createPredicateIndexFinder(-1);

// node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}

// node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN2);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}

// node_modules/underscore/modules/indexOf.js
var indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);

// node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);

// node_modules/underscore/modules/find.js
function find(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj[key];
}

// node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}

// node_modules/underscore/modules/each.js
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike_default(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee2(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}

// node_modules/underscore/modules/map.js
function map(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}

// node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}

// node_modules/underscore/modules/reduce.js
var reduce_default = createReduce(1);

// node_modules/underscore/modules/reduceRight.js
var reduceRight_default = createReduce(-1);

// node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list))
      results.push(value);
  });
  return results;
}

// node_modules/underscore/modules/reject.js
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

// node_modules/underscore/modules/every.js
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj))
      return false;
  }
  return true;
}

// node_modules/underscore/modules/some.js
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj))
      return true;
  }
  return false;
}

// node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj))
    obj = values(obj);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}

// node_modules/underscore/modules/invoke.js
var invoke_default = restArguments(function(obj, path3, args) {
  var contextPath, func;
  if (isFunction_default(path3)) {
    func = path3;
  } else {
    path3 = toPath2(path3);
    contextPath = path3.slice(0, -1);
    path3 = path3[path3.length - 1];
  }
  return map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null)
        return void 0;
      method = context[path3];
    }
    return method == null ? method : method.apply(context, args);
  });
});

// node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map(obj, property(key));
}

// node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}

// node_modules/underscore/modules/max.js
function max(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}

// node_modules/underscore/modules/min.js
function min(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}

// node_modules/underscore/modules/toArray.js
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj)
    return [];
  if (isArray_default(obj))
    return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj))
    return map(obj, identity);
  return values(obj);
}

// node_modules/underscore/modules/sample.js
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike_default(obj))
      obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}

// node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}

// node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0)
        return 1;
      if (a < b || b === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}

// node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index) {
      var key = iteratee2(value, index, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}

// node_modules/underscore/modules/groupBy.js
var groupBy_default = group(function(result2, value, key) {
  if (has(result2, key))
    result2[key].push(value);
  else
    result2[key] = [value];
});

// node_modules/underscore/modules/indexBy.js
var indexBy_default = group(function(result2, value, key) {
  result2[key] = value;
});

// node_modules/underscore/modules/countBy.js
var countBy_default = group(function(result2, value, key) {
  if (has(result2, key))
    result2[key]++;
  else
    result2[key] = 1;
});

// node_modules/underscore/modules/partition.js
var partition_default = group(function(result2, value, pass) {
  result2[pass ? 0 : 1].push(value);
}, true);

// node_modules/underscore/modules/size.js
function size(obj) {
  if (obj == null)
    return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}

// node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}

// node_modules/underscore/modules/pick.js
var pick_default = restArguments(function(obj, keys2) {
  var result2 = {}, iteratee2 = keys2[0];
  if (obj == null)
    return result2;
  if (isFunction_default(iteratee2)) {
    if (keys2.length > 1)
      iteratee2 = optimizeCb(iteratee2, keys2[1]);
    keys2 = allKeys(obj);
  } else {
    iteratee2 = keyInObj;
    keys2 = flatten(keys2, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys2.length; i < length; i++) {
    var key = keys2[i];
    var value = obj[key];
    if (iteratee2(value, key, obj))
      result2[key] = value;
  }
  return result2;
});

// node_modules/underscore/modules/omit.js
var omit_default = restArguments(function(obj, keys2) {
  var iteratee2 = keys2[0], context;
  if (isFunction_default(iteratee2)) {
    iteratee2 = negate(iteratee2);
    if (keys2.length > 1)
      context = keys2[1];
  } else {
    keys2 = map(flatten(keys2, false, false), String);
    iteratee2 = function(value, key) {
      return !contains(keys2, key);
    };
  }
  return pick_default(obj, iteratee2, context);
});

// node_modules/underscore/modules/initial.js
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

// node_modules/underscore/modules/first.js
function first(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[0];
  return initial(array, array.length - n);
}

// node_modules/underscore/modules/rest.js
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}

// node_modules/underscore/modules/last.js
function last(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}

// node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}

// node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}

// node_modules/underscore/modules/difference.js
var difference_default = restArguments(function(array, rest2) {
  rest2 = flatten(rest2, true, true);
  return filter(array, function(value) {
    return !contains(rest2, value);
  });
});

// node_modules/underscore/modules/without.js
var without_default = restArguments(function(array, otherArrays) {
  return difference_default(array, otherArrays);
});

// node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}

// node_modules/underscore/modules/union.js
var union_default = restArguments(function(arrays) {
  return uniq(flatten(arrays, true, true));
});

// node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item))
      continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item))
        break;
    }
    if (j === argsLength)
      result2.push(item);
  }
  return result2;
}

// node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}

// node_modules/underscore/modules/zip.js
var zip_default = restArguments(unzip);

// node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength_default(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}

// node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}

// node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1)
    return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}

// node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}

// node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}

// node_modules/underscore/modules/underscore-array-methods.js
each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === "shift" || name === "splice") && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});
each(["concat", "join", "slice"], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null)
      obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});
var underscore_array_methods_default = _;

// node_modules/underscore/modules/index-default.js
var _2 = mixin(modules_exports);
_2._ = _2;
var index_default_default = _2;

// node_modules/glob/node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// node_modules/glob/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/glob/node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob2, position) => {
  const pos = position;
  if (glob2.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate2 = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i < glob2.length) {
      const c = glob2.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate2 = true;
        i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob2.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob2.length - pos, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob2.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-"));
        i += 2;
        continue;
      }
      if (glob2.startsWith("-", i + 1)) {
        rangeStart = c;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob2.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate2) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate2 ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate2 ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/glob/node_modules/minimatch/dist/mjs/unescape.js
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/glob/node_modules/minimatch/dist/mjs/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
var _AST = class {
  constructor(type, parent, options = {}) {
    __privateAdd(this, _fillNegs);
    __privateAdd(this, _partsToRegExp);
    __publicField(this, "type");
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _hasMagic, void 0);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent, void 0);
    __privateAdd(this, _parentIndex, void 0);
    __privateAdd(this, _negs, void 0);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _toString, void 0);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type;
    if (type)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p of __privateGet(this, _parts)) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
        throw new Error("invalid part: " + p);
      }
      __privateGet(this, _parts).push(p);
    }
  }
  toJSON() {
    var _a3;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a3;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p = __privateGet(this, _parent);
    for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
      const pp = __privateGet(p, _parts)[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a3, _b2, _c2;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!")
      return true;
    if (!((_b2 = __privateGet(this, _parent)) == null ? void 0 : _b2.isEnd()))
      return false;
    if (!this.type)
      return (_c2 = __privateGet(this, _parent)) == null ? void 0 : _c2.isEnd();
    const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of __privateGet(this, _parts)) {
      c.copyIn(p);
    }
    return c;
  }
  static fromGlob(pattern, options = {}) {
    var _a3;
    const ast = new _AST(null, void 0, options);
    __privateMethod(_a3 = _AST, _parseAST, parseAST_fn).call(_a3, pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob2 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a3;
    const dot = allowDot != null ? allowDot : !!__privateGet(this, _options).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = __privateGet(this, _parts).map((p) => {
        var _a4;
        const [re, _3, hasMagic2, uflag] = typeof p === "string" ? __privateMethod(_a4 = _AST, _parseGlob, parseGlob_fn).call(_a4, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic2);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      __privateSet(this, _parts, [s]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
var AST = _AST;
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_fillNegs = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n;
  while (n = __privateGet(this, _negs).pop()) {
    if (n.type !== "!")
      continue;
    let p = n;
    let pp = __privateGet(p, _parent);
    while (pp) {
      for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
        for (const part of __privateGet(n, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp, _parts)[i]);
        }
      }
      p = pp;
      pp = __privateGet(p, _parent);
    }
  }
  return this;
};
_parseAST = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a3, _b2;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i2 = pos;
    let acc2 = "";
    while (i2 < str.length) {
      const c = str.charAt(i2++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc2 += c;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc2 += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c, ast);
        i2 = __privateMethod(_a3 = _AST, _parseAST, parseAST_fn).call(_a3, str, ext2, i2, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c;
    }
    ast.push(acc2);
    return i2;
  }
  let i = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i < str.length) {
    const c = str.charAt(i++);
    if (escaping || c === "\\") {
      escaping = !escaping;
      acc += c;
      continue;
    }
    if (inBrace) {
      if (i === braceStart + 1) {
        if (c === "^" || c === "!") {
          braceNeg = true;
        }
      } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c;
      continue;
    } else if (c === "[") {
      inBrace = true;
      braceStart = i;
      braceNeg = false;
      acc += c;
      continue;
    }
    if (isExtglobType(c) && str.charAt(i) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c, part);
      part.push(ext2);
      i = __privateMethod(_b2 = _AST, _parseAST, parseAST_fn).call(_b2, str, ext2, i, opt);
      continue;
    }
    if (c === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i;
    }
    acc += c;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i;
};
_partsToRegExp = new WeakSet();
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p) => {
    if (typeof p === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re, _3, _hasMagic2, uflag] = p.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re;
  }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
};
_parseGlob = new WeakSet();
parseGlob_fn = function(glob2, hasMagic2, noEmpty = false) {
  let escaping = false;
  let re = "";
  let uflag = false;
  for (let i = 0; i < glob2.length; i++) {
    const c = glob2.charAt(i);
    if (escaping) {
      escaping = false;
      re += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      if (i === glob2.length - 1) {
        re += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob2, i);
      if (consumed) {
        re += src;
        uflag = uflag || needUflag;
        i += consumed - 1;
        hasMagic2 = hasMagic2 || magic;
        continue;
      }
    }
    if (c === "*") {
      if (noEmpty && glob2 === "*")
        re += starNoEmpty;
      else
        re += star;
      hasMagic2 = true;
      continue;
    }
    if (c === "?") {
      re += qmark;
      hasMagic2 = true;
      continue;
    }
    re += regExpEscape(c);
  }
  return [re, unescape(glob2), !!hasMagic2, uflag];
};
__privateAdd(AST, _parseAST);
__privateAdd(AST, _parseGlob);

// node_modules/glob/node_modules/minimatch/dist/mjs/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/glob/node_modules/minimatch/dist/mjs/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path2 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter2 = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter2;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._3) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _3, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i] = matched;
        globParts[j] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result2 = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result2.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result2.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result2.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result2.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result2.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result2;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate2 = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate2 = !negate2;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate2;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial2 = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial2) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial2;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest ? Object.assign(re, { test: fastTest }) : re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial2 = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial2) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2; !filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0; i < set.length; i++) {
      const pattern = set[i];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial2);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// node_modules/path-scurry/node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_3, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a3, _b2;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      (_b2 = (_a3 = this.signal).onabort) == null ? void 0 : _b2.call(_a3, reason);
    }
  };
  let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size2) {
    super(size2);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class {
  constructor(max2, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max2);
    this.length = 0;
  }
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s = new _Stack(max2, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var Stack = _Stack;
_constructing = new WeakMap();
// private constructor
__privateAdd(Stack, _constructing, false);
var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
var _LRUCache = class {
  constructor(options) {
    __privateAdd(this, _initializeTTLTracking);
    __privateAdd(this, _initializeSizeTracking);
    __privateAdd(this, _indexes);
    __privateAdd(this, _rindexes);
    __privateAdd(this, _isValidIndex);
    __privateAdd(this, _evict);
    __privateAdd(this, _backgroundFetch);
    __privateAdd(this, _isBackgroundFetch);
    __privateAdd(this, _connect);
    __privateAdd(this, _moveToTail);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    __privateAdd(this, _max, void 0);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _dispose, void 0);
    __privateAdd(this, _disposeAfter, void 0);
    __privateAdd(this, _fetchMethod, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _calculatedSize, void 0);
    __privateAdd(this, _keyMap, void 0);
    __privateAdd(this, _keyList, void 0);
    __privateAdd(this, _valList, void 0);
    __privateAdd(this, _next, void 0);
    __privateAdd(this, _prev, void 0);
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _free, void 0);
    __privateAdd(this, _disposed, void 0);
    __privateAdd(this, _sizes, void 0);
    __privateAdd(this, _starts, void 0);
    __privateAdd(this, _ttls, void 0);
    __privateAdd(this, _hasDispose, void 0);
    __privateAdd(this, _hasFetchMethod, void 0);
    __privateAdd(this, _hasDisposeAfter, void 0);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i2) => {
    });
    __privateAdd(this, _addItemSize, (_i2, _s2, _st) => {
    });
    __privateAdd(this, _requireSize, (_k2, _v, size2, sizeCalculation) => {
      if (size2 || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    __privateSet(this, _max, max2);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max2).fill(void 0));
    __privateSet(this, _valList, new Array(max2).fill(void 0));
    __privateSet(this, _next, new UintArray(max2));
    __privateSet(this, _prev, new UintArray(max2));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max2));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: __privateGet(c, _starts),
      ttls: __privateGet(c, _ttls),
      sizes: __privateGet(c, _sizes),
      keyMap: __privateGet(c, _keyMap),
      keyList: __privateGet(c, _keyList),
      valList: __privateGet(c, _valList),
      next: __privateGet(c, _next),
      prev: __privateGet(c, _prev),
      get head() {
        return __privateGet(c, _head);
      },
      get tail() {
        return __privateGet(c, _tail);
      },
      free: __privateGet(c, _free),
      // methods
      isBackgroundFetch: (p) => {
        var _a3;
        return __privateMethod(_a3 = c, _isBackgroundFetch, isBackgroundFetch_fn).call(_a3, p);
      },
      backgroundFetch: (k, index, options, context) => {
        var _a3;
        return __privateMethod(_a3 = c, _backgroundFetch, backgroundFetch_fn).call(_a3, k, index, options, context);
      },
      moveToTail: (index) => {
        var _a3;
        return __privateMethod(_a3 = c, _moveToTail, moveToTail_fn).call(_a3, index);
      },
      indexes: (options) => {
        var _a3;
        return __privateMethod(_a3 = c, _indexes, indexes_fn).call(_a3, options);
      },
      rindexes: (options) => {
        var _a3;
        return __privateMethod(_a3 = c, _rindexes, rindexes_fn).call(_a3, options);
      },
      isStale: (index) => {
        var _a3;
        return __privateGet(_a3 = c, _isStale).call(_a3, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const k = __privateGet(this, _keyList)[i];
      if (k !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const k = __privateGet(this, _keyList)[i];
      if (k !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      if (v !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield __privateGet(this, _valList)[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      if (v !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
        yield __privateGet(this, _valList)[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, __privateGet(this, _keyList)[i], this)) {
        return this.get(__privateGet(this, _keyList)[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i)) {
        this.delete(__privateGet(this, _keyList)[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i];
      const v = __privateGet(this, _valList)[i];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i];
        const age = perf.now() - __privateGet(this, _starts)[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k, v, setOptions = {}) {
    var _a3, _b2, _c2, _d2, _e2;
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size2 = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size2 > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
    if (index === void 0) {
      index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index] = k;
      __privateGet(this, _valList)[index] = v;
      __privateGet(this, _keyMap).set(k, index);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index;
      __privateGet(this, _prev)[index] = __privateGet(this, _tail);
      __privateSet(this, _tail, index);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index, size2, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
      const oldVal = __privateGet(this, _valList)[index];
      if (v !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, s, k, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_c2 = __privateGet(this, _dispose)) == null ? void 0 : _c2.call(this, oldVal, k, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_d2 = __privateGet(this, _disposed)) == null ? void 0 : _d2.push([oldVal, k, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index);
        __privateGet(this, _addItemSize).call(this, index, size2, status);
        __privateGet(this, _valList)[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_e2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _e2.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a3;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _evict, evict_fn).call(this, true);
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a3 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a3.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = __privateGet(this, _keyMap).get(k);
    if (index !== void 0) {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = __privateGet(this, _keyMap).get(k);
    if (index !== void 0 && (allowStale || !__privateGet(this, _isStale).call(this, index))) {
      const v = __privateGet(this, _valList)[index];
      return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
    }
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size2 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size2,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = __privateGet(this, _keyMap).get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k, index, options, context);
      return p.__returned = p;
    } else {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = __privateGet(this, _isStale).call(this, index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        return v;
      }
      const p = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = __privateGet(this, _keyMap).get(k);
    if (index !== void 0) {
      const value = __privateGet(this, _valList)[index];
      const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
      if (__privateGet(this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    var _a3, _b2, _c2, _d2;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index = __privateGet(this, _keyMap).get(k);
      if (index !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          this.clear();
        } else {
          __privateGet(this, _removeItemSize).call(this, index);
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, "delete"]);
            }
          }
          __privateGet(this, _keyMap).delete(k);
          __privateGet(this, _keyList)[index] = void 0;
          __privateGet(this, _valList)[index] = void 0;
          if (index === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index]);
          } else if (index === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index]);
          } else {
            __privateGet(this, _next)[__privateGet(this, _prev)[index]] = __privateGet(this, _next)[index];
            __privateGet(this, _prev)[__privateGet(this, _next)[index]] = __privateGet(this, _prev)[index];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && ((_c2 = __privateGet(this, _disposed)) == null ? void 0 : _c2.length)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_d2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _d2.call(this, ...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a3, _b2, _c2;
    for (const index of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      const v = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = __privateGet(this, _keyList)[index];
        if (__privateGet(this, _hasDispose)) {
          (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k, "delete");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, "delete"]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c2 = __privateGet(this, _disposeAfter)) == null ? void 0 : _c2.call(this, ...task);
      }
    }
  }
};
var LRUCache = _LRUCache;
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_initializeTTLTracking = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index)) {
          this.delete(__privateGet(this, _keyList)[index]);
        }
      }, ttl + 1);
      if (t.unref) {
        t.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n;
      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t.unref) {
        t.unref();
      }
    }
    return n;
  };
  this.getRemainingTTL = (key) => {
    const index = __privateGet(this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    const ttl = ttls[index];
    const start = starts[index];
    if (ttl === 0 || start === 0) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index) => {
    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
_initializeSizeTracking = new WeakSet();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
    sizes[index] = 0;
  });
  __privateSet(this, _requireSize, (k, v, size2, sizeCalculation) => {
    if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
      return 0;
    }
    if (!isPosInt(size2)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size2 = sizeCalculation(v, k);
        if (!isPosInt(size2)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size2;
  });
  __privateSet(this, _addItemSize, (index, size2, status) => {
    sizes[index] = size2;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _evict, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
    if (status) {
      status.entrySize = size2;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
_indexes = new WeakSet();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === __privateGet(this, _head)) {
        break;
      } else {
        i = __privateGet(this, _prev)[i];
      }
    }
  }
};
_rindexes = new WeakSet();
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
        yield i;
      }
      if (i === __privateGet(this, _tail)) {
        break;
      } else {
        i = __privateGet(this, _next)[i];
      }
    }
  }
};
_isValidIndex = new WeakSet();
isValidIndex_fn = function(index) {
  return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
};
_evict = new WeakSet();
evict_fn = function(free) {
  var _a3, _b2;
  const head = __privateGet(this, _head);
  const k = __privateGet(this, _keyList)[head];
  const v = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
    v.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k);
  __privateWrapper(this, _size)._--;
  return head;
};
_backgroundFetch = new WeakSet();
backgroundFetch_fn = function(k, index, options, context) {
  const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
  if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
    return v;
  }
  const ac = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb2 = (v2, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p;
    if (__privateGet(this, _valList)[index] === p) {
      if (v2 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          this.delete(k);
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k, v2, fetchOpts.options);
      }
    }
    return v2;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p;
    if (__privateGet(this, _valList)[index] === p) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        this.delete(k);
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a3;
    const fmp = (_a3 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a3.call(this, k, v, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v2) => cb2(v2, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p = new Promise(pcall).then(cb2, eb);
  const bf = Object.assign(p, {
    __abortController: ac,
    __staleWhileFetching: v,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k, bf, { ...fetchOpts.options, status: void 0 });
    index = __privateGet(this, _keyMap).get(k);
  } else {
    __privateGet(this, _valList)[index] = bf;
  }
  return bf;
};
_isBackgroundFetch = new WeakSet();
isBackgroundFetch_fn = function(p) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b = p;
  return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
};
_connect = new WeakSet();
connect_fn = function(p, n) {
  __privateGet(this, _prev)[n] = p;
  __privateGet(this, _next)[p] = n;
};
_moveToTail = new WeakSet();
moveToTail_fn = function(index) {
  if (index !== __privateGet(this, _tail)) {
    if (index === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index]);
    } else {
      __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
    }
    __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index);
    __privateSet(this, _tail, index);
  }
};

// node_modules/path-scurry/dist/mjs/index.js
var import_path4 = require("path");
var import_url = require("url");
var actualFS = __toESM(require("fs"), 1);
var import_fs2 = require("fs");
var import_promises = require("fs/promises");

// node_modules/minipass/dist/esm/index.js
var import_events = require("events");
var import_stream = __toESM(require("stream"), 1);
var import_string_decoder = require("string_decoder");
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_stream.default || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_events.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_stream.default.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_events.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  constructor(src, dest, opts) {
    __publicField(this, "src");
    __publicField(this, "dest");
    __publicField(this, "opts");
    __publicField(this, "ondrain");
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
var Minipass = class extends import_events.EventEmitter {
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    __publicField(this, _a2, false);
    __publicField(this, _b, false);
    __publicField(this, _c, []);
    __publicField(this, _d, []);
    __publicField(this, _e);
    __publicField(this, _f);
    __publicField(this, _g);
    __publicField(this, _h);
    __publicField(this, _i, false);
    __publicField(this, _j, false);
    __publicField(this, _k, false);
    __publicField(this, _l, false);
    __publicField(this, _m, null);
    __publicField(this, _n, 0);
    __publicField(this, _o, false);
    __publicField(this, _p);
    __publicField(this, _q, false);
    __publicField(this, _r, 0);
    __publicField(this, _s, false);
    /**
     * true if the stream can be written
     */
    __publicField(this, "writable", true);
    /**
     * true if the stream can be read
     */
    __publicField(this, "readable", true);
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new import_string_decoder.StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get [(_a2 = FLOWING, _b = PAUSED, _c = PIPES, _d = BUFFER, _e = OBJECTMODE, _f = ENCODING, _g = ASYNC, _h = DECODER, _i = EOF, _j = EMITTED_END, _k = EMITTING_END, _l = CLOSED, _m = EMITTED_ERROR, _n = BUFFERLENGTH, _o = DESTROYED, _p = SIGNAL, _q = ABORTED, _r = DATALISTENERS, _s = DISCARDED, "async")]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    var _a3, _b2;
    this[ABORTED] = true;
    this.emit("abort", (_a3 = this[SIGNAL]) == null ? void 0 : _a3.reason);
    this.destroy((_b2 = this[SIGNAL]) == null ? void 0 : _b2.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_3) {
  }
  write(chunk2, encoding, cb2) {
    var _a3;
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb2 = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk2)) {
      if (isArrayBufferView(chunk2)) {
        chunk2 = Buffer.from(chunk2.buffer, chunk2.byteOffset, chunk2.byteLength);
      } else if (isArrayBufferLike(chunk2)) {
        chunk2 = Buffer.from(chunk2);
      } else if (typeof chunk2 !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk2);
      else
        this[BUFFERPUSH](chunk2);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb2)
        fn(cb2);
      return this[FLOWING];
    }
    if (!chunk2.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb2)
        fn(cb2);
      return this[FLOWING];
    }
    if (typeof chunk2 === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !((_a3 = this[DECODER]) == null ? void 0 : _a3.lastNeed))) {
      chunk2 = Buffer.from(chunk2, encoding);
    }
    if (Buffer.isBuffer(chunk2) && this[ENCODING]) {
      chunk2 = this[DECODER].write(chunk2);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk2);
    else
      this[BUFFERPUSH](chunk2);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb2)
      fn(cb2);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk2) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk2;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk2 = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk2 = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk2);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk2;
  }
  end(chunk2, encoding, cb2) {
    if (typeof chunk2 === "function") {
      cb2 = chunk2;
      chunk2 = void 0;
    }
    if (typeof encoding === "function") {
      cb2 = encoding;
      encoding = "utf8";
    }
    if (chunk2 !== void 0)
      this.write(chunk2, encoding);
    if (cb2)
      this.once("end", cb2);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk2) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk2.length;
    this[BUFFER].push(chunk2);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk2) {
    this.emit("data", chunk2);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve, reject2) => {
      this.on(DESTROYED, () => reject2(new Error("stream destroyed")));
      this.on("error", (er) => reject2(er));
      this.on("end", () => resolve());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve;
      let reject2;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject2(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject2 = rej;
        resolve = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// node_modules/path-scurry/dist/mjs/index.js
var realpathSync = import_fs2.realpathSync.native;
var defaultFS = {
  lstatSync: import_fs2.lstatSync,
  readdir: import_fs2.readdir,
  readdirSync: import_fs2.readdirSync,
  readlinkSync: import_fs2.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises.lstat,
    readdir: import_promises.readdir,
    readlink: import_promises.readlink,
    realpath: import_promises.realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache = /* @__PURE__ */ new Map();
var normalize = (s) => {
  const c = normalizeCache.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache.set(s, n);
  return n;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var _fs, _dev, _mode, _nlink, _uid, _gid, _rdev, _blksize, _ino, _size2, _blocks, _atimeMs, _mtimeMs, _ctimeMs, _birthtimeMs, _atime, _mtime, _ctime, _birthtime, _matchName, _depth, _fullpath, _fullpathPosix, _relative, _relativePosix, _type, _children, _linkTarget, _realpath, _resolveParts, resolveParts_fn, _readdirSuccess, readdirSuccess_fn, _markENOENT, markENOENT_fn, _markChildrenENOENT, markChildrenENOENT_fn, _markENOREALPATH, markENOREALPATH_fn, _markENOTDIR, markENOTDIR_fn, _readdirFail, readdirFail_fn, _lstatFail, lstatFail_fn, _readlinkFail, readlinkFail_fn, _readdirAddChild, readdirAddChild_fn, _readdirAddNewChild, readdirAddNewChild_fn, _readdirMaybePromoteChild, readdirMaybePromoteChild_fn, _readdirPromoteChild, readdirPromoteChild_fn, _applyStat, applyStat_fn, _onReaddirCB, _readdirCBInFlight, _callOnReaddirCB, callOnReaddirCB_fn, _asyncReaddirInFlight;
var PathBase = class {
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root2, roots, nocase, children, opts) {
    __privateAdd(this, _resolveParts);
    __privateAdd(this, _readdirSuccess);
    __privateAdd(this, _markENOENT);
    __privateAdd(this, _markChildrenENOENT);
    __privateAdd(this, _markENOREALPATH);
    // save the information when we know the entry is not a dir
    __privateAdd(this, _markENOTDIR);
    __privateAdd(this, _readdirFail);
    __privateAdd(this, _lstatFail);
    __privateAdd(this, _readlinkFail);
    __privateAdd(this, _readdirAddChild);
    __privateAdd(this, _readdirAddNewChild);
    __privateAdd(this, _readdirMaybePromoteChild);
    __privateAdd(this, _readdirPromoteChild);
    __privateAdd(this, _applyStat);
    __privateAdd(this, _callOnReaddirCB);
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    __publicField(this, "name");
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    __publicField(this, "root");
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    __publicField(this, "roots");
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    __publicField(this, "parent");
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    __publicField(this, "nocase");
    // potential default fs override
    __privateAdd(this, _fs, void 0);
    // Stats fields
    __privateAdd(this, _dev, void 0);
    __privateAdd(this, _mode, void 0);
    __privateAdd(this, _nlink, void 0);
    __privateAdd(this, _uid, void 0);
    __privateAdd(this, _gid, void 0);
    __privateAdd(this, _rdev, void 0);
    __privateAdd(this, _blksize, void 0);
    __privateAdd(this, _ino, void 0);
    __privateAdd(this, _size2, void 0);
    __privateAdd(this, _blocks, void 0);
    __privateAdd(this, _atimeMs, void 0);
    __privateAdd(this, _mtimeMs, void 0);
    __privateAdd(this, _ctimeMs, void 0);
    __privateAdd(this, _birthtimeMs, void 0);
    __privateAdd(this, _atime, void 0);
    __privateAdd(this, _mtime, void 0);
    __privateAdd(this, _ctime, void 0);
    __privateAdd(this, _birthtime, void 0);
    __privateAdd(this, _matchName, void 0);
    __privateAdd(this, _depth, void 0);
    __privateAdd(this, _fullpath, void 0);
    __privateAdd(this, _fullpathPosix, void 0);
    __privateAdd(this, _relative, void 0);
    __privateAdd(this, _relativePosix, void 0);
    __privateAdd(this, _type, void 0);
    __privateAdd(this, _children, void 0);
    __privateAdd(this, _linkTarget, void 0);
    __privateAdd(this, _realpath, void 0);
    __privateAdd(this, _onReaddirCB, []);
    __privateAdd(this, _readdirCBInFlight, false);
    __privateAdd(this, _asyncReaddirInFlight, void 0);
    this.name = name;
    __privateSet(this, _matchName, nocase ? normalizeNocase(name) : normalize(name));
    __privateSet(this, _type, type & TYPEMASK);
    this.nocase = nocase;
    this.roots = roots;
    this.root = root2 || this;
    __privateSet(this, _children, children);
    __privateSet(this, _fullpath, opts.fullpath);
    __privateSet(this, _relative, opts.relative);
    __privateSet(this, _relativePosix, opts.relativePosix);
    this.parent = opts.parent;
    if (this.parent) {
      __privateSet(this, _fs, __privateGet(this.parent, _fs));
    } else {
      __privateSet(this, _fs, fsFromOption(opts.fs));
    }
  }
  get dev() {
    return __privateGet(this, _dev);
  }
  get mode() {
    return __privateGet(this, _mode);
  }
  get nlink() {
    return __privateGet(this, _nlink);
  }
  get uid() {
    return __privateGet(this, _uid);
  }
  get gid() {
    return __privateGet(this, _gid);
  }
  get rdev() {
    return __privateGet(this, _rdev);
  }
  get blksize() {
    return __privateGet(this, _blksize);
  }
  get ino() {
    return __privateGet(this, _ino);
  }
  get size() {
    return __privateGet(this, _size2);
  }
  get blocks() {
    return __privateGet(this, _blocks);
  }
  get atimeMs() {
    return __privateGet(this, _atimeMs);
  }
  get mtimeMs() {
    return __privateGet(this, _mtimeMs);
  }
  get ctimeMs() {
    return __privateGet(this, _ctimeMs);
  }
  get birthtimeMs() {
    return __privateGet(this, _birthtimeMs);
  }
  get atime() {
    return __privateGet(this, _atime);
  }
  get mtime() {
    return __privateGet(this, _mtime);
  }
  get ctime() {
    return __privateGet(this, _ctime);
  }
  get birthtime() {
    return __privateGet(this, _birthtime);
  }
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['path'] refers to the path of the directory
   * that was passed to readdir.  So, somewhat counterintuitively, this
   * property refers to the *parent* path, not the path object itself.
   * For root entries, it's the path to the entry itself.
   */
  get path() {
    return (this.parent || this).fullpath();
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (__privateGet(this, _depth) !== void 0)
      return __privateGet(this, _depth);
    if (!this.parent)
      return __privateSet(this, _depth, 0);
    return __privateSet(this, _depth, this.parent.depth() + 1);
  }
  /**
   * @internal
   */
  childrenCache() {
    return __privateGet(this, _children);
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path3) {
    var _a3;
    if (!path3) {
      return this;
    }
    const rootPath = this.getRootString(path3);
    const dir = path3.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result2 = rootPath ? __privateMethod(_a3 = this.getRoot(rootPath), _resolveParts, resolveParts_fn).call(_a3, dirParts) : __privateMethod(this, _resolveParts, resolveParts_fn).call(this, dirParts);
    return result2;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = __privateGet(this, _children).get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    __privateGet(this, _children).set(this, children);
    __privateSet(this, _type, __privateGet(this, _type) & ~READDIR_CALLED);
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (const p of children) {
      if (__privateGet(p, _matchName) === name) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = __privateGet(this, _fullpath) ? __privateGet(this, _fullpath) + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      __privateSet(pchild, _type, __privateGet(pchild, _type) | ENOENT);
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (__privateGet(this, _relative) !== void 0) {
      return __privateGet(this, _relative);
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return __privateSet(this, _relative, this.name);
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (__privateGet(this, _relativePosix) !== void 0)
      return __privateGet(this, _relativePosix);
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return __privateSet(this, _relativePosix, this.fullpathPosix());
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (__privateGet(this, _fullpath) !== void 0) {
      return __privateGet(this, _fullpath);
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return __privateSet(this, _fullpath, this.name);
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name;
    return __privateSet(this, _fullpath, fp);
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (__privateGet(this, _fullpathPosix) !== void 0)
      return __privateGet(this, _fullpathPosix);
    if (this.sep === "/")
      return __privateSet(this, _fullpathPosix, this.fullpath());
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return __privateSet(this, _fullpathPosix, `//?/${p2}`);
      } else {
        return __privateSet(this, _fullpathPosix, p2);
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return __privateSet(this, _fullpathPosix, fpp);
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (__privateGet(this, _type) & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (__privateGet(this, _type) & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (__privateGet(this, _type) & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (__privateGet(this, _type) & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (__privateGet(this, _type) & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (__privateGet(this, _type) & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (__privateGet(this, _type) & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (__privateGet(this, _type) & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return __privateGet(this, _type) & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return __privateGet(this, _linkTarget);
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return __privateGet(this, _realpath);
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (__privateGet(this, _linkTarget))
      return true;
    if (!this.parent)
      return false;
    const ifmt = __privateGet(this, _type) & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || __privateGet(this, _type) & ENOREADLINK || __privateGet(this, _type) & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(__privateGet(this, _type) & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(__privateGet(this, _type) & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return !this.nocase ? __privateGet(this, _matchName) === normalize(n) : __privateGet(this, _matchName) === normalizeNocase(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target2 = __privateGet(this, _linkTarget);
    if (target2) {
      return target2;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = await __privateGet(this, _fs).promises.readlink(this.fullpath());
      const linkTarget = this.parent.resolve(read);
      if (linkTarget) {
        return __privateSet(this, _linkTarget, linkTarget);
      }
    } catch (er) {
      __privateMethod(this, _readlinkFail, readlinkFail_fn).call(this, er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target2 = __privateGet(this, _linkTarget);
    if (target2) {
      return target2;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = __privateGet(this, _fs).readlinkSync(this.fullpath());
      const linkTarget = this.parent.resolve(read);
      if (linkTarget) {
        return __privateSet(this, _linkTarget, linkTarget);
      }
    } catch (er) {
      __privateMethod(this, _readlinkFail, readlinkFail_fn).call(this, er.code);
      return void 0;
    }
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((__privateGet(this, _type) & ENOENT) === 0) {
      try {
        __privateMethod(this, _applyStat, applyStat_fn).call(this, await __privateGet(this, _fs).promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        __privateMethod(this, _lstatFail, lstatFail_fn).call(this, er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((__privateGet(this, _type) & ENOENT) === 0) {
      try {
        __privateMethod(this, _applyStat, applyStat_fn).call(this, __privateGet(this, _fs).lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        __privateMethod(this, _lstatFail, lstatFail_fn).call(this, er.code);
      }
    }
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb2, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb2(null, []);
      else
        queueMicrotask(() => cb2(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb2(null, c);
      else
        queueMicrotask(() => cb2(null, c));
      return;
    }
    __privateGet(this, _onReaddirCB).push(cb2);
    if (__privateGet(this, _readdirCBInFlight)) {
      return;
    }
    __privateSet(this, _readdirCBInFlight, true);
    const fullpath = this.fullpath();
    __privateGet(this, _fs).readdir(fullpath, { withFileTypes: true }, (er, entries) => {
      if (er) {
        __privateMethod(this, _readdirFail, readdirFail_fn).call(this, er.code);
        children.provisional = 0;
      } else {
        for (const e of entries) {
          __privateMethod(this, _readdirAddChild, readdirAddChild_fn).call(this, e, children);
        }
        __privateMethod(this, _readdirSuccess, readdirSuccess_fn).call(this, children);
      }
      __privateMethod(this, _callOnReaddirCB, callOnReaddirCB_fn).call(this, children.slice(0, children.provisional));
      return;
    });
  }
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (__privateGet(this, _asyncReaddirInFlight)) {
      await __privateGet(this, _asyncReaddirInFlight);
    } else {
      let resolve = () => {
      };
      __privateSet(this, _asyncReaddirInFlight, new Promise((res) => resolve = res));
      try {
        for (const e of await __privateGet(this, _fs).promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          __privateMethod(this, _readdirAddChild, readdirAddChild_fn).call(this, e, children);
        }
        __privateMethod(this, _readdirSuccess, readdirSuccess_fn).call(this, children);
      } catch (er) {
        __privateMethod(this, _readdirFail, readdirFail_fn).call(this, er.code);
        children.provisional = 0;
      }
      __privateSet(this, _asyncReaddirInFlight, void 0);
      resolve();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of __privateGet(this, _fs).readdirSync(fullpath, {
        withFileTypes: true
      })) {
        __privateMethod(this, _readdirAddChild, readdirAddChild_fn).call(this, e, children);
      }
      __privateMethod(this, _readdirSuccess, readdirSuccess_fn).call(this, children);
    } catch (er) {
      __privateMethod(this, _readdirFail, readdirFail_fn).call(this, er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (__privateGet(this, _type) & ENOCHILD)
      return false;
    const ifmt = IFMT & __privateGet(this, _type);
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (__privateGet(this, _type) & IFDIR) === IFDIR && !(__privateGet(this, _type) & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (__privateGet(this, _realpath))
      return __privateGet(this, _realpath);
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & __privateGet(this, _type))
      return void 0;
    try {
      const rp = await __privateGet(this, _fs).promises.realpath(this.fullpath());
      return __privateSet(this, _realpath, this.resolve(rp));
    } catch (_3) {
      __privateMethod(this, _markENOREALPATH, markENOREALPATH_fn).call(this);
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (__privateGet(this, _realpath))
      return __privateGet(this, _realpath);
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & __privateGet(this, _type))
      return void 0;
    try {
      const rp = __privateGet(this, _fs).realpathSync(this.fullpath());
      return __privateSet(this, _realpath, this.resolve(rp));
    } catch (_3) {
      __privateMethod(this, _markENOREALPATH, markENOREALPATH_fn).call(this);
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      __privateSet(p, _relative, rp.join(this.sep));
      __privateSet(p, _relativePosix, rp.join("/"));
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      __privateSet(p, _relative, void 0);
      __privateSet(p, _relativePosix, void 0);
      p = p.parent;
    }
  }
};
_fs = new WeakMap();
_dev = new WeakMap();
_mode = new WeakMap();
_nlink = new WeakMap();
_uid = new WeakMap();
_gid = new WeakMap();
_rdev = new WeakMap();
_blksize = new WeakMap();
_ino = new WeakMap();
_size2 = new WeakMap();
_blocks = new WeakMap();
_atimeMs = new WeakMap();
_mtimeMs = new WeakMap();
_ctimeMs = new WeakMap();
_birthtimeMs = new WeakMap();
_atime = new WeakMap();
_mtime = new WeakMap();
_ctime = new WeakMap();
_birthtime = new WeakMap();
_matchName = new WeakMap();
_depth = new WeakMap();
_fullpath = new WeakMap();
_fullpathPosix = new WeakMap();
_relative = new WeakMap();
_relativePosix = new WeakMap();
_type = new WeakMap();
_children = new WeakMap();
_linkTarget = new WeakMap();
_realpath = new WeakMap();
_resolveParts = new WeakSet();
resolveParts_fn = function(dirParts) {
  let p = this;
  for (const part of dirParts) {
    p = p.child(part);
  }
  return p;
};
_readdirSuccess = new WeakSet();
readdirSuccess_fn = function(children) {
  var _a3;
  __privateSet(this, _type, __privateGet(this, _type) | READDIR_CALLED);
  for (let p = children.provisional; p < children.length; p++) {
    __privateMethod(_a3 = children[p], _markENOENT, markENOENT_fn).call(_a3);
  }
};
_markENOENT = new WeakSet();
markENOENT_fn = function() {
  if (__privateGet(this, _type) & ENOENT)
    return;
  __privateSet(this, _type, (__privateGet(this, _type) | ENOENT) & IFMT_UNKNOWN);
  __privateMethod(this, _markChildrenENOENT, markChildrenENOENT_fn).call(this);
};
_markChildrenENOENT = new WeakSet();
markChildrenENOENT_fn = function() {
  var _a3;
  const children = this.children();
  children.provisional = 0;
  for (const p of children) {
    __privateMethod(_a3 = p, _markENOENT, markENOENT_fn).call(_a3);
  }
};
_markENOREALPATH = new WeakSet();
markENOREALPATH_fn = function() {
  __privateSet(this, _type, __privateGet(this, _type) | ENOREALPATH);
  __privateMethod(this, _markENOTDIR, markENOTDIR_fn).call(this);
};
_markENOTDIR = new WeakSet();
markENOTDIR_fn = function() {
  if (__privateGet(this, _type) & ENOTDIR)
    return;
  let t = __privateGet(this, _type);
  if ((t & IFMT) === IFDIR)
    t &= IFMT_UNKNOWN;
  __privateSet(this, _type, t | ENOTDIR);
  __privateMethod(this, _markChildrenENOENT, markChildrenENOENT_fn).call(this);
};
_readdirFail = new WeakSet();
readdirFail_fn = function(code = "") {
  if (code === "ENOTDIR" || code === "EPERM") {
    __privateMethod(this, _markENOTDIR, markENOTDIR_fn).call(this);
  } else if (code === "ENOENT") {
    __privateMethod(this, _markENOENT, markENOENT_fn).call(this);
  } else {
    this.children().provisional = 0;
  }
};
_lstatFail = new WeakSet();
lstatFail_fn = function(code = "") {
  var _a3;
  if (code === "ENOTDIR") {
    const p = this.parent;
    __privateMethod(_a3 = p, _markENOTDIR, markENOTDIR_fn).call(_a3);
  } else if (code === "ENOENT") {
    __privateMethod(this, _markENOENT, markENOENT_fn).call(this);
  }
};
_readlinkFail = new WeakSet();
readlinkFail_fn = function(code = "") {
  var _a3;
  let ter = __privateGet(this, _type);
  ter |= ENOREADLINK;
  if (code === "ENOENT")
    ter |= ENOENT;
  if (code === "EINVAL" || code === "UNKNOWN") {
    ter &= IFMT_UNKNOWN;
  }
  __privateSet(this, _type, ter);
  if (code === "ENOTDIR" && this.parent) {
    __privateMethod(_a3 = this.parent, _markENOTDIR, markENOTDIR_fn).call(_a3);
  }
};
_readdirAddChild = new WeakSet();
readdirAddChild_fn = function(e, c) {
  return __privateMethod(this, _readdirMaybePromoteChild, readdirMaybePromoteChild_fn).call(this, e, c) || __privateMethod(this, _readdirAddNewChild, readdirAddNewChild_fn).call(this, e, c);
};
_readdirAddNewChild = new WeakSet();
readdirAddNewChild_fn = function(e, c) {
  const type = entToType(e);
  const child = this.newChild(e.name, type, { parent: this });
  const ifmt = __privateGet(child, _type) & IFMT;
  if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
    __privateSet(child, _type, __privateGet(child, _type) | ENOTDIR);
  }
  c.unshift(child);
  c.provisional++;
  return child;
};
_readdirMaybePromoteChild = new WeakSet();
readdirMaybePromoteChild_fn = function(e, c) {
  for (let p = c.provisional; p < c.length; p++) {
    const pchild = c[p];
    const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
    if (name !== __privateGet(pchild, _matchName)) {
      continue;
    }
    return __privateMethod(this, _readdirPromoteChild, readdirPromoteChild_fn).call(this, e, pchild, p, c);
  }
};
_readdirPromoteChild = new WeakSet();
readdirPromoteChild_fn = function(e, p, index, c) {
  const v = p.name;
  __privateSet(p, _type, __privateGet(p, _type) & IFMT_UNKNOWN | entToType(e));
  if (v !== e.name)
    p.name = e.name;
  if (index !== c.provisional) {
    if (index === c.length - 1)
      c.pop();
    else
      c.splice(index, 1);
    c.unshift(p);
  }
  c.provisional++;
  return p;
};
_applyStat = new WeakSet();
applyStat_fn = function(st) {
  const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size: size2, uid } = st;
  __privateSet(this, _atime, atime);
  __privateSet(this, _atimeMs, atimeMs);
  __privateSet(this, _birthtime, birthtime);
  __privateSet(this, _birthtimeMs, birthtimeMs);
  __privateSet(this, _blksize, blksize);
  __privateSet(this, _blocks, blocks);
  __privateSet(this, _ctime, ctime);
  __privateSet(this, _ctimeMs, ctimeMs);
  __privateSet(this, _dev, dev);
  __privateSet(this, _gid, gid);
  __privateSet(this, _ino, ino);
  __privateSet(this, _mode, mode);
  __privateSet(this, _mtime, mtime);
  __privateSet(this, _mtimeMs, mtimeMs);
  __privateSet(this, _nlink, nlink);
  __privateSet(this, _rdev, rdev);
  __privateSet(this, _size2, size2);
  __privateSet(this, _uid, uid);
  const ifmt = entToType(st);
  __privateSet(this, _type, __privateGet(this, _type) & IFMT_UNKNOWN | ifmt | LSTAT_CALLED);
  if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
    __privateSet(this, _type, __privateGet(this, _type) | ENOTDIR);
  }
};
_onReaddirCB = new WeakMap();
_readdirCBInFlight = new WeakMap();
_callOnReaddirCB = new WeakSet();
callOnReaddirCB_fn = function(children) {
  __privateSet(this, _readdirCBInFlight, false);
  const cbs = __privateGet(this, _onReaddirCB).slice();
  __privateGet(this, _onReaddirCB).length = 0;
  cbs.forEach((cb2) => cb2(null, children));
};
_asyncReaddirInFlight = new WeakMap();
var PathWin32 = class extends PathBase {
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root2, roots, nocase, children, opts) {
    super(name, type, root2, roots, nocase, children, opts);
    /**
     * Separator for generating path strings.
     */
    __publicField(this, "sep", "\\");
    /**
     * Separator for parsing path strings.
     */
    __publicField(this, "splitSep", eitherSep);
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path3) {
    return import_path4.win32.parse(path3).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare, root2] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare)) {
        return this.roots[rootPath] = root2;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare;
  }
};
var PathPosix = class extends PathBase {
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root2, roots, nocase, children, opts) {
    super(name, type, root2, roots, nocase, children, opts);
    /**
     * separator for parsing path strings
     */
    __publicField(this, "splitSep", "/");
    /**
     * separator for generating path strings
     */
    __publicField(this, "sep", "/");
  }
  /**
   * @internal
   */
  getRootString(path3) {
    return path3.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var _resolveCache, _resolvePosixCache, _children2, _fs2;
var PathScurryBase = class {
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}) {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    __publicField(this, "root");
    /**
     * The string path for the root of this Scurry's current working directory
     */
    __publicField(this, "rootPath");
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    __publicField(this, "roots");
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    __publicField(this, "cwd");
    __privateAdd(this, _resolveCache, void 0);
    __privateAdd(this, _resolvePosixCache, void 0);
    __privateAdd(this, _children2, void 0);
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    __publicField(this, "nocase");
    __privateAdd(this, _fs2, void 0);
    __privateSet(this, _fs2, fsFromOption(fs));
    if (cwd instanceof URL || cwd.startsWith("file://")) {
      cwd = (0, import_url.fileURLToPath)(cwd);
    }
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    __privateSet(this, _resolveCache, new ResolveCache());
    __privateSet(this, _resolvePosixCache, new ResolveCache());
    __privateSet(this, _children2, new ChildrenCache(childrenCacheSize));
    const split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0]) {
      split.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(__privateGet(this, _fs2));
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs = this.rootPath;
    let sawFirst = false;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path3 = this.cwd) {
    if (typeof path3 === "string") {
      path3 = this.cwd.resolve(path3);
    }
    return path3.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return __privateGet(this, _children2);
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = __privateGet(this, _resolveCache).get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result2 = this.cwd.resolve(r).fullpath();
    __privateGet(this, _resolveCache).set(r, result2);
    return result2;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = __privateGet(this, _resolvePosixCache).get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result2 = this.cwd.resolve(r).fullpathPosix();
    __privateGet(this, _resolvePosixCache).set(r, result2);
    return result2;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = [];
    if (!filter3 || filter3(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk = (dir, cb2) => {
      dirs.add(dir);
      dir.readdirCB((er, entries) => {
        if (er) {
          return cb2(er);
        }
        let len = entries.length;
        if (!len)
          return cb2();
        const next = () => {
          if (--len === 0) {
            cb2();
          }
        };
        for (const e of entries) {
          if (!filter3 || filter3(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => (r == null ? void 0 : r.isUnknown()) ? r.lstat() : r).then((r) => (r == null ? void 0 : r.shouldWalk(dirs, walkFilter)) ? walk(r, next) : next());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk(e, next);
            } else {
              next();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = [];
    if (!filter3 || filter3(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter3 || filter3(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    if (!filter3 || filter3(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter3 || filter3(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter3 || filter3(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => (r == null ? void 0 : r.isUnknown()) ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries, true));
              return;
            }
          }
          for (const e of entries) {
            if (e && (!filter3 || filter3(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process2);
          } else if (!sync2) {
            process2();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process2();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter3 || filter3(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing = 0;
    const process2 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter3 || filter3(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process2);
    };
    process2();
    return results;
  }
  chdir(path3 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path3 === "string" ? this.cwd.resolve(path3) : path3;
    this.cwd[setAsCwd](oldCwd);
  }
};
_resolveCache = new WeakMap();
_resolvePosixCache = new WeakMap();
_children2 = new WeakMap();
_fs2 = new WeakMap();
var PathScurryWin32 = class extends PathScurryBase {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, import_path4.win32, "\\", { ...opts, nocase });
    /**
     * separator for generating path strings
     */
    __publicField(this, "sep", "\\");
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return import_path4.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd, import_path4.posix, "/", { ...opts, nocase });
    /**
     * separator for generating path strings
     */
    __publicField(this, "sep", "/");
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// node_modules/glob/dist/esm/glob.js
var import_url2 = require("url");

// node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var _patternList, _globList, _index, _platform, _rest, _globString, _isDrive, _isUNC, _isAbsolute, _followGlobstar;
var _Pattern = class {
  constructor(patternList, globList, index, platform) {
    __privateAdd(this, _patternList, void 0);
    __privateAdd(this, _globList, void 0);
    __privateAdd(this, _index, void 0);
    __publicField(this, "length");
    __privateAdd(this, _platform, void 0);
    __privateAdd(this, _rest, void 0);
    __privateAdd(this, _globString, void 0);
    __privateAdd(this, _isDrive, void 0);
    __privateAdd(this, _isUNC, void 0);
    __privateAdd(this, _isAbsolute, void 0);
    __privateAdd(this, _followGlobstar, true);
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index < 0 || index >= this.length) {
      throw new TypeError("index out of range");
    }
    __privateSet(this, _patternList, patternList);
    __privateSet(this, _globList, globList);
    __privateSet(this, _index, index);
    __privateSet(this, _platform, platform);
    if (__privateGet(this, _index) === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = __privateGet(this, _patternList);
        const [g0, g1, g2, g3, ...grest] = __privateGet(this, _globList);
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        __privateSet(this, _patternList, [p, ...prest]);
        __privateSet(this, _globList, [g, ...grest]);
        this.length = __privateGet(this, _patternList).length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = __privateGet(this, _patternList);
        const [g1, ...grest] = __privateGet(this, _globList);
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        __privateSet(this, _patternList, [p, ...prest]);
        __privateSet(this, _globList, [g, ...grest]);
        this.length = __privateGet(this, _patternList).length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return __privateGet(this, _patternList)[__privateGet(this, _index)];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof __privateGet(this, _patternList)[__privateGet(this, _index)] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return __privateGet(this, _patternList)[__privateGet(this, _index)] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return __privateGet(this, _patternList)[__privateGet(this, _index)] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return __privateSet(this, _globString, __privateGet(this, _globString) || (__privateGet(this, _index) === 0 ? this.isAbsolute() ? __privateGet(this, _globList)[0] + __privateGet(this, _globList).slice(1).join("/") : __privateGet(this, _globList).join("/") : __privateGet(this, _globList).slice(__privateGet(this, _index)).join("/")));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > __privateGet(this, _index) + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (__privateGet(this, _rest) !== void 0)
      return __privateGet(this, _rest);
    if (!this.hasMore())
      return __privateSet(this, _rest, null);
    __privateSet(this, _rest, new _Pattern(__privateGet(this, _patternList), __privateGet(this, _globList), __privateGet(this, _index) + 1, __privateGet(this, _platform)));
    __privateSet(__privateGet(this, _rest), _isAbsolute, __privateGet(this, _isAbsolute));
    __privateSet(__privateGet(this, _rest), _isUNC, __privateGet(this, _isUNC));
    __privateSet(__privateGet(this, _rest), _isDrive, __privateGet(this, _isDrive));
    return __privateGet(this, _rest);
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = __privateGet(this, _patternList);
    return __privateGet(this, _isUNC) !== void 0 ? __privateGet(this, _isUNC) : __privateSet(this, _isUNC, __privateGet(this, _platform) === "win32" && __privateGet(this, _index) === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3]);
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = __privateGet(this, _patternList);
    return __privateGet(this, _isDrive) !== void 0 ? __privateGet(this, _isDrive) : __privateSet(this, _isDrive, __privateGet(this, _platform) === "win32" && __privateGet(this, _index) === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]));
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = __privateGet(this, _patternList);
    return __privateGet(this, _isAbsolute) !== void 0 ? __privateGet(this, _isAbsolute) : __privateSet(this, _isAbsolute, pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC());
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = __privateGet(this, _patternList)[0];
    return typeof p === "string" && this.isAbsolute() && __privateGet(this, _index) === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(__privateGet(this, _index) === 0 || !this.isGlobstar() || !__privateGet(this, _followGlobstar));
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (__privateGet(this, _index) === 0 || !this.isGlobstar() || !__privateGet(this, _followGlobstar))
      return false;
    __privateSet(this, _followGlobstar, false);
    return true;
  }
};
var Pattern = _Pattern;
_patternList = new WeakMap();
_globList = new WeakMap();
_index = new WeakMap();
_platform = new WeakMap();
_rest = new WeakMap();
_globString = new WeakMap();
_isDrive = new WeakMap();
_isUNC = new WeakMap();
_isAbsolute = new WeakMap();
_followGlobstar = new WeakMap();

// node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore = class {
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
    __publicField(this, "relative");
    __publicField(this, "relativeChildren");
    __publicField(this, "absolute");
    __publicField(this, "absoluteChildren");
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    const mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored) {
      const mm = new Minimatch(ign, mmopts);
      for (let i = 0; i < mm.set.length; i++) {
        const parsed = mm.set[i];
        const globParts = mm.globParts[i];
        if (!parsed || !globParts) {
          throw new Error("invalid pattern object");
        }
        const p = new Pattern(parsed, globParts, 0, platform);
        const m = new Minimatch(p.globString(), mmopts);
        const children = globParts[globParts.length - 1] === "**";
        const absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children) {
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
        }
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative = p.relative() || ".";
    const relatives = `${relative}/`;
    for (const m of this.relative) {
      if (m.match(relative) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// node_modules/glob/dist/esm/processor.js
var HasWalkedCache = class {
  constructor(store = /* @__PURE__ */ new Map()) {
    __publicField(this, "store");
    this.store = store;
  }
  copy() {
    return new HasWalkedCache(new Map(this.store));
  }
  hasWalked(target2, pattern) {
    var _a3;
    return (_a3 = this.store.get(target2.fullpath())) == null ? void 0 : _a3.has(pattern.globString());
  }
  storeWalked(target2, pattern) {
    const fullpath = target2.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  constructor() {
    __publicField(this, "store", /* @__PURE__ */ new Map());
  }
  add(target2, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target2);
    this.store.set(target2, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path3, n]) => [
      path3,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
};
var SubWalks = class {
  constructor() {
    __publicField(this, "store", /* @__PURE__ */ new Map());
  }
  add(target2, pattern) {
    if (!target2.canReaddir()) {
      return;
    }
    const subs = this.store.get(target2);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target2, [pattern]);
  }
  get(target2) {
    const subs = this.store.get(target2);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class {
  constructor(opts, hasWalkedCache) {
    __publicField(this, "hasWalkedCache");
    __publicField(this, "matches", new MatchRecord());
    __publicField(this, "subwalks", new SubWalks());
    __publicField(this, "patterns");
    __publicField(this, "follow");
    __publicField(this, "dot");
    __publicField(this, "opts");
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target2, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target2, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root2 = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root2) {
        t = t.resolve(root2 === "/" && this.opts.root !== void 0 ? this.opts.root : root2);
        const rest3 = pattern.rest();
        if (!rest3) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest3;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest2;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest2 = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest2;
        changed = true;
      }
      p = pattern.pattern();
      rest2 = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest2 == null ? void 0 : rest2.pattern();
        const rrest = rest2 == null ? void 0 : rest2.rest();
        if (!rest2 || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest2 = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest2, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest2, absolute);
        } else {
          results.testString(e, p, rest2, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest2, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest2 && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest2);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest2) {
      const rp = rest2.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest2.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest2);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest2.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest2, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest2) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest2);
    }
  }
  testString(e, p, rest2, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest2) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest2);
    }
  }
};

// node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
var _onResume, _ignore, _sep, _ignored, ignored_fn, _childrenIgnored, childrenIgnored_fn;
var GlobUtil = class {
  constructor(patterns, path3, opts) {
    __privateAdd(this, _ignored);
    __privateAdd(this, _childrenIgnored);
    __publicField(this, "path");
    __publicField(this, "patterns");
    __publicField(this, "opts");
    __publicField(this, "seen", /* @__PURE__ */ new Set());
    __publicField(this, "paused", false);
    __publicField(this, "aborted", false);
    __privateAdd(this, _onResume, []);
    __privateAdd(this, _ignore, void 0);
    __privateAdd(this, _sep, void 0);
    __publicField(this, "signal");
    __publicField(this, "maxDepth");
    this.patterns = patterns;
    this.path = path3;
    this.opts = opts;
    __privateSet(this, _sep, !opts.posix && opts.platform === "win32" ? "\\" : "/");
    if (opts.ignore) {
      __privateSet(this, _ignore, makeIgnore(opts.ignore, opts));
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        __privateGet(this, _onResume).length = 0;
      });
    }
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    var _a3;
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = __privateGet(this, _onResume).shift())) {
      fn();
    }
  }
  onResume(fn) {
    var _a3;
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      __privateGet(this, _onResume).push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !__privateMethod(this, _ignored, ignored_fn).call(this, e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
  }
  matchFinish(e, absolute) {
    if (__privateMethod(this, _ignored, ignored_fn).call(this, e))
      return;
    const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? __privateGet(this, _sep) : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs) {
      const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + __privateGet(this, _sep)) ? "." + __privateGet(this, _sep) : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target2, patterns, cb2) {
    var _a3;
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      cb2();
    this.walkCB2(target2, patterns, new Processor(this.opts), cb2);
  }
  walkCB2(target2, patterns, processor, cb2) {
    var _a3;
    if (__privateMethod(this, _childrenIgnored, childrenIgnored_fn).call(this, target2))
      return cb2();
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      cb2();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target2, patterns, processor, cb2));
      return;
    }
    processor.processPatterns(target2, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb2();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (__privateMethod(this, _ignored, ignored_fn).call(this, m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next);
      else {
        t.readdirCB((_3, entries) => this.walkCB3(t, entries, processor, next), true);
      }
    }
    next();
  }
  walkCB3(target2, entries, processor, cb2) {
    processor = processor.filterEntries(target2, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb2();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (__privateMethod(this, _ignored, ignored_fn).call(this, m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const [target3, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target3, patterns, processor.child(), next);
    }
    next();
  }
  walkCBSync(target2, patterns, cb2) {
    var _a3;
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      cb2();
    this.walkCB2Sync(target2, patterns, new Processor(this.opts), cb2);
  }
  walkCB2Sync(target2, patterns, processor, cb2) {
    var _a3;
    if (__privateMethod(this, _childrenIgnored, childrenIgnored_fn).call(this, target2))
      return cb2();
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      cb2();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target2, patterns, processor, cb2));
      return;
    }
    processor.processPatterns(target2, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb2();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (__privateMethod(this, _ignored, ignored_fn).call(this, m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target2, entries, processor, cb2) {
    processor = processor.filterEntries(target2, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb2();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (__privateMethod(this, _ignored, ignored_fn).call(this, m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target3, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target3, patterns, processor.child(), next);
    }
    next();
  }
};
_onResume = new WeakMap();
_ignore = new WeakMap();
_sep = new WeakMap();
_ignored = new WeakSet();
ignored_fn = function(path3) {
  var _a3, _b2;
  return this.seen.has(path3) || !!((_b2 = (_a3 = __privateGet(this, _ignore)) == null ? void 0 : _a3.ignored) == null ? void 0 : _b2.call(_a3, path3));
};
_childrenIgnored = new WeakSet();
childrenIgnored_fn = function(path3) {
  var _a3, _b2;
  return !!((_b2 = (_a3 = __privateGet(this, _ignore)) == null ? void 0 : _a3.childrenIgnored) == null ? void 0 : _b2.call(_a3, path3));
};
var GlobWalker = class extends GlobUtil {
  constructor(patterns, path3, opts) {
    super(patterns, path3, opts);
    __publicField(this, "matches");
    this.matches = /* @__PURE__ */ new Set();
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    var _a3;
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        var _a4;
        if ((_a4 = this.signal) == null ? void 0 : _a4.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    var _a3;
    if ((_a3 = this.signal) == null ? void 0 : _a3.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      var _a4;
      if ((_a4 = this.signal) == null ? void 0 : _a4.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  constructor(patterns, path3, opts) {
    super(patterns, path3, opts);
    __publicField(this, "results");
    this.results = new Minipass({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target2 = this.path;
    if (target2.isUnknown()) {
      target2.lstat().then(() => {
        this.walkCB(target2, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target2, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    __publicField(this, "absolute");
    __publicField(this, "cwd");
    __publicField(this, "root");
    __publicField(this, "dot");
    __publicField(this, "dotRelative");
    __publicField(this, "follow");
    __publicField(this, "ignore");
    __publicField(this, "magicalBraces");
    __publicField(this, "mark");
    __publicField(this, "matchBase");
    __publicField(this, "maxDepth");
    __publicField(this, "nobrace");
    __publicField(this, "nocase");
    __publicField(this, "nodir");
    __publicField(this, "noext");
    __publicField(this, "noglobstar");
    __publicField(this, "pattern");
    __publicField(this, "platform");
    __publicField(this, "realpath");
    __publicField(this, "scurry");
    __publicField(this, "stat");
    __publicField(this, "signal");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "withFileTypes");
    /**
     * The options provided to the constructor.
     */
    __publicField(this, "opts");
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    __publicField(this, "patterns");
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = (0, import_url2.fileURLToPath)(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set, m) => {
      set[0].push(...m.set);
      set[1].push(...m.globParts);
      return set;
    }, [[], []]);
    this.patterns = matchSet.map((set, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options).hasMagic())
      return true;
  }
  return false;
};

// node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync;
var stream = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;

// src/export/globCopy.ts
var import_path5 = require("path");
var import_fs3 = require("fs");
async function copyGlob(fileExportProperties, globString, plugin) {
  const relativeRoot = (0, import_path5.parse)(fileExportProperties.from).dir;
  const basePath = plugin.app.vault.adapter.basePath;
  const fromAbsoluteRoot = (0, import_path5.join)(basePath, relativeRoot);
  const toRootDir = (0, import_path5.parse)(fileExportProperties.toAbsoluteFs).dir;
  const files = globSync(globString, { cwd: fromAbsoluteRoot });
  const fileListExported = [];
  files.forEach((relativeFileName) => {
    const toAbsolutePath = (0, import_path5.join)(toRootDir, relativeFileName);
    const fromAbsolutePath = (0, import_path5.join)(fromAbsoluteRoot, relativeFileName);
    const exportTargetDir = (0, import_path5.parse)(toAbsolutePath).dir;
    const fileStats = (0, import_fs3.statSync)(fromAbsolutePath);
    if (fileStats.isFile()) {
      if (!(0, import_fs3.existsSync)(exportTargetDir)) {
        (0, import_fs3.mkdirSync)(exportTargetDir, { recursive: true });
        fileListExported.push({
          count: 0,
          newPath: toAbsolutePath,
          originalPath: relativeFileName,
          normalizedOriginalPath: relativeFileName,
          status: "success",
          text: relativeFileName,
          source: "globCopy",
          linkType: 0 /* internal */
        });
      }
      try {
        (0, import_fs3.cpSync)(fromAbsolutePath, toAbsolutePath);
        fileListExported.push({
          count: 1,
          newPath: exportTargetDir,
          originalPath: relativeFileName,
          status: "success",
          normalizedOriginalPath: relativeFileName,
          text: relativeFileName,
          source: "globCopy",
          linkType: 0 /* internal */
        });
      } catch (e) {
        console.error(e);
        fileListExported.push({
          count: 1,
          newPath: toAbsolutePath,
          originalPath: relativeFileName,
          normalizedOriginalPath: relativeFileName,
          status: "error",
          error: e.message,
          text: relativeFileName,
          source: "globCopy",
          linkType: 0 /* internal */
        });
      }
    } else if (fileStats.isDirectory()) {
    }
  });
  return fileListExported;
}

// src/export/replace-local-links.ts
var import_console = require("console");
function replaceLocalLinks(exportProperties, links, allFileListMap, plugin) {
  for (const index in links) {
    const link = links[index];
    const original = link.originalPath;
    const title = link.text;
    const linkedDocument = plugin.app.metadataCache.getFirstLinkpathDest(
      decodeURIComponent(link.normalizedOriginalPath),
      exportProperties.from
    );
    if (!linkedDocument) {
      link.error = "Internal Link Not Found at all!";
      exportProperties.outputContent = replaceAll(
        `[${title}](${original})`,
        exportProperties.outputContent,
        `${title}`
      );
      (0, import_console.warn)("Internal link not found! Removing. ", title, original);
      continue;
    }
    const path3 = linkedDocument.path;
    if (allFileListMap[path3]) {
      const newFilePath = allFileListMap[path3].toRelative;
      const newLink = newFilePath.substring(
        0,
        newFilePath.lastIndexOf(".")
      );
      if (newLink.indexOf(" ") > -1) {
        newLink.split("/").map((urlPart) => encodeURIComponent(urlPart));
      }
      link.newPath = newLink;
      const newLinkWithTitle = `[${title}](${newLink})`;
      exportProperties.outputContent = replaceAll(
        `[${title}](${original})`,
        exportProperties.outputContent,
        newLinkWithTitle
      );
    } else {
      (0, import_console.warn)("Internal link not found in output, removing!", original, title, path3);
      link.error = "Internal Link FOUND but not public, removed!";
      exportProperties.outputContent = replaceAll(
        `[${title}](${original})`,
        exportProperties.outputContent,
        `${title}`
      );
    }
  }
}

// src/export/collect-assets.ts
async function collectAssetsReplaceLinks(fileExportProperties, allFileListMap, settings, plugin) {
  const linksAndAttachments = getLinksAndAttachments(fileExportProperties.content);
  fileExportProperties.linksAndAttachments = linksAndAttachments;
  fileExportProperties.outputContent = linksAndAttachments.markdownReplacedWikiStyleLinks;
  collectAndReplaceHeaderAttachments(plugin, settings, fileExportProperties, linksAndAttachments.internalHeaderAttachments);
  collectAndReplaceInlineAttachments(plugin, settings, fileExportProperties, linksAndAttachments.internalAttachments);
  replaceLocalLinks(
    fileExportProperties,
    linksAndAttachments.internalLinks,
    allFileListMap,
    plugin
  );
  const frontMatterData = fileExportProperties.frontMatter;
  const filesCopied = {};
  if (frontMatterData && frontMatterData.copy) {
    if (isArray_default(frontMatterData.copy)) {
      for (let i = 0; i < frontMatterData.copy.length; i++) {
        const globPattern = frontMatterData.copy[i];
        filesCopied[globPattern] = await copyGlob(fileExportProperties, globPattern, plugin);
      }
    } else if (isString_default(frontMatterData.copy)) {
      filesCopied[frontMatterData.copy] = await copyGlob(fileExportProperties, frontMatterData.copy, plugin);
    }
  }
  fileExportProperties.copyGlob = filesCopied;
  return fileExportProperties;
}

// src/utils/delete-folder-content.ts
var import_fs4 = require("fs");
var import_path6 = require("path");
function rmDirContent(directoryPath) {
  if ((0, import_fs4.existsSync)(directoryPath)) {
    (0, import_fs4.readdirSync)(directoryPath).forEach((file) => {
      const curPath = (0, import_path6.join)(directoryPath, file);
      if ((0, import_fs4.lstatSync)(curPath).isDirectory()) {
        (0, import_fs4.rmSync)(curPath, { recursive: true, force: true });
      } else {
        (0, import_fs4.unlinkSync)(curPath);
      }
    });
  }
}

// src/export/exporter.ts
var Exporter = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.display = new FileListItemWrapper(plugin);
  }
  async searchAll() {
    const ret = [];
    for (let item = 0; item < this.plugin.settings.items.length; item++) {
      const setting = this.plugin.settings.items[item];
      ret.push({
        results: await this.searchFilesToExport(setting),
        setting
      });
    }
    return ret;
  }
  async searchAndExportAll() {
    const ret = [];
    for (let item = 0; item < this.plugin.settings.items.length; item++) {
      const setting = this.plugin.settings.items[item];
      ret.push({
        results: await this.searchAndExport(setting),
        setting
      });
    }
    return ret;
  }
  registerUpdates() {
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on(
        // @ts-ignore
        "dataview:metadata-change",
        (type, file) => {
          this.plugin.settings.items.forEach((setting) => {
            const previouslyExported = setting.lastExport[file.path];
            if (previouslyExported) {
              this.display.updateElementStatus(previouslyExported, setting);
            } else {
            }
          });
        }
      )
    );
  }
  /**
   * 1.- Finds all the files that are matching our filter in settings.
   * 2.- Updates file-explorer plugin with the proper exported status icons.
   * @returns
   */
  async searchFilesToExport(settings) {
    const dataViewApi = getDataViewApi();
    if (dataViewApi) {
      const initialQuery = normalizeQuery(
        settings.exportQuery
      );
      const data = await dataViewApi.query(initialQuery);
      if (data.successful) {
        const exportFileMap = createPathMap(
          // @ts-ignore
          data.value.values,
          settings
        );
        log(
          `Found ${data.value.values.length} files for`,
          ` filter: '${settings.exportQuery}'`,
          ` organized by: '${settings.outputFormat}'`
        );
        if (data.value && data.value.type === "table") {
          this.display.applyStatusIcons(exportFileMap, settings);
          return exportFileMap;
        } else {
          throw new Error("[Bulk Exporter]: return type error");
        }
      }
      error(`[Bulk Exporter] Error in Query: "${initialQuery}"`);
      error(data.error);
      console.error(data);
      throw new Error("[Bulk Exporter] Query Error");
    } else {
      new import_obsidian3.Notice("Meta-Dataview needs Dataview plugin to be installed.");
      error("[Bulk Exporter] Dataview plugin to be installed.");
      throw new Error("Dataview plugin to be installed.");
    }
  }
  async searchAndExport(settings) {
    const results = await this.searchFilesToExport(settings);
    let toBeExported = {};
    if (settings.isPublishedField) {
      Object.keys(results).map((path3) => {
        const fileMetaData = results[path3].frontMatter;
        if (fileMetaData[settings.isPublishedField]) {
          toBeExported[path3] = results[path3];
        }
      });
    } else {
      toBeExported = results;
    }
    const lastExport = await exportSelection(
      toBeExported,
      settings,
      this.plugin
    );
    Object.keys(lastExport).forEach((absoluteFilePath) => {
      const exportProperties = lastExport[absoluteFilePath];
      exportProperties.content = "";
      exportProperties.outputContent = "";
      exportProperties.file = void 0;
    });
    settings.lastExport = lastExport;
    this.plugin.saveSettings();
    this.display.applyStatusIcons(settings.lastExport, settings);
    return results;
  }
};
function getGroups(fileMap) {
  const ret = {};
  Object.keys(fileMap).forEach((filePath) => {
    const dir = fileMap[filePath].toRelativeToExportDirRoot;
    if (!ret[dir]) {
      ret[dir] = [];
    }
    ret[dir].push(fileMap[filePath]);
  });
  Object.keys(ret).forEach((pathGroup) => {
    ret[pathGroup] = sortBy(ret[pathGroup], "newFileName");
  });
  return ret;
}
async function exportSelection(fileList, settings, plugin) {
  var _a3;
  const start = new Date();
  const outputFolder = settings.outputFolder;
  const outputPathMap = {};
  log("=============================");
  log("Export to " + outputFolder);
  if (!(0, import_fs5.existsSync)(outputFolder)) {
    (0, import_fs5.mkdirSync)(outputFolder, { recursive: true });
    log("Created new target folder: " + outputFolder);
  }
  if (settings.emptyTargetFolder) {
    rmDirContent(settings.outputFolder);
  }
  for (const fileIndex in fileList) {
    const exportProperties = fileList[fileIndex];
    await convertAndCopy(
      outputFolder,
      exportProperties,
      fileList,
      settings,
      plugin
    );
    exportProperties.lastExportDate = new Date(
      (_a3 = exportProperties.file) == null ? void 0 : _a3.mtime
    ).getTime();
    outputPathMap[exportProperties.toRelativeToExportDirRoot] = outputPathMap[exportProperties.toRelativeToExportDirRoot] || [];
    outputPathMap[exportProperties.toRelativeToExportDirRoot].push(exportProperties);
  }
  exportedLogEntry(outputPathMap, plugin);
  if (settings.shell && settings.shell.trim()) {
    log("Starting shell script ", settings.shell);
    const shellStart = new Date();
    await runShellCommand(settings.shell);
    log("Finished shell script! ", (new Date().getTime() - shellStart.getTime()) / 1e3, "s");
  }
  new import_obsidian3.Notice("Exported to " + outputFolder);
  log(
    `Export took ${(new Date().getTime() - start.getTime()) / 1e3}s to ` + outputFolder
  );
  return fileList;
}
async function convertAndCopy(rootPath, fileExportProperties, allFileListMap, settings, plugin) {
  const targetDir = (0, import_path7.join)((0, import_path7.normalize)(rootPath), fileExportProperties.toRelativeToExportDirRoot);
  const fileDescriptor = fileExportProperties.file;
  if (!(0, import_fs5.existsSync)(targetDir)) {
    (0, import_fs5.mkdirSync)(targetDir, { recursive: true });
  }
  if (!fileDescriptor) {
    throw new Error("Null Error");
  }
  const fileContent = await plugin.app.vault.adapter.read(fileDescriptor.path);
  fileExportProperties.outputContent = fileExportProperties.content = fileContent;
  fileExportProperties.md5 = import_ts_md52.Md5.hashStr(fileContent);
  await collectAssetsReplaceLinks(fileExportProperties, allFileListMap, settings, plugin);
  (0, import_fs5.writeFileSync)(
    fileExportProperties.toAbsoluteFs,
    fileExportProperties.outputContent,
    "utf-8"
  );
  return fileExportProperties;
}

// src/utils/indexing/folder-meta.ts
var import_path8 = require("path");
var MAX_ENUM_LENGTH = 50;
function getMetaFields(mapOfFiles) {
  const resultsMap = {};
  Object.keys(mapOfFiles).forEach((filePath) => {
    const frontMatter = mapOfFiles[filePath].frontMatter;
    Object.keys(frontMatter).map((attributeKey) => {
      const value = frontMatter[attributeKey];
      const existingValues = resultsMap[attributeKey] || [];
      appendIfQualify(existingValues, value);
      if (index_default_default.isArray(value)) {
        value.forEach((subValue) => {
          appendIfQualify(existingValues, subValue);
        });
      }
      resultsMap[attributeKey] = index_default_default.uniq(existingValues);
    });
  });
  return resultsMap;
}
function appendIfQualify(array, value) {
  if (index_default_default.isNumber(value)) {
    array.push(value.toString());
  }
  if (index_default_default.isString(value) && value.length < MAX_ENUM_LENGTH) {
    array.push(value);
  }
}

// src/ui/header-selector-modal.ts
var import_obsidian4 = require("obsidian");
var HeaderFieldSelectorModal = class extends import_obsidian4.Modal {
  constructor(plugin, settings, headerFields, onSubmit) {
    super(plugin.app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
    this.enabled = settings.headerFieldsToShow;
    this.settings = settings;
    this.headerFields = headerFields;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Select metadata header display order" });
    this.preview = contentEl.createEl("input", {
      value: this.enabled.join(", "),
      cls: "meta-data-header-selector-input",
      placeholder: "*"
    });
    this.preview.addEventListener("change", () => {
      this.enabled = this.preview.value.split(",").map((s) => s.trim());
    });
    this.toggleWrapper = contentEl.createDiv({ cls: "meta-data-header-selector-scroller" });
    new import_obsidian4.Setting(contentEl).addButton((button) => {
      button.setButtonText("Clear");
      button.onClick(() => this.clear());
    }).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => {
      this.close();
      this.enabled = this.preview.value.split(",").map((s) => s.trim());
      this.settings.headerFieldsToShow = this.preview.value.split(",").map((s) => s.trim()).filter((s) => s);
      this.plugin.saveSettings();
      this.onSubmit(this.enabled);
    }));
    this.renderToggles();
  }
  clear() {
    this.enabled = [];
    this.preview.value = "";
    this.renderToggles();
  }
  renderToggles() {
    this.toggleWrapper.innerHTML = "";
    (this.headerFields || []).sort().map((fieldName) => {
      const isSelected = this.enabled.indexOf(fieldName) > -1;
      const toggler = this.toggleWrapper.createSpan({ text: fieldName, cls: isSelected ? "active" : "" });
      toggler.addEventListener("click", () => {
        if (this.enabled.indexOf(fieldName) === -1) {
          this.enabled.push(fieldName);
        } else {
          this.enabled.splice(this.enabled.indexOf(fieldName), 1);
        }
        this.preview.value = this.enabled.join(", ");
        toggler.classList.toggle("active");
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/obsidian-api-helpers/open-settings-page.ts
function open_settings_page_default(pluginId, plugin) {
  plugin.app.setting.open();
  plugin.app.setting.openTabById(pluginId);
}

// src/obsidian-api-helpers/show-in-folder.ts
var import_obsidian5 = require("obsidian");
function showFolderInSystemBrowserAbsolute(plugin, path3) {
  window.electron && (import_obsidian5.Platform.isMacOS ? electron.remote.shell : electron.shell).showItemInFolder(path3);
}

// src/ui/render-export.ts
var import_path9 = require("path");

// src/ui/stats-modal.ts
var import_obsidian6 = require("obsidian");
var LINK_LISTS = [
  "internalLinks",
  "externalLinks",
  "internalAttachments",
  "internalHeaderAttachments",
  "externalAttachments",
  "headerAttachments"
];
var StatsModal = class extends import_obsidian6.Modal {
  constructor(plugin, item) {
    super(plugin.app);
    this.item = item;
  }
  onOpen() {
    var _a3;
    const { contentEl } = this;
    contentEl.classList.add("bulk-export-stat-modal");
    contentEl.createEl("h1", { text: (_a3 = this.item.file) == null ? void 0 : _a3.path });
    const content = contentEl.createDiv({ cls: "content" });
    this.linkStats(content);
    this.globStats(content);
  }
  globStats(content) {
    if (this.item.copyGlob) {
      content.createEl("h2", "body raw files");
      Object.keys(this.item.copyGlob).forEach((selector) => {
        const groupDiv = content.createDiv();
        groupDiv.createEl("h3", { text: selector });
        if (this.item.copyGlob[selector] && this.item.copyGlob[selector].length) {
          this.item.copyGlob[selector].forEach((link) => {
            this.renderLink(link, groupDiv);
          });
        } else {
          groupDiv.createSpan({ text: "no files found" });
        }
      });
    }
  }
  linkStats(content) {
    if (this.noLinksOrAttachments()) {
      content.createEl("p", { text: "No attachments or links in file." });
    }
    LINK_LISTS.forEach((linkOrAttachmentGroupKey) => {
      if (this.item.linksAndAttachments && this.item.linksAndAttachments[linkOrAttachmentGroupKey]) {
        const linkGroup = this.item.linksAndAttachments[linkOrAttachmentGroupKey];
        if (linkGroup instanceof Array && linkGroup.length) {
          const groupDiv = content.createDiv();
          groupDiv.createEl("h3", { text: linkOrAttachmentGroupKey });
          linkGroup.forEach((link) => {
            this.renderLink(link, groupDiv);
          });
        }
      }
    });
  }
  noLinksOrAttachments() {
    return !LINK_LISTS.find((linkOrAttachmentGroupKey) => {
      if (this.item.linksAndAttachments && // @ts-ignore
      this.item.linksAndAttachments[linkOrAttachmentGroupKey] && // @ts-ignore
      this.item.linksAndAttachments[linkOrAttachmentGroupKey].length) {
        return true;
      }
    });
  }
  renderLink(link, groupDiv) {
    const linkDisplay = groupDiv.createDiv({
      cls: link.error ? "error link" : link.newPath ? "success link" : "link"
    });
    linkDisplay.createEl("a", {
      text: link.text,
      title: link.normalizedOriginalPath,
      cls: "title",
      href: link.originalPath
    });
    linkDisplay.createSpan({ text: link.normalizedOriginalPath, cls: "url" });
    if (link.newPath) {
      linkDisplay.createSpan({ text: `=> ${link.newPath}`, cls: "replaced" });
    }
    if (link.error) {
      linkDisplay.createDiv({ cls: "error", text: link.error });
      linkDisplay.prepend(getIcon("alert-triangle"));
    } else if (link.newPath) {
      linkDisplay.prepend(getIcon("check"));
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/status-icon.ts
function statusIcon(root2, item, settings, plugin) {
  var _a3;
  if (settings.isPublishedField) {
    if (!item.frontMatter[settings.isPublishedField]) {
      return;
    }
  }
  const iconSpanAddedAlready = root2.createSpan({ cls: "status-icon" });
  const alreadyExported = settings.lastExport[(_a3 = item.file) == null ? void 0 : _a3.path];
  iconSpanAddedAlready.addEventListener("click", () => {
    new StatsModal(plugin, alreadyExported || item).open();
  });
  if (alreadyExported) {
    if (modifiedSinceLastExport(item, alreadyExported)) {
      iconSpanAddedAlready.classList.add("orange");
      iconSpanAddedAlready.append(getIcon("file-plus"));
      iconSpanAddedAlready.title = "Modified Since Last Export";
    } else {
      const hadErrorsLastExport = hadErrors(alreadyExported);
      if (!hadErrorsLastExport) {
        iconSpanAddedAlready.classList.add("green");
        iconSpanAddedAlready.append(getIcon("check-circle"));
        iconSpanAddedAlready.title = "Up to date";
      } else {
        root2.classList.add("warn");
        const bugButton = iconSpanAddedAlready.createSpan({ title: JSON.stringify(hadErrorsLastExport, null, 2) });
        bugButton.append(getIcon("bug"));
      }
    }
  }
}
function hadErrors(alreadyExported) {
  if (!alreadyExported.linksAndAttachments) {
    return false;
  }
  const debugInfo = getDebugInfo(alreadyExported.linksAndAttachments);
  const errors = debugInfo.internalAttachmentsError.length || debugInfo.internalHeaderAttachmentsError.length || debugInfo.internalLinksError.length;
  return errors ? debugInfo : false;
}
function modifiedSinceLastExport(item, alreadyExported) {
  var _a3;
  const lastModifyDateOfFile = new Date((_a3 = item.file) == null ? void 0 : _a3.mtime).getTime();
  const lastExportedDate = new Date(
    alreadyExported.lastExportDate
  ).getTime();
  return lastModifyDateOfFile !== lastExportedDate;
}
function getDebugInfo(linksAndAttachments) {
  const internalLinksError = linksAndAttachments.internalLinks.filter((l) => l.error).map((l) => l.normalizedOriginalPath + " - " + l.error);
  const internalAttachmentsError = linksAndAttachments.internalAttachments.filter((l) => l.error).map((l) => l.normalizedOriginalPath + " - " + l.error);
  const internalHeaderAttachmentsError = linksAndAttachments.internalHeaderAttachments.filter((l) => l.error).map((l) => l.normalizedOriginalPath + " - " + l.error);
  return {
    internalLinksError,
    internalAttachmentsError,
    internalHeaderAttachmentsError
  };
}

// src/ui/render-export.ts
var OVERWRITE_LOCALE = "hu-HU";
var ExportTableRender = class {
  constructor(leaf, exportMap, settings, plugin) {
    const resultListEl = leaf.createEl("div", {
      cls: "nav-files-container meta-data-view-table-container"
    });
    this.leaf = resultListEl;
    this.settings = settings;
    this.plugin = plugin;
    this.exportMap = exportMap;
    this.groupMap = getGroups(exportMap);
    this.metaKeysToShow = getMetaFields(exportMap);
    this.metaFields = ["fileName"].concat(Object.keys(this.metaKeysToShow));
    if (this.settings.isPublishedField) {
      delete this.metaKeysToShow[this.settings.isPublishedField];
      this.isPublishedField = this.settings.isPublishedField;
      this.metaFields = ["fileName", this.settings.isPublishedField].concat(Object.keys(this.metaKeysToShow));
    }
    this.metaFieldsWithoutFileName = without_default(this.metaFields, "fileName");
    this.render();
  }
  render() {
    var _a3;
    if ((_a3 = this.settings.headerFieldsToShow) == null ? void 0 : _a3.length) {
      this.fieldsToRender = this.settings.headerFieldsToShow;
    } else {
      this.fieldsToRender = this.metaFieldsWithoutFileName;
    }
    this.leaf.innerHTML = "";
    const preHeader = this.leaf.createEl("h2", { text: this.settings.name });
    const tableRoot = this.leaf.createEl("table", { cls: "dataview table-view-table" });
    const tableHead = tableRoot.createEl("thead", { cls: "table-view-thead" });
    const tableHeadTr = tableHead.createEl("tr", { cls: "table-view-tr-header" });
    tableHeadTr.createEl("th", {
      cls: "table-view-th debug-column",
      attr: { "data-column-id": "fileName" }
    });
    const preHeaderButtons = preHeader.createSpan({ cls: "table-header-buttons" });
    const editHeaderFieldsLink = preHeaderButtons.createEl("span", {
      cls: "clickable table-header-link",
      title: "Edit Visible Header Fields"
    });
    editHeaderFieldsLink.append(getIcon("eye"));
    const editSettingsLink = preHeaderButtons.createEl("span", {
      cls: "clickable table-header-link",
      title: "Edit Export Settings"
    });
    editSettingsLink.append(getIcon("settings"));
    editSettingsLink.addEventListener("click", () => {
      this.plugin.settings.selected = this.plugin.settings.items.indexOf(this.settings);
      open_settings_page_default("bulk-exporter", this.plugin);
    });
    const openOutputFolderLink = preHeaderButtons.createEl("span", {
      cls: "clickable table-header-link",
      title: "Open Output Folder"
    });
    openOutputFolderLink.append(getIcon("folder-open"));
    openOutputFolderLink.addEventListener("click", () => {
      const outputFolder = (0, import_path9.join)(process.cwd(), this.settings.outputFolder) + "/";
      showFolderInSystemBrowserAbsolute(this.plugin, outputFolder);
    });
    this.fieldsToRender.forEach((name) => {
      const tableHeadTh = tableHeadTr.createEl("th", {
        cls: "table-view-th",
        attr: { "data-column-id": name }
      });
      tableHeadTr.append(tableHeadTh);
      tableHeadTh.createSpan({ text: name });
    });
    editHeaderFieldsLink.addEventListener("click", () => {
      new HeaderFieldSelectorModal(this.plugin, this.settings, this.metaFields, () => {
        this.render();
      }).open();
    });
    Object.keys(this.groupMap).forEach((group2) => {
      const tBody = tableRoot.createEl("tbody", { cls: "table-view-tbody" });
      this.renderFolderHeaderRow(tBody, group2, this.groupMap);
      this.groupMap[group2].forEach((file) => {
        this.renderFileRow(tBody, file);
      });
      this.leaf.appendChild(tableRoot);
    });
  }
  renderFileRow(tableBodyRoot, item) {
    const metaData = item.frontMatter;
    const group2 = item.toRelativeToExportDirRoot;
    const isOpen = (this.settings.groupOpenMap || {})[group2];
    const fileItemRow = tableBodyRoot.createEl("tr", {
      cls: "nav-file tree-item meta-data-table-file-row",
      attr: { "data-path": item.toRelativeToExportDirRoot, style: isOpen ? "" : "display: none" }
    });
    if (this.settings.isPublishedField && !metaData[this.settings.isPublishedField]) {
      fileItemRow.classList.add("draft");
    }
    const linkTd = fileItemRow.createEl("td", {
      cls: "nav-file-title tree-item-self debug-column"
    });
    statusIcon(linkTd, item, this.settings, this.plugin);
    fileItemRow.addEventListener("click", () => {
      revealInFolder(this.plugin, item.from);
    });
    fileItemRow.addEventListener("dblclick", () => {
      revealInFolder(this.plugin, item.from);
      openFileByPath(this.plugin, item.from);
    });
    this.fieldsToRender.forEach((metaKey) => {
      if (metaKey === "fileName") {
        this.renderMetaCell(fileItemRow, metaKey, item.newFileName);
      } else {
        this.renderMetaCell(fileItemRow, metaKey, metaData[metaKey]);
      }
    });
  }
  renderFolderHeaderRow(tableBodyRoot, group2, exportGroupMap) {
    const pathHeader = tableBodyRoot.createEl("tr", { cls: "table-sub-header tree-item" });
    const isOpen = (this.settings.groupOpenMap || {})[group2];
    const pathHeaderTd = pathHeader.createEl("td", {
      attr: { colspan: Object.keys(this.metaKeysToShow).length + 1 },
      cls: isOpen ? "" : "is-collapsed"
    });
    const title = pathHeaderTd.createDiv({ cls: "nav-folder-title mod-collapsible tree-item-self" });
    const collapseArrow = title.createDiv({
      cls: "nav-folder-collapse-indicator collapse-icon"
    });
    title.createEl("a", {
      cls: "nav-folder-title-content",
      text: group2
    });
    title.append(this.folderHeaderRowStats(exportGroupMap[group2]));
    collapseArrow.append(getIcon("chevron-down"));
    pathHeaderTd.addEventListener("click", (evt) => this.collapseHeaderRow(evt, pathHeaderTd, tableBodyRoot, group2));
    collapseArrow.addEventListener("click", (evt) => this.collapseHeaderRow(evt, pathHeaderTd, tableBodyRoot, group2));
  }
  collapseHeaderRow(event, pathHeaderTd, tableBodyRoot, group2) {
    event.stopPropagation();
    pathHeaderTd.classList.toggle("is-collapsed");
    const isOpen = !pathHeaderTd.classList.contains("is-collapsed");
    this.settings.groupOpenMap = this.settings.groupOpenMap || {};
    this.settings.groupOpenMap[group2] = isOpen;
    this.plugin.saveSettings();
    const elements = tableBodyRoot.querySelectorAll(`.meta-data-table-file-row[data-path="${group2}"]`);
    if (elements) {
      elements.forEach((el) => el.style.display = isOpen ? "table-row" : "none");
    }
  }
  folderHeaderRowStats(list) {
    const allInFolder = list.length;
    const metadataWrapper = createSpan({ cls: "metadata" });
    if (this.settings.isPublishedField) {
      const draftsInFolder = this.countDraftsInFolder(list);
      const publishedInFolder = allInFolder - draftsInFolder;
      if (draftsInFolder > 0) {
        metadataWrapper.title = "Published / Draft = " + allInFolder;
        metadataWrapper.createSpan({
          text: String(publishedInFolder),
          cls: "metadata-published"
        });
        metadataWrapper.append("/");
        metadataWrapper.createSpan({
          text: String(draftsInFolder),
          cls: "metadata-draft"
        });
      } else {
        metadataWrapper.append(String(allInFolder));
      }
    } else {
      metadataWrapper.append(String(allInFolder));
    }
    return metadataWrapper;
  }
  countDraftsInFolder(list) {
    return list.filter((e) => {
      return Boolean(e.frontMatter[this.settings.isPublishedField]);
    }).length;
  }
  renderMetaCell(fileItemRow, metaKey, value) {
    const td = fileItemRow.createEl("td", { cls: "data-view-meta-key" });
    if (metaKey === "tags" && value instanceof Array) {
      value.forEach((tag, i) => {
        td.createSpan({ cls: "tag-link", text: tag });
        if (i < value.length - 1)
          td.createSpan({ text: ", " });
      });
    } else if (typeof value === "string" && isHttpUrl(value.trim())) {
      createLink(td, value, "\u{1F517} " + new import_url4.URL(value).hostname, value);
    } else if (typeof value === "string" && isNumber(value)) {
      td.createSpan({ text: value, cls: "number" });
    } else if (value && typeof value === "string" && value.indexOf(" ") === -1) {
      if (isValidDate(new Date(value))) {
        const date = new Date(value);
        let display = date.toLocaleDateString(OVERWRITE_LOCALE);
        if (!(date.getHours() === 0 && date.getMinutes() === 0)) {
          display += " " + date.toLocaleTimeString();
        }
        td.createSpan({ cls: "meta-value date", text: display, attr: { title: value } });
      } else {
        td.createSpan({ text: value });
      }
    } else if (value instanceof Array) {
      td.createSpan({ cls: "meta-value", text: value.join(", ") });
    } else if (value instanceof Object) {
      td.createEl("button", { cls: "meta-value", text: "JS Object", attr: { title: JSON.stringify(value, null, 2) } });
      td.addEventListener("click", () => {
        new import_obsidian7.Notice("Copied to clipboard! \n" + JSON.stringify(value, null, 2));
        navigator.clipboard.writeText(JSON.stringify(value, null, 2));
      });
    } else if (value === void 0) {
      td.classList.add("undefined");
    } else if (typeof value === "boolean") {
      td.classList.add("boolean");
      td.createEl("input", { attr: { type: "checkbox", disabled: true, checked: value } });
    } else {
      td.createSpan({ cls: "meta-value", text: value });
    }
  }
  remove() {
    this.leaf.remove();
  }
};
function isNumber(string) {
  return string.match(/^[0-9]+\.?[0-9]*$/);
}
function isValidDate(date) {
  return date instanceof Date && isFinite(+date);
}

// src/ui/button-with-loader.ts
var DEFAULT_BUTTON_PROPERTIES = {
  domElementName: "button",
  domElementInfo: { text: "Save" },
  iconId: "folder-input",
  loadingIconId: "loader-2",
  errorIconId: "alert-circle"
};
var ButtonWithLoader = class {
  constructor(root2, params, onClick, onError) {
    const buttonWithLoaderSettings = Object.assign({}, DEFAULT_BUTTON_PROPERTIES, params);
    const button = root2.createEl("button", buttonWithLoaderSettings.domElementInfo);
    const icon = getIcon(buttonWithLoaderSettings.iconId);
    const loadingIcon = getIcon(buttonWithLoaderSettings.loadingIconId);
    const errorIcon = getIcon(buttonWithLoaderSettings.errorIconId);
    loadingIcon.style.display = "none";
    loadingIcon.classList.add("spin");
    errorIcon.style.display = "none";
    button.append(icon, loadingIcon, errorIcon);
    button.classList.add("with-icon");
    button.addEventListener("click", async (evt) => {
      icon.style.display = "none";
      loadingIcon.style.display = "block";
      errorIcon.style.display = "none";
      button.disabled = true;
      try {
        await onClick(evt);
        loadingIcon.style.display = "none";
        icon.style.display = "block";
      } catch (e) {
        loadingIcon.style.display = "none";
        errorIcon.style.display = "block";
        onError(e);
      }
      button.disabled = false;
    });
  }
};

// src/ui/select.ts
var Select = class {
  constructor(rootElement, items, onChange, domInfo) {
    const select = rootElement.createEl("select", domInfo);
    items.forEach((listItem) => {
      select.createEl("option", { value: listItem.value, text: listItem.text });
    });
    if (domInfo == null ? void 0 : domInfo.value) {
      select.value = domInfo.value;
    }
    select.addEventListener("change", (evt) => {
      onChange(evt, select.value);
    });
  }
};

// src/view.ts
var META_DATA_VIEW_TYPE = "bulk-exporter-preview";
var BulkExporterView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.exporter = this.plugin.exporter;
  }
  getIcon() {
    return "folder-input";
  }
  getViewType() {
    return META_DATA_VIEW_TYPE;
  }
  getDisplayText() {
    return "Bulk Export Preview";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.classList.add("meta-data-view");
    this.header = container.createDiv();
    this.settingsHeader = container.createDiv();
    this.settingsHeader.style.display = "none";
    this.error = container.createDiv();
    this.resultsContainer = container.createDiv();
    this.log = this.settingsHeader.createDiv();
    this.clearLogButton = this.log.createEl("button", { text: "Clear", cls: "clear-log-button" });
    this.clearLogButton.addEventListener("click", () => {
      this.log.querySelectorAll(".log-entry").forEach((e) => e.remove());
    });
    setLogOutput(this.log);
    log("Hey! Single click on the file name to reveal it in the sidebar, double click to open it!");
    this.topRightMenuContainer = this.header.createDiv({
      cls: "top-right-button-container"
    });
    this.refreshButton = this.topRightMenuContainer.createEl("button", { title: "Refresh" });
    this.refreshButton.append(getIcon("refresh-cw"));
    this.refreshButton.addEventListener("click", () => {
      this.refresh();
    });
    this.logButton = this.topRightMenuContainer.createEl("button", { title: "Show Log" });
    this.logButton.append(getIcon("bug"));
    this.logButton.addEventListener("click", () => {
      this.settingsHeader.style.display = this.settingsHeader.style.display === "none" ? "block" : "none";
    });
    this.settingsButton = this.topRightMenuContainer.createEl("button", { title: "Open Plugin Settings" });
    this.settingsButton.append(getIcon("settings"));
    this.settingsButton.addEventListener("click", () => {
      open_settings_page_default("bulk-exporter", this.plugin);
    });
    new ButtonWithLoader(
      this.topRightMenuContainer,
      {
        domElementInfo: { text: "Export " }
      },
      async () => {
        if (this.plugin.settings.preview === "all") {
          try {
            this.resultsContainer.innerText = "";
            const list = await this.exporter.searchAndExportAll();
            list.forEach(({ setting, results }) => {
              this.renderPreviewTable(results, setting);
            });
          } catch (e) {
            this.settingsHeader.style.display = "block";
            console.error(e);
          }
        } else {
          const selectedIndex = parseInt(this.plugin.settings.preview);
          const setting = this.plugin.settings.items[selectedIndex];
          await this.exporter.searchAndExport(setting);
        }
        await this.refresh();
      },
      (e) => {
        error((e == null ? void 0 : e.message) || "Something went wrong with the export, see log!");
        this.settingsHeader.style.display = "block";
        this.log.style.display = "block";
      }
    );
    const h = this.header.createEl("h4");
    if (this.plugin.settings.items.length > 1) {
      this.renderSelector(h);
    } else {
      h.setText("Bulk Exporter Preview " + this.plugin.settings.items[0].name);
    }
    this.refresh();
  }
  async refresh() {
    this.resultsContainer.innerText = "";
    if (this.plugin.settings.preview === "all") {
      try {
        const results = await this.exporter.searchAll();
        results.forEach(({ setting, results: results2 }) => {
          this.renderPreviewTable(results2, setting);
        });
      } catch (e) {
        this.settingsHeader.style.display = "block";
        console.error(e);
      }
    } else {
      const selectedIndex = parseInt(this.plugin.settings.preview);
      const setting = this.plugin.settings.items[selectedIndex];
      const results = await this.exporter.searchFilesToExport(setting);
      this.renderPreviewTable(results, setting);
    }
  }
  /**
   * Group by the exported folder and order by one of the fields
   * @param results
   */
  renderPreviewTable(results, settings) {
    this.exportTable = new ExportTableRender(
      this.resultsContainer,
      results,
      settings,
      this.plugin
    );
  }
  renderSelector(root2) {
    const selectItems = this.plugin.settings.items.map((setting, i) => {
      return { text: setting.name, value: String(i) };
    });
    selectItems.unshift({ text: "-- All --", value: "all" });
    new Select(root2, selectItems, (evt, selectedId) => {
      this.plugin.settings.preview = selectedId === "all" ? "all" : selectedId;
      if (selectedId === "all") {
        this.resultsContainer.innerText = "";
      } else {
        this.plugin.settings.selected = parseInt(selectedId);
      }
      this.refresh();
      this.plugin.saveSettings();
    }, { value: this.plugin.settings.preview });
  }
  async onClose() {
  }
};

// src/settings/export-settings-tab.ts
var import_obsidian10 = require("obsidian");

// src/models/bulk-export-settings.ts
var DEFAULT_SETTINGS = {
  name: "export set",
  outputFolder: "output",
  exportQuery: "blog",
  emptyTargetFolder: false,
  isPublishedField: "",
  assetPath: "assets",
  outputFormat: "${blog}/${slug}",
  lastExport: {},
  shell: "",
  headerFieldsToShow: [],
  groupOpenMap: {},
  absoluteAssets: false
};

// src/ui/confirm-modal.ts
var import_obsidian9 = require("obsidian");
var DEFAULT_SETTINGS2 = {
  question: "Are you sure?",
  okText: "Yes",
  okIcon: "check",
  okClass: "",
  cancelText: "Cancel",
  okCallback: () => {
  }
};
var ConfirmModal = class extends import_obsidian9.Modal {
  constructor(app, settings) {
    super(app);
    this.settings = Object.assign({}, DEFAULT_SETTINGS2, settings);
  }
  onOpen() {
    this.contentEl.classList.add("bulk-export-confirm");
    this.contentEl.setText(this.settings.question);
    this.contentEl.createDiv({ cls: "footer" });
    const okBtn = this.contentEl.createEl("button", {
      text: this.settings.okText,
      cls: this.settings.okClass + " yes"
    });
    okBtn.addEventListener("click", () => {
      if (this.settings.okCallback) {
        this.settings.okCallback();
      }
      this.close();
    });
    const cancelBtn = this.contentEl.createEl("button", {
      text: this.settings.cancelText,
      cls: "cancel"
    });
    cancelBtn.addEventListener("click", this.close);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/settings/export-settings-tab.ts
var OutputSettingTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("bulk-export-settings");
    const linkToIssues = createEl("a", { href: "https://github.com/symunona/obsidian-bulk-exporter/issues", text: "Github Issue Tracker" });
    const genericInfo = createSpan({ text: "Export a certain subset of your notes, based on whether they match a DataView query. Bug reports and Feature Requests are welcome at " });
    genericInfo.append(linkToIssues);
    const genericFragment = document.createDocumentFragment();
    genericFragment.append(genericInfo);
    new import_obsidian10.Setting(containerEl).setName("Bulk Exporter").setDesc(genericFragment);
    this.header = containerEl.createDiv({ cls: "bulk-export-settings-header" });
    this.tabs = containerEl.createDiv({ cls: "bulk-export-settings-tabs" });
    this.buttons = this.plugin.settings.items.map(
      (setting, index) => this.createButton(setting)
    );
    this.buttons.map((e) => this.header.append(e));
    const addBtn = this.header.createEl("button", { cls: "tab-header add-element", text: "+" });
    addBtn.addEventListener("click", () => {
      var _a3;
      const newSetting = Object.assign({}, DEFAULT_SETTINGS, this.plugin.settings.items[this.plugin.settings.selected]);
      newSetting.name += " Copy";
      newSetting.groupOpenMap = {};
      newSetting.lastExport = {};
      this.plugin.settings.items.push(newSetting);
      const newBtn = this.createButton(newSetting);
      this.buttons.push(newBtn);
      (_a3 = addBtn.parentNode) == null ? void 0 : _a3.insertBefore(newBtn, addBtn);
      this.selectSetting(newSetting);
    });
    this.selectSetting();
  }
  selectSetting(setting) {
    if (setting) {
      this.renderSettingsPage(this.tabs, setting);
    } else if (this.plugin.settings.items.length === 0) {
      this.plugin.settings.items.push(Object.assign({}, DEFAULT_SETTINGS));
      this.renderSettingsPage(this.tabs, this.plugin.settings.items[0]);
    } else if (this.plugin.settings.items.length === 1) {
      this.renderSettingsPage(this.tabs, this.plugin.settings.items[0]);
    } else if (this.plugin.settings.items.length > this.plugin.settings.selected) {
      this.renderSettingsPage(this.tabs, this.plugin.settings.items[this.plugin.settings.selected]);
    } else {
      this.renderSettingsPage(this.tabs, this.plugin.settings.items[0]);
    }
  }
  createButton(setting) {
    const button = createEl("button", { cls: "tab-header", text: setting.name || "no-name" });
    button.addEventListener("click", async () => {
      this.plugin.settings.selected = this.plugin.settings.items.indexOf(setting);
      this.selectSetting(setting);
      await this.plugin.saveSettingsWithRefresh();
    });
    return button;
  }
  renderSettingsPage(containerEl, settings) {
    containerEl.empty();
    this.plugin.settings.selected = this.plugin.settings.items.indexOf(settings);
    this.buttons.forEach((b) => b.classList.remove("active"));
    this.buttons[this.plugin.settings.selected].classList.add("active");
    new import_obsidian10.Setting(containerEl).setName("Name of the export set").addText(
      (text) => text.setPlaceholder("default").setValue(settings.name).onChange(async (value) => {
        settings.name = value;
        this.buttons[this.plugin.settings.selected].setText(settings.name || "-- no name --");
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Export Target Folder").setDesc("Which folder do you want to export converted markdown files with their assets?").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.outputFolder).setValue(settings.outputFolder).onChange(async (value) => {
        settings.outputFolder = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    const linkToDataViewDocs = createEl("a", { href: "https://blacksmithgu.github.io/obsidian-dataview/queries/data-commands/", text: "DataView Language Specs" });
    const filterInfo = createSpan({ text: `Use a DataView style query for matching your metadata. Example: "blog='personal'". For more, see ` });
    filterInfo.append(linkToDataViewDocs);
    const filterInfoFragment = document.createDocumentFragment();
    filterInfoFragment.append(filterInfo);
    new import_obsidian10.Setting(containerEl).setName("Filter Query").setDesc(filterInfoFragment).addText(
      (text) => text.setPlaceholder("default").setValue(settings.exportQuery).onChange(async (value) => {
        settings.exportQuery = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    const linkToDocs = createEl("a", { href: "https://github.com/symunona/obsidian-bulk-exporter", text: "Docs" });
    const filenameInfo = createSpan({ text: 'You can define the output path with the following JS expression. Example: "${blog}/${created.date}-${slug}" - see ' });
    filenameInfo.append(linkToDocs);
    const exportFileNameInfoFragment = document.createDocumentFragment();
    exportFileNameInfoFragment.append(filenameInfo);
    new import_obsidian10.Setting(containerEl).setName("Output Filename and Path").setDesc(exportFileNameInfoFragment).addText(
      (text) => text.setPlaceholder("${blog}/${slug}").setValue(settings.outputFormat).onChange(async (value) => {
        settings.outputFormat = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Empty target folder on each export").setDesc("if true, the target folder contents will be erased every time. This can be good for getting rid of deleted blog posts, as by default the plugin does not track the ones that were deleted. Note that the ROOT of the folder is NOT deleted if everything is ordered in folders, so if you want to have your blogs in a monorepo, you can do so.").addToggle(
      (text) => text.setValue(settings.emptyTargetFolder).onChange(async (value) => {
        settings.emptyTargetFolder = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    containerEl.createEl("h2", { text: "Preview" });
    new import_obsidian10.Setting(containerEl).setName("Published Field / Drafts").setDesc("If provided, files that DO NOT have this field in their front matter will be shown on the file tree and the export preview, but will not get actually exported.").addText(
      (text) => text.setPlaceholder("key of the meta value, like draft").setValue(settings.isPublishedField).onChange(async (value) => {
        settings.isPublishedField = value.trim();
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Visible Columns").setDesc("Same as clicking on the eye icon").addText(
      (text) => text.setPlaceholder("*").setValue(settings.headerFieldsToShow.join(", ")).onChange(async (value) => {
        settings.headerFieldsToShow = value.split(",").map((v) => v.trim()).filter((v) => v);
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    containerEl.createEl("h2", { text: "Attachments and Links" });
    new import_obsidian10.Setting(containerEl).setName("Flatten attachments to File Root").setDesc("if true, all attachments will go to the file root's asset folder.").addToggle(
      (text) => text.setValue(settings.absoluteAssets).onChange(async (value) => {
        settings.absoluteAssets = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    new import_obsidian10.Setting(containerEl).setName("Attachment / Asset folder name").setDesc("Relative to the file's export path, or absolute, to the file's Attachment and link root above.").addText(
      (text) => text.setPlaceholder("assets").setValue(settings.assetPath).onChange(async (value) => {
        settings.assetPath = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    containerEl.createEl("h2", { text: "" });
    new import_obsidian10.Setting(containerEl).setName("Run Script After Export").setDesc("Place here anything you want to run after the export is done. Uses child_process.spawn.").addText(
      (text) => text.setPlaceholder("shell script path").setValue(settings.shell).onChange(async (value) => {
        settings.shell = value;
        await this.plugin.saveSettingsWithRefresh();
      })
    );
    if (this.plugin.settings.items.length > 1) {
      containerEl.createEl("hr");
      const deleteButton = containerEl.createEl("button", { text: "Delete this Export Settings", cls: "danger" });
      deleteButton.addEventListener("click", () => {
        new ConfirmModal(this.plugin.app, {
          okClass: "danger",
          okText: "Delete",
          okCallback: () => {
            this.plugin.settings.items.splice(this.plugin.settings.selected, 1);
            this.plugin.saveSettingsWithRefresh();
            this.buttons[this.plugin.settings.selected].remove();
            this.selectSetting();
          }
        }).open();
      });
    }
  }
};

// src/utils/data-parser.ts
function parseSavedSettingsData(storedData) {
  if (storedData) {
    if (!(storedData.items instanceof Array)) {
      return {
        selected: 0,
        preview: "all",
        items: [Object.assign(
          {},
          DEFAULT_SETTINGS,
          storedData
        )]
      };
    } else {
      const settings = Object.assign({ items: [], selected: 0, preview: "all" }, storedData);
      if (!settings.items.length) {
        settings.items.push(Object.assign({}, DEFAULT_SETTINGS));
      }
      return settings;
    }
  } else {
    return {
      selected: 0,
      preview: "all",
      items: [
        Object.assign({}, DEFAULT_SETTINGS)
      ]
    };
  }
}

// src/main.ts
var BulkExporterPlugin = class extends import_obsidian11.Plugin {
  constructor() {
    super(...arguments);
    this.inited = false;
    this.debouncedRefresh = debounce(() => {
      var _a3;
      if ((_a3 = this.app.workspace.getLeavesOfType(META_DATA_VIEW_TYPE)) == null ? void 0 : _a3.length) {
        const view = this.app.workspace.getLeavesOfType(META_DATA_VIEW_TYPE)[0].view;
        view.refresh();
      }
    }, 1e3);
  }
  async onload() {
    await this.loadSettings();
    this.exporter = new Exporter(this);
    this.exporter.registerUpdates();
    this.registerView(
      META_DATA_VIEW_TYPE,
      (leaf) => new BulkExporterView(leaf, this)
    );
    this.addRibbonIcon(
      "folder-input",
      "Bulk Exporter Preview",
      (evt) => {
        this.activateView();
      }
    );
    this.addCommand({
      id: "bulk-export",
      name: "Bulk Export",
      callback: () => {
        this.exporter.searchAndExportAll();
        this.activateView();
      }
    });
    this.addSettingTab(new OutputSettingTab(this.app, this));
    this.registerEvent(
      this.app.metadataCache.on("resolved", async () => {
        if (!this.inited) {
          this.exporter.searchAll();
          this.inited = true;
        } else {
        }
      })
    );
  }
  onunload() {
    this.exporter.display.clean();
  }
  async loadSettings() {
    this.settings = parseSavedSettingsData(await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async saveSettingsWithRefresh() {
    await this.saveSettings();
    this.debouncedRefresh();
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(META_DATA_VIEW_TYPE);
    await this.app.workspace.getLeaf(false).setViewState({
      type: META_DATA_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(META_DATA_VIEW_TYPE)[0]
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
